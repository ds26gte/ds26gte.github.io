<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <script src="../codemirror.js"></script>
  <script src="../runmode.js"></script>
  <script src="../pyret.js"></script>
  <script src="../hilite.js"></script>
  <link rel="stylesheet" type="text/css" href="../codemirror.css" title="default"/>
  <link rel="stylesheet" type="text/css" href="../pyret.css" title="default"/>
  <link rel="stylesheet" type="text/css" href="../styles.css" title="default"/>
  <head>
    <title>Testing</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="testing" toclevel="1" tocentry="yes">Testing</h1><p><span></span></p><h2 id="testing-blocks" toclevel="2" tocentry="yes"><span class="pyret-highlight"><tt class="pyretexpr">check:</tt></span> and <span class="pyret-highlight"><tt class="pyretexpr">where:</tt></span> blocks</h2><p>Tests in Pyret are written in special <i>testing blocks</i>.  These blocks can contain any Pyret code that isn’t toplevel-only (like data definitions and import or provide statements), and are the only places where <a href="lang/testing.html#testing-operators">Testing Operators</a> can be used.</p><h3 id="--check:--blocks" toclevel="3" tocentry="yes"><span class="pyret-highlight"><tt class="pyretexpr">check:</tt></span> blocks</h3><p>The simplest testing blocks are <span class="pyret-highlight"><tt class="pyretexpr">check:</tt></span> blocks.  They can be written at the top-level or inside other testing blocks.  Check blocks are a unit of reporting test results, so all the test operators that evaluate inside a check block will be reported as part of that block.  For example, these two check blocks:</p><pre class="pyret-highlight">check "a first block":
  5 is 5
  4 is 5
end

check "a second block":
  6 is 7
end</pre><p>will report:</p><pre class="nothing_special">Check block: a first block
  test (5 is 5): ok
  test (4 is 5): failed, reason:
    Values not equal:
    4
    5
  1/2 tests passed in check block: a first block

Check block: a second block
  test (6 is 7): failed, reason:
    Values not equal:
    6
    7
  The test failed.

1/3 tests passed in all check blocks</pre><p>Testing blocks are also a unit of failure: most of the time an error stops the whole program, but inside a check block (and also inside <a href="../lang/testing.html#raises"><span class="pyret-highlight"><tt class="pyretexpr">raises</tt></span></a>, mentioned later), the error is stopped and reported, and Pyret goes on to evaluating the next check block:</p><pre class="pyret-highlight">check "error-block":
  raise("an error here doesn't stop the next check block from running")
  string-length("this test doesn't run") is 21
end

check "a later block":
  string-length("these tests still run") is 21
end</pre><p>Keep an eye out for the message <span class="pyret-highlight"><tt class="pyretexpr">“Check block &lt;some-block&gt; ended in an error (all tests may not have run):”</tt></span>, because it means that later tests in the same block may not have run, so the output doesn’t reflect all the tests that were written.</p><h3 id="--where:--blocks" toclevel="3" tocentry="yes"><span class="pyret-highlight"><tt class="pyretexpr">where:</tt></span> blocks</h3><p>Sometimes a function has tests that are explicitly associated with it.  For these cases, the function can end in a <span class="pyret-highlight"><tt class="pyretexpr">where:</tt></span> block rather than immediately with <span class="pyret-highlight"><tt class="pyretexpr">end</tt></span>.  <span class="pyret-highlight"><tt class="pyretexpr">where:</tt></span> blocks run the same way that <span class="pyret-highlight"><tt class="pyretexpr">check:</tt></span> blocks do, and their name is taken from the function they are attached to.</p><div><p><b>Examples:</b></p><pre class="pyret-highlight">fun double(n):
  n + n
where:
  double(10) is 20
  double(15) is 30
end</pre></div><h2 id="testing-operators" toclevel="2" tocentry="yes">Testing Operators</h2><p>Testing operators should be written on their own line inside a <span class="pyret-highlight"><tt class="pyretexpr">check:</tt></span> or <span class="pyret-highlight"><tt class="pyretexpr">where:</tt></span> block.  They can check for a number of properties and come in several forms.</p><h3 id="Binary-Test-Operators" toclevel="3" tocentry="yes">Binary Test Operators</h3><p>Many useful tests compare two values, whether for a specific type of <a href="lang/equality.html#equality">equality</a> or a more sophisticated predicate.</p><div><p><span><a name="is"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is">is</a> expr2</pre></div><p>Evaluates <span class="pyret-highlight"><tt class="pyretexpr">expr1</tt></span> and <span class="pyret-highlight"><tt class="pyretexpr">expr2</tt></span> to values, and checks if two values are equal via <a href="../lang/equality.html#equal-always"><span class="pyret-highlight"><tt class="pyretexpr">equal-always</tt></span></a>, reporting success if they are equal, and failure if they are not.</p><div><p><span><a name="is-not"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is-not">is-not</a> expr2</pre></div><p>Like <a href="../lang/testing.html#is"><span class="pyret-highlight"><tt class="pyretexpr">is</tt></span></a>, but failure and success are reversed.</p><div><p><span><a name="is-roughly"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is-roughly">is-roughly</a> expr2</pre></div><p>Like <a href="../lang/testing.html#is"><span class="pyret-highlight"><tt class="pyretexpr">is</tt></span></a>, but tolerant of roughnum values: specifically, this is a shorthand for <a href="../lang/testing.html#is%"><span class="pyret-highlight"><tt class="pyretexpr">is%</tt></span></a>(<a href="../lang/equality.html#within"><span class="pyret-highlight"><tt class="pyretexpr">within</tt></span></a>(0.000001)).</p><div><p><span><a name="is%"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is%">is%</a>(pred) expr2</pre></div><p>Evaluates <span class="pyret-highlight"><tt class="pyretexpr">expr1</tt></span> and <span class="pyret-highlight"><tt class="pyretexpr">expr2</tt></span> to values, and <span class="pyret-highlight"><tt class="pyretexpr">pred</tt></span> to a value that must be a function (an error is reported if <span class="pyret-highlight"><tt class="pyretexpr">pred</tt></span> is not a function).  It then applies <span class="pyret-highlight"><tt class="pyretexpr">pred</tt></span> to the two values from <span class="pyret-highlight"><tt class="pyretexpr">expr1</tt></span> and <span class="pyret-highlight"><tt class="pyretexpr">expr2</tt></span>.  If the result of that call is <span class="pyret-highlight"><tt class="pyretexpr">true</tt></span>, reports success, otherwise reports failure.</p><div><p><span><a name="is-not%"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is-not%">is-not%</a>(pred) expr2</pre></div><p>Like <a href="../lang/testing.html#is%"><span class="pyret-highlight"><tt class="pyretexpr">is%</tt></span></a>, but failure and success are reversed.</p><div><p><b>Examples:</b></p><pre class="pyret-highlight">check:
  fun less-than(n1, n2): n1 &lt; n2 end

  1 is%(less-than) 2
  2 is-not%(less-than) 1
end

check:
  fun longer-than(s1, s2):
    string-length(s1) &gt; string-length(s2)
  end

  "abc" is%(longer-than) "ab"
  "" is-not%(longer-than) ""
end

check:
  fun equal-any-order&lt;a&gt;(l1 :: List&lt;a&gt;, l2 :: List&lt;a&gt;):
    same-length = (l1.length() == l2.length())
    all-present = for lists.all(elt from l1):
      lists.member(l2, elt)
    end
    same-length and all-present
  end

  [list: 1, 2, 3] is%(equal-any-order) [list: 3, 2, 1]
  [list: 1, 2, 3] is%(equal-any-order) [list: 2, 1, 3]
  [list: 1, 2, 3, 3] is-not%(equal-any-order) [list: 2, 1, 3]
end

check:
  fun one-of(ans, elts):
    lists.member(elts, ans)
  end

  some-strings = [list: "123", "132", "213", "231", "312", "321"]
  "321" is%(one-of) some-strings
  "123" is%(one-of) some-strings
end

check:
  fun around(delta):
    lam(actual, target):
      num-abs(target - actual) &lt;= delta
    end
  end

  5.05 is%(around(0.1)) 5
  5.00002 is-not%(around(0.00001)) 5
end</pre></div><div><p><span><a name="is=="></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is==">is==</a> expr2</pre></div><p>Shorthand for <tt class="pyret-display">expr1 <a href="../lang/testing.html#is%">is%</a>(<a href="../lang/equality.html#equal-always"><span class="pyret-highlight"><tt class="pyretexpr">equal-always</tt></span></a>) expr2</tt>. Same as <a href="../lang/testing.html#is"><span class="pyret-highlight"><tt class="pyretexpr">is</tt></span></a>.</p><div><p><span><a name="is-not=="></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is-not==">is-not==</a> expr2</pre></div><p>Like <a href="../lang/testing.html#is=="><span class="pyret-highlight"><tt class="pyretexpr">is==</tt></span></a>, but failure and success are reversed. Same as <a href="../lang/testing.html#is-not"><span class="pyret-highlight"><tt class="pyretexpr">is-not</tt></span></a>.</p><div><p><span><a name="is=~"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is=~">is=~</a> expr2</pre></div><p>Shorthand for <tt class="pyret-display">expr1 <a href="../lang/testing.html#is%">is%</a>(<a href="../lang/equality.html#equal-now"><span class="pyret-highlight"><tt class="pyretexpr">equal-now</tt></span></a>) expr2</tt></p><div><p><span><a name="is-not=~"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is-not=~">is-not=~</a> expr2</pre></div><p>Like <a href="../lang/testing.html#is=~"><span class="pyret-highlight"><tt class="pyretexpr">is=~</tt></span></a>, but failure and success are reversed.</p><div><p><span><a name="is&lt;=&gt;"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is&lt;=&gt;">is&lt;=&gt;</a> expr2</pre></div><p>Shorthand for <tt class="pyret-display">expr1 <a href="../lang/testing.html#is%">is%</a>(<a href="../lang/equality.html#identical"><span class="pyret-highlight"><tt class="pyretexpr">identical</tt></span></a>) expr2</tt></p><div><p><span><a name="is-not&lt;=&gt;"></a></span></p><pre class="pyret-display">expr1 <a href="../lang/testing.html#is-not&lt;=&gt;">is-not&lt;=&gt;</a> expr2</pre></div><p>Like <a href="../lang/testing.html#is&lt;=&gt;"><span class="pyret-highlight"><tt class="pyretexpr">is&lt;=&gt;</tt></span></a>, but failure and success are reversed.</p><h3 id="Unary-Test-Operators" toclevel="3" tocentry="yes">Unary Test Operators</h3><div><p><span><a name="satisfies"></a></span></p><pre class="pyret-display">expr <a href="../lang/testing.html#satisfies">satisfies</a> pred</pre></div><p>Evaluates <span class="pyret-highlight"><tt class="pyretexpr">expr</tt></span> to a value and <span class="pyret-highlight"><tt class="pyretexpr">pred</tt></span> to a value expected to be a function (if not a function, an error is thrown).  Then, <span class="pyret-highlight"><tt class="pyretexpr">pred(val)</tt></span> is evaluated, and if the result is <span class="pyret-highlight"><tt class="pyretexpr">true</tt></span>, the test succeeds, and if <span class="pyret-highlight"><tt class="pyretexpr">false</tt></span>, the test fails.</p><div><p><span><a name="violates"></a></span></p><pre class="pyret-display">expr <a href="../lang/testing.html#violates">violates</a> pred</pre></div><p>Like <a href="../lang/testing.html#satisfies"><span class="pyret-highlight"><tt class="pyretexpr">satisfies</tt></span></a>, but failure and success are reversed.</p><div><p><b>Examples:</b></p><pre class="pyret-highlight">check:
  [list:] satisfies is-empty
  [list:] satisfies lam(l): l.length() == 0 end

  is-odd = lam(n :: Number): num-modulo(n, 2) == 1 end
  5 satisfies is-odd
  6 violates is-odd
end</pre></div><h3 id="Exception-Test-Operators" toclevel="3" tocentry="yes">Exception Test Operators</h3><div><p><span><a name="raises"></a></span></p><pre class="pyret-display">expr <a href="../lang/testing.html#raises">raises</a> exn-string</pre></div><p>Evaluates <span class="pyret-highlight"><tt class="pyretexpr">expr</tt></span> and expects an error to be raised.  If no error is raised, the test fails.</p><p>If an error is the result, the <a href="../trove/globals.html#torepr"><span class="pyret-highlight"><tt class="pyretexpr">torepr</tt></span></a> function is called on the exception value, and <a href="../lang/testing.html#raises"><span class="pyret-highlight"><tt class="pyretexpr">raises</tt></span></a> checks that <span class="pyret-highlight"><tt class="pyretexpr">exn-string</tt></span> is contained within that string.  If so, the test passes, otherwise, it fails.</p><p>For simple errors (like those in many programming assignments), it works to use <a href="../trove/globals.html#raise"><span class="pyret-highlight"><tt class="pyretexpr">raise</tt></span></a> on a string value and check that that string is raised.  For larger programs, it can be useful to construct more sophisticated error values and use <a href="../lang/testing.html#raises-satisfies"><span class="pyret-highlight"><tt class="pyretexpr">raises-satisfies</tt></span></a> to test them.</p><div><p><b>Examples:</b></p><pre class="pyret-highlight">check:
  raise("the roof!") raises "the roof"

  string-length("too", "many", "strings") raises "arity-mismatch"

  {}.x raises "field-not-found"
end</pre></div><p><b>Warning!</b> These two tests are not equivalent:</p><pre class="pyret-highlight">check "actually catches the error":
  raise("error!") raises "error!"
end

check "error happens before raises":
  value = raise("error!")
  value raises "error!"
end</pre><p>This is because the left-hand-side of <a href="../lang/testing.html#raises"><span class="pyret-highlight"><tt class="pyretexpr">raises</tt></span></a> is a special position that can detect and catch errors, which normal expressions do not do.  So the second check block fails before even getting to the <a href="../lang/testing.html#raises"><span class="pyret-highlight"><tt class="pyretexpr">raises</tt></span></a> line; try it out and see what happens.</p><div><p><span><a name="raises-other-than"></a></span></p><pre class="pyret-display">expr <a href="../lang/testing.html#raises-other-than">raises-other-than</a> exn-string</pre></div><p>Like <a href="../lang/testing.html#raises"><span class="pyret-highlight"><tt class="pyretexpr">raises</tt></span></a>, but the result must <i>not</i> contain <span class="pyret-highlight"><tt class="pyretexpr">exn-string</tt></span>.</p><div><p><span><a name="does-not-raise"></a></span></p><pre class="pyret-display">expr <a href="../lang/testing.html#does-not-raise">does-not-raise</a></pre></div><p>Evaluates <span class="pyret-highlight"><tt class="pyretexpr">expr</tt></span> and checks that no error is raised while evaluating it.  The expression can evaluate to any value.</p><div><p><span><a name="raises-satisfies"></a></span></p><pre class="pyret-display">expr <a href="../lang/testing.html#raises-satisfies">raises-satisfies</a> pred</pre></div><p>As the name suggests, this combines the idea of <a href="../lang/testing.html#raises"><span class="pyret-highlight"><tt class="pyretexpr">raises</tt></span></a> with <a href="../lang/testing.html#satisfies"><span class="pyret-highlight"><tt class="pyretexpr">satisfies</tt></span></a> and calls <span class="pyret-highlight"><tt class="pyretexpr">pred</tt></span> on the exception that <span class="pyret-highlight"><tt class="pyretexpr">expr</tt></span> raises (if any).  Still fails if no exception is raised.</p><div><p><b>Examples:</b></p><pre class="pyret-highlight">import is-field-not-found from error
check:
  o = {}
  o.x raises-satisfies is-field-not-found
end</pre></div><div><p><span><a name="raises-violates"></a></span></p><pre class="pyret-display">expr <a href="../lang/testing.html#raises-violates">raises-violates</a> pred</pre></div><p>Like <a href="../lang/testing.html#raises-satisfies"><span class="pyret-highlight"><tt class="pyretexpr">raises-satisfies</tt></span></a>, but the predicate must return <span class="pyret-highlight"><tt class="pyretexpr">false</tt></span>.  Still fails if no exception is raised.</p></div><h2 id="Reasons-for-tests:----because--clauses" toclevel="2" tocentry="yes">Reasons for tests: <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> clauses</h2><p>When writing a test case, we may have several goals in mind: we might want to demonstrate <i>whether</i> a particular function works properly, or we might want to explore <i>why</i> a particular function works the way it does. Consider the following two test cases: when reading them, what meaning do they convey?</p><div><p><b>Examples:</b></p><pre class="pyret-highlight">check:
  distance-to-origin(3, 4) is 5
  distance-to-origin(3, 4) is num-sqrt(num-sqr(3) + num-sqr(4))
end</pre></div><p>Reading the first test case is concise and clear: the expected distance is simply 5.  But why?  Nothing in the expected output gives any insight into how the function works.  By contrast, the second test case gives far more insight, and ``shows our work’’...but it is also much lengthier.  Writing many such test cases would get very tedious, very quickly.  Additionally, there’s nothing tying the two test cases together: we have to notice that the two tests are adjacent in our program and their left sides are identical, to notice that both tests are about the same input scenario.</p><p>Pyret allows us to write test cases in a slightly different way, that addresses both of these concerns:</p><div><p><b>Examples:</b></p><pre class="pyret-highlight">check:
  distance-to-origin(3, 4) is-roughly 5
    because num-sqrt(num-sqr(3) + num-sqr(4))
end</pre></div><p>Read this aloud as ``The distance to origin of (3, 4) is roughly 5, because the square-root of three squared plus four squared is roughly 5.‘’  The <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> clause lets us show work, while also connecting the explanation to the original test case.</p><p>Now that there are potentially <i>three</i> components to writing a single test case, there are multiple ways a test case can fail:</p><ul><li>The explanation could be wrong, and so the expected value and the explanation do not match.</li><li>The expected value could be wrong, and so the explanation does not match the expected value even if the explanation is correct.</li><li>The function itself could be wrong, and so the left-hand side produces the wrong value and does not match the expected value.</li><li>The expected value could be wrong, and so the left-hand side does not match the right-hand side even if the function behaves properly.</li></ul><p>As an example of the first case, suppose we had a typo in our explanation (we used <span class="pyret-highlight"><tt class="pyretexpr">num-sqrt</tt></span> instead of <span class="pyret-highlight"><tt class="pyretexpr">num-sqr</tt></span>):</p><pre class="bad-ex pyret-highlight">check:
  distance-to-origin(3, 4) is-roughly 5
    because num-sqrt(num-sqrt(3) + num-sqr(4))
end</pre><p>Pyret will show us</p><p><img src="test-inconsistent.png"/></p><p>Here, even if the function is defined properly, the explanation and the expected result are inconsistent.  Pyret will show this inconsistency as a test failure, even if the left-hand side and the expected value do match—after all, we might simply have gotten lucky, and the explanation is more accurate! A test case using a <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> clause will pass only if the explanation matches the expected value <i>and</i> the left-hand side matches the expected value.</p><p>Using a <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> clause is optional, and is most helpful to illustrate a few select examples to demonstrate how we think a function should be working. Once we have a few test cases are passing, we can easily add several more and leave out the <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> clauses for them...but if any of them unexpectedly fail, we can easily add a <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> clause to them to help debug the failure.</p><h3 id="Using----because--with-other-testing-operators" toclevel="3" tocentry="yes">Using <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> with other testing operators</h3><p>For an arbitrary test case <span class="pyret-highlight"><tt class="pyretexpr">expr1 &lt;test-op&gt; expr2 because expr3</tt></span>, read this aloud as ``<span class="pyret-highlight"><tt class="pyretexpr">expr1 &lt;test-op&gt; expr2</tt></span> because <span class="pyret-highlight"><tt class="pyretexpr">expr3 &lt;test-op&gt; expr2</tt></span>.‘’  So for example:</p><ul><li><span class="pyret-highlight"><tt class="pyretexpr">times-two(3) is 6 because 2 * 3</tt></span> reads as ``<span class="pyret-highlight"><tt class="pyretexpr">times-two</tt></span> of 3 is 6, because two times 3 is 6.‘’  Note that this reads analogously for <span class="pyret-highlight"><tt class="pyretexpr">is-roughly</tt></span>, <span class="pyret-highlight"><tt class="pyretexpr">is==</tt></span>, <span class="pyret-highlight"><tt class="pyretexpr">is=~</tt></span>, <span class="pyret-highlight"><tt class="pyretexpr">is&lt;=&gt;</tt></span>, and <span class="pyret-highlight"><tt class="pyretexpr">is%(...)</tt></span>.</li><li><span class="pyret-highlight"><tt class="pyretexpr">times-two(3) satisfies is-even because 2 * 3</tt></span> reads as ``<span class="pyret-highlight"><tt class="pyretexpr">times-two</tt></span> of 3 should be even, because two times 3 should be even.‘’</li><li><span class="pyret-highlight"><tt class="pyretexpr">reciprocal(0) raises “division by zero” because 1 / 0</tt></span> reads as ``The reciprocal of zero raises a division-by-zero error, because <span class="pyret-highlight"><tt class="pyretexpr">1 / 0</tt></span> raises a division-by-zero error.‘’</li></ul><p>The other testing operators also work with <span class="pyret-highlight"><tt class="pyretexpr">because</tt></span> in the same way, though it is a bit harder to read them aloud.</p></root>
    <hr/>
    The current page is lang/testing.html.
    The previous page is <a href = "../lang/forms.html">../lang/forms.html</a>.
    The next page is <a href = "../lang/equality.html">../lang/equality.html</a>.
    </div>
  </body>
</html>