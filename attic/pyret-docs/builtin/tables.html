<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Tables</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="tables" toclevel="1" tocentry="yes">Tables</h1><p>There are many examples of tables in computing, with spreadsheets being the most obvious.</p><p>A <tt class="pyretexpr">Table</tt> is made up of <bold>rows</bold> and <bold>columns</bold>. All rows have the same number of columns, in the same order. Each column has a name.  Each column may also be assigned a type via an annotation; if so, all entries in a column will then be checked against the annotation.  Unsurprisingly, they are useful for representing tabular data from sources like spreadsheets or CSV files.</p><p><bold>Note:</bold> The <tt class="pyretexpr">Table</tt> data type and the syntax for manipulating tables is built in to Pyret without needing any imports; however, using the <a href="builtin/tables.html#Reducers">Reducers</a> or the functions in <a href="builtin/tables.html#s:tables:methods">Advanced Table Manipulation</a> require the <tt class="pyretexpr">import</tt> line above.</p><p>  </p><h2 id="s:tables" toclevel="2" tocentry="yes">Creating Tables</h2><p>A simple <tt class="pyretexpr">Table</tt> can be directly created with a <tt class="pyretexpr">table:</tt> expression, which lists any number of columns, with optional annotations, and then any number of rows.  For example, this expression creates a table with three columns, <tt class="pyretexpr">name</tt>, <tt class="pyretexpr">age</tt>, and <tt class="pyretexpr">favorite-color</tt>, and three rows:</p><p>  </p><pre>my-table = table: name :: String, age :: Number, favorite-color :: String
  row: "Bob", 12, "blue"
  row: "Alice", 17, "green"
  row: "Eve", 13, "red"
end</pre><p><margin-note>Indeed, <tt class="pyretexpr">my-table</tt> is used as a running example in much of the following.</margin-note> Evaluating <tt class="pyretexpr">my-table</tt> in the interactions window after running the program above will display a formatted version of the table:</p><p><img src="src/builtin/table-print.png"/></p><p>  </p><h2 id="s:tables:loading" toclevel="2" tocentry="yes">Loading Tables</h2><p>Pyret supports loading spreadsheets from Google Sheets and interpreting them as Pyret tables.</p><p>You can import most relevant file types, including .xlsx, into Google Sheets, and then into Pyret, so you should be able to get almost any tabular data into Pyret with a little effort.</p><p><margin-note>In Google Sheets, you create a file, referred to as a “spreadsheet” that contains one or more grids called “sheets.”  Excel refers to the file as a “workbook” and each grid as a “worksheet.”  We will follow Google Sheets’ nomenclature.</margin-note></p><p>Pyret assumes each sheet contains only one table of neatly formatted data, without skipping columns or extra comments other than an optional single header row at the top.</p><p>As a simple and consistent example, let’s say we wanted to import the <tt class="pyretexpr">my-table</tt> data from a spreadsheet.</p><p><img src="src/builtin/gsheet-1.png"/></p><p>To import this data into a Pyret program, you need to get the spreadsheet’s unique Google ID.  The easiest way to do this is to click on the blue <tt class="pyretexpr">Share</tt> button in the upper right.</p><p><img src="src/builtin/gsheet-2.png"/></p><p>If you don’t want to share your spreadsheet with anyone else, click <tt class="pyretexpr">Advanced</tt> in the lower right of the <tt class="pyretexpr">Share with others</tt> dialog, then copy the <tt class="pyretexpr">Link to share</tt>, highlighted in orange below, and paste it into your Pyret definitions area (or another editor).</p><p><img src="src/builtin/gsheet-3.png"/></p><p>The URL will look something like</p><p><tt class="pyretexpr">https://docs.google.com/spreadsheets/d/1BAexzf08Q5o8bXb_k8PwuE3tMKezxRfbKBKT-4L6UzI/edit?usp=sharing</tt></p><p>The Google ID is the part between <tt class="pyretexpr">/d/</tt> and <tt class="pyretexpr">/edit...</tt>, in this case:</p><p><tt class="pyretexpr">1BAexzf08Q5o8bXb_k8PwuE3tMKezxRfbKBKT-4L6UzI</tt></p><p><margin-note>If you do want to share the spreadsheet with others, click on the blue <tt class="pyretexpr">Share</tt> button as above, and then click <tt class="pyretexpr">Get sharable link</tt>, choose the appropriate level of sharing, and copy the URL to get the Google ID as above.</margin-note></p><p>Now you can load the spreadsheet into your Pyret program:</p><pre>import gdrive-sheets as GS

imported-my-table =
  GS.load-spreadsheet("1BAexzf08Q5o8bXb_k8PwuE3tMKezxRfbKBKT-4L6UzI")</pre><p>You can use <tt class="pyretexpr">include</tt> instead of <tt class="pyretexpr">import as...</tt> to cut down on some typing by omitting the <tt class="pyretexpr">GS.</tt> before the <tt class="pyretexpr">tables</tt> module functions.</p><pre>include gdrive-sheets

imported-my-table =
  load-spreadsheet("1BAexzf08Q5o8bXb_k8PwuE3tMKezxRfbKBKT-4L6UzI")</pre><p><margin-note>We’ll use <tt class="pyretexpr">import</tt> and the prefix <tt class="pyretexpr">GS.</tt> in the following examples.  If you use <tt class="pyretexpr">include</tt>, omit <tt class="pyretexpr">GS.</tt> where used below.</margin-note></p><p>When data is loaded into a table, we recommend using <italic>sanitizers</italic> to properly load each entry of the table as the correct Pyret type.  The supported sanitizers are imported from the <tt class="pyretexpr">data-source</tt> module.</p><p>The sanitizers currently provided by Pyret are:</p><p><itemlist><item><bold>string-sanitizer</bold> tries to convert anything to a <a href="UnDeFiNeD">UnDeFiNeD</a></item><item><bold>num-sanitizer</bold> tries to convert  numbers, strings and booleans to <a href="UnDeFiNeD">UnDeFiNeD</a>s</item><item><bold>bool-sanitizer</bold> tries to convert numbers, strings and booleans to <a href="UnDeFiNeD">UnDeFiNeD</a>s</item><item><bold>strict-num-sanitizer</bold> tries to convert numbers and strings (not booleans) to <a href="UnDeFiNeD">UnDeFiNeD</a>s</item><item><bold>strings-only</bold> converts only strings to <a href="UnDeFiNeD">UnDeFiNeD</a>s</item><item><bold>numbers-only</bold> converts only numbers to <a href="UnDeFiNeD">UnDeFiNeD</a>s</item><item><bold>booleans-only</bold> converts only booleans to <a href="UnDeFiNeD">UnDeFiNeD</a>s</item><item><bold>empty-only</bold> converts only empty cells to <tt class="pyretexpr">noneoption</tt>s</item></itemlist></p><p><margin-note>While the <tt class="pyretexpr">data-source</tt> library provides sanitizers which should cover most use cases, there may be times when one would like to create a custom data sanitizer. To do so, one must simply create a function which conforms to the <tt class="pyretexpr">Sanitizerdata-source</tt> type in the <tt class="pyretexpr">data-source</tt> module.</margin-note></p><p>Use the <tt class="pyretexpr">load-table:</tt> expression to create a table from an imported sheet.</p><p>Each spreadsheet file contains multiple, named sheets, displayed as tabs across the bottom of the Sheets user interface.  When you start working with the data in an imported spreadsheet, you need to indentify which sheet you are using as the data source.</p><p>The <tt class="pyretexpr">source:</tt> expression should be followed by the imported spreadsheet, calling the pyret-method method with two arguments, the sheet name and a boolean flag indicating whether or not there is a header row in the sheet that should be ignored.  In our example above,  <tt class="pyretexpr">imported-my-table</tt> contains one sheet, called <tt class="pyretexpr">3-rows</tt>, and there is a header row that should be ignored by the importer, so the <tt class="pyretexpr">source:</tt> expression would be written as illustrated below.</p><pre>import gdrive-sheets as GS
import data-source as DS

imported-my-table =
  GS.load-spreadsheet("1BAexzf08Q5o8bXb_k8PwuE3tMKezxRfbKBKT-4L6UzI")

my-table = load-table: name :: String, age :: Number, favorite-color :: String
  source: imported-my-table.sheet-by-name("3-rows", true)
  sanitize name using DS.string-sanitizer
  sanitize age using DS.strict-num-sanitizer
  sanitize favorite-color using DS.string-sanitizer
end</pre><p>In general, it is <italic>safest</italic> to sanitize <italic>every</italic> input column, since it is the only way to guarantee that the data source will not guess the column’s type incorrectly.</p><p>Note that Google Sheets, and other spreadsheets, themselves assign or infer types to data in a way that often is not apparent to the user and is a common source of errors when exporting from or between spreadsheet applications.</p><div><div class="function">TableLoader&lt;&gt;</div></div><p>The type of values that can be loaded using <tt class="pyretexpr">load-table</tt>. Common ways to generate a <tt class="pyretexpr">TableLoader</tt> are:</p><p><itemlist><item>pyret-method and pyret-method</item><item><tt class="pyretexpr">csv-table-strcsv</tt> and <tt class="pyretexpr">csv-table-filecsv</tt></item></itemlist></p><p>  </p><h2 id="s:tables:select" toclevel="2" tocentry="yes">Selecting Columns</h2><p>The <tt class="pyretexpr">select</tt> expression can be used to create a new table from a subset of the columns of an existing one.  For example, we can get just the names and ages from <tt class="pyretexpr">my-table</tt> above:</p><pre>names-and-ages = select name, age from my-table end
check:
  names-and-ages is table: name, age
    row: "Bob", 12
    row: "Alice", 17
    row: "Eve", 13
  end
end</pre><p>  </p><h2 id="Filtering-Tables" toclevel="2" tocentry="yes">Filtering Tables</h2><p>The <tt class="pyretexpr">sieve</tt> mechanism allows for filtering out rows of tables based on some criteria. The <tt class="pyretexpr">using</tt> keyword specifies which columns may be used in the body of the <tt class="pyretexpr">sieve</tt> expression.</p><p>For instance, we can find the individuals in <tt class="pyretexpr">my-table</tt> who are old enough to drive in the United States.</p><pre class="good-ex">can-drive = sieve my-table using age:
  age &gt;= 16
end
check:
  can-drive is table: name, age, favorite-color
    row: "Alice", 17, "green"
  end
end</pre><p>Note that the <tt class="pyretexpr">sieve</tt> block must explicitly list the columns used to filter out values with <tt class="pyretexpr">using</tt>.  The following would signal an undefined name error for <tt class="pyretexpr">age</tt>, because names being used in the expression body must be listed:</p><pre class="bad-ex">can-drive = sieve my-table using name:
  # age is not visible inside of this expression
  age &gt;= 16
end</pre><p>  </p><h2 id="Ordering-Tables" toclevel="2" tocentry="yes">Ordering Tables</h2><p>To arrange the rows of a table in some particular order, use an <tt class="pyretexpr">order</tt> expression.  This can be done with any column whose type supports the use of <tt class="pyretexpr">&lt;</tt> and <tt class="pyretexpr">&gt;</tt>, including <a href="UnDeFiNeD">UnDeFiNeD</a>s.</p><pre>name-ordered = order my-table:
  name ascending
end
check:
  name-ordered is table: name, age, favorite-color
    row: "Alice", 17, "green"
    row: "Bob", 12, "blue"
    row: "Eve", 13, "red"
  end
end</pre><p>Tables can be sorted by multiple columns.  In general you may select as many columns as desired, and can mix and match <tt class="pyretexpr">ascending</tt> and <tt class="pyretexpr">descending</tt> sorts.  No column can be mentioned more than once.</p><pre>order some-table:
  column1 ascending,
  column3 descending,
  column2 ascending
end</pre><p>This example will first sort the data in increasing order on <tt class="pyretexpr">column1</tt>.  If there are any duplicate values in <tt class="pyretexpr">column1</tt>, each such group of rows will be sorted in decreasing order by <tt class="pyretexpr">column3</tt>.  If there are any duplicates in both columns, each remaining group will be sorted in increasing order by <tt class="pyretexpr">column2</tt>.</p><p>  </p><h2 id="Transforming-Tables" toclevel="2" tocentry="yes">Transforming Tables</h2><p>The <tt class="pyretexpr">transform</tt> expression allows the changing of columns within a table, similar to the <tt class="pyretexpr">maplists</tt> function over lists (and, just like <tt class="pyretexpr">maplists</tt>, <tt class="pyretexpr">transform</tt> expressions do not mutate the table, but instead return a new one).</p><p>Suppose we find out that <tt class="pyretexpr">my-table</tt> is wrong and everyone is actually a year older than it says they are. We can fix our data as follows:</p><pre>age-fixed = transform my-table using age:
  age: age + 1
end
check:
  age-fixed is table: name, age, favorite-color
    row: "Bob", 13, "blue"
    row: "Alice", 18, "green"
    row: "Eve", 14, "red"
  end
end</pre><h2 id="Extracting-Columns-from-Tables" toclevel="2" tocentry="yes">Extracting Columns from Tables</h2><p>A large number of Pyret modules work on <a href="trove/lists.html#lists"></a> instead of tables, so it may be desired to pull the contents of one column of a table as a list to use it elsewhere. The <tt class="pyretexpr">extract</tt> mechanism allows this ability, and serves as the primary link between processing tabular data and non-tabular Pyret functions.</p><p>Suppose, for example, we wanted just the names of each person in <tt class="pyretexpr">my-table</tt>. We could pull those names out as follows:</p><pre>name-list = extract name from my-table end
check:
  name-list is [list: "Bob", "Alice", "Eve"]
end</pre><h2 id="Extending-Tables" toclevel="2" tocentry="yes">Extending Tables</h2><p>“Extending” a table means to create a new table with an additional, calculated column. There are two types of extensions which can be made to tables: mapping extensions and reducing extensions.</p><h3 id="Mapping-extensions" toclevel="3" tocentry="yes">Mapping extensions</h3><p>A mapping column is one whose contents are calculated from other columns only in the row it is being added to.  This is analogous to the map function for <a href="trove/lists.html#lists"></a>.</p><p>In a mapping expression, the body of the expression defines the name of the new column or columns followed by an expression which calculates the new value to be placed in each row of the new column.</p><p>One example of this is a column which tells whether the <tt class="pyretexpr">age</tt> field of a given row in <tt class="pyretexpr">my-table</tt> indicates that the person in that row is old enough drive in the United States or not, that is, whether that person is at least 16:</p><pre>can-drive-col = extend my-table using age:
  can-drive: age &gt;= 16
end
check:
  can-drive-col is table: name, age, can-drive
    row: "Bob", 12, false
    row: "Alice", 17, true
    row: "Eve", 13, false
  end
end</pre><p>Another example creates a new table including baseball players’ calculated batting average and slugging percentage in extended columns:</p><pre>batting = table: batter :: String,
  at-bats :: Number, singles :: Number, doubles :: Number,
  triples :: Number, home-runs :: Number
  row: "Julia", 20, 4, 2, 0, 0
  row: "Vivian", 25, 6, 1, 1, 1
  row: "Eddie", 28, 5, 2, 0, 2
end
batting-avg-and-slugging = extend batting
  using at-bats, singles, doubles, triples, home-runs:
  batting-average: (singles + doubles + triples + home-runs) / at-bats,
  slugging-percentage: (singles + (doubles * 2) +
    (triples * 3) + (home-runs * 4)) / at-bats
end</pre><p><img src="src/builtin/baseball.png"/></p><p><margin-note>As in <a href="UnDeFiNeD">UnDeFiNeD</a>, you must specify which columns will be used to calculate the value in the <tt class="pyretexpr">extend</tt> expression using the <tt class="pyretexpr">using</tt> keyword.</margin-note></p><h3 id="Reducers" toclevel="3" tocentry="yes">Reducers</h3><p>A “reducing” column is one whose information is computed from the row it is being added to <italic>and one or more of the rows above</italic> that row.  This is analogous to the <tt class="pyretexpr">foldlists</tt> function for <a href="trove/lists.html#lists"></a>.</p><p>The simplest examples of reducing use reducers built into Pyret.</p><p>For each reducer below, you will need to specify a name for the new column and which existing column new value will be based on.  You will also need to <tt class="pyretexpr">import</tt> or <tt class="pyretexpr">include</tt> <tt class="pyretexpr">tables</tt>.</p><p><value>running-sumReducer&lt;Number&gt;</value></p><p>Creates a new column where in each row, the running sum will be the added value of the cell in the selected column plus all the cells <italic>above</italic> the cell in the same column.</p><pre>import tables as T
dem-primary-delegates = table: state :: String, clinton :: Number,
  sanders :: Number
  row: "Iowa", 29, 21
  row: "New Hampshire", 15, 16
  row: "Nevada", 27, 16
  row: "South Carolina", 44, 14
end
running-total-delegates = extend dem-primary-delegates
  using clinton, sanders:
  total-clinton: T.running-sum of clinton,
  total-sanders: T.running-sum of sanders
end
print(running-total-delegates)</pre><p><img src="src/builtin/primaries.png"/></p><p><value><p>differenceReducer&lt;Number&gt; The <tt class="pyretexpr">difference</tt> extender creates a new column containing the difference between the value in the current row (of the selected column) minus the value in <italic>only</italic> the row directly above.  In the first row, the value is unchanged. Since there’s no value before the first row, Pyret behaves as if it were zero.</p><p><margin-note>Both <tt class="pyretexpr">difference</tt> and <tt class="pyretexpr">difference-from</tt> do <italic>not</italic> calculate a running difference, only the difference between the selected row and the single row above.</margin-note></p><pre>import tables as T
test-scores = table: year :: Number,
  math-score :: Number, reading-score :: Number
  row: 2014, 87, 89
  row: 2015, 98, 93
  row: 2016, 79, 83
  row: 2017, 85, 90
end
changes-by-year = extend test-scores using math-score, reading-score:
  math-change-from-previous: T.difference of math-score,
  reading-change-from-previous: T.difference of reading-score
end</pre><p><img src="src/builtin/difference-table.png"/></p></value></p><div class="function"><p>difference-from Like <tt class="pyretexpr">difference</tt>, except the starting value is specified, instead of defaulting to 0.</p><pre># calculates velocity of a dropping ball
ball-info = table: pos-y
  row: 25
  row: 24
  row: 21
  row: 16
  row: 0
end
with-velocity = extend ball-info using pos-y:
  vel-y: T.difference-from(25) of pos-y
end
check:
  with-velocity is table: pos-y, vel-y
    row: 25, 0
    row: 24, -1
    row: 21, -3
    row: 16, -5
    row: 0, -16
  end
end</pre><p> :: <span>Number -&gt; Reducer&lt;Number&gt;</span></p></div><p><value>running-meanReducer&lt;Number&gt;</value></p><p>Creates a new column  where the value in each row is equal to the mean of <italic>all</italic> values in the designated column in the current row and above.</p><pre>import tables as T
my-grades = table: score :: Number
  row: 87
  row: 91
  row: 98
  row: 82
end
with-running-mean = extend my-grades
  using score:
  mean: T.running-mean of score
end
check:
  with-running-mean is table: score, mean
    row: 87, 87
    row: 91, 89
    row: 98, 92
    row: 82, 89.5
  end
end</pre><p><value>running-maxReducer&lt;Number&gt;</value> <value>running-minReducer&lt;Number&gt;</value></p><p>Creates a new column that contains the maximum or minimum value in the selected column in the current row or above.</p><pre>some-numbers = table: n :: Number
  row: 4
  row: 9
  row: 3
  row: 1
  row: 10
end
with-min-max = extend some-numbers using n:
  max: T.running-max of n,
  min: T.running-min of n
end
check:
  with-min-max is table: n, max, min
    row: 4, 4, 4
    row: 9, 9, 4
    row: 3, 9, 3
    row: 1, 9, 1
    row: 10, 10, 1
  end
end</pre><div class="function">running-fold :: <span>Result<span>ResultCol -&gt; Result</span> -&gt; Reducer&lt;Result&gt;</span></div><div class="function">running-reduce :: <span><span>ColCol -&gt; Col</span> -&gt; Reducer&lt;Col&gt;</span></div><p><tt class="pyretexpr">running-fold</tt> and <tt class="pyretexpr">running-reduce</tt> allow you to specify a function used to calculate the value in the new column, based on a running calculation of all the values in the selected column in the current row and above.</p><p>The difference between <tt class="pyretexpr">running-fold</tt> and <tt class="pyretexpr">running-reduce</tt> is that <tt class="pyretexpr">running-fold</tt> requires an explicit <tt class="pyretexpr">start-value</tt>.</p><pre>import tables as T
count-if-driver = T.running-fold(0,
  lam(sum, col): if col &gt;= 16: 1 + sum else: sum end end)
t = table: name, age
  row: "Bob", 17
  row: "Mary", 22
  row: "Jane", 6
  row: "Jim", 15
  row: "Barbara", 30
end
with-driver-count = extend t using age:
  total-drivers: count-if-driver of age
end
check:
  with-driver-count is table: name, age, total-drivers
    row: "Bob", 17, 1
    row: "Mary", 22, 2
    row: "Jane", 6, 2
    row: "Jim", 15, 2
    row: "Barbara", 30, 3
  end
end

checks = table: check-number :: Number, withdrawal :: Number
  row: 001, 50
  row: 002, 100
  row: 003, 500
end
with-checking-balance = extend checks using withdrawal:
  current-balance: T.running-fold(1000,
    lam(total, col): total - col end) of withdrawal
end
check:
  with-checking-balance is table: check-number, withdrawal, current-balance
    row: 001, 50, 950
    row: 002, 100, 850
    row: 003, 500, 350
  end
end
</pre><p>While the reducers found in the <tt class="pyretexpr">tables</tt> module should cover most all use cases, there may be times when one would like to create a reducer of their own. To do so, one must construct an object of the following type:</p><div><div class="function">Reducer&lt;Acc, InVal, OutVal&gt;</div><div><tt>.one :: <span>Reducer&lt;Acc&gt;InVal -&gt; a-tuple</span></tt></div><div><tt>.reduce :: <span>Reducer&lt;Acc&gt;AccInVal -&gt; a-tuple</span></tt></div><p>Reducers are essentially descriptions of folds (in the list <tt class="pyretexpr">foldlists</tt> sense) over table columns. The way reducers are called by the language runtime is as follows: the value(s) from the first row are passed to the reducer’s pyret-method method, which should return a tuple containing both any accumulated information needed for the fold and the value which should be placed in the new column in that row. The remaining rows are then sequentially populated using the reducer’s pyret-method method, which is identical to the pyret-method method except that it receives an additional argument which is the previously mentioned accumulated information from the previous row.</p><p>To illustrate, a <tt class="pyretexpr">running-mean</tt> reducer which is equivalent to the one provided by the <tt class="pyretexpr">tables</tt> module could be implemented as follows:</p><pre>import tables as T
running-mean :: T.Reducer&lt;{Number; Number}, Number, Number&gt; = {
  one: lam(n): {{n; 1}; n} end,
  reduce: lam({sum; count}, n):
    { {sum + n; count + 1}; (sum + n) / (count + 1) }
  end
}</pre></div><p>  </p><h2 id="s:tables:comparing" toclevel="2" tocentry="yes">Comparing Tables</h2><p>The order of both rows and columns are part of a table value.  To be considered equal, tables need to have all the same rows and columns, with the rows and columns appearing in the same order.</p><h2 id="s:tables:methods" toclevel="2" tocentry="yes">Advanced Table Manipulation</h2><p>The operations listed above come with a significant restriction: all column names must also be valid identifier names. In addition, column names are always chosen directly by the programmer in each query, and there’s no way to abstract over them.</p><p>To see why this is a significant restriction, consider this (non-working) example:</p><pre>fun sieve-by-large-number(t :: Table, colname :: String) -&gt; Table:
  doc: ```Return a new table containing the rows of t whose column
          named by the string provided for colname have value greater than
          1000```
  sieve t using colname:
    colname &gt; 1000
  end
where:
  my-t = table: item, price
    row: "Chromebook", 250
    row: "Macbook", 1300
  end

  sieve-by-large-number(my-t, "price") is table: item, price
    row: "Macbook", 1300
  end
end</pre><p>We may well want to write this if we have a number of tables, all of which we want to sieve by the same criteria. However, it isn’t possible to abstract over a column name using <tt class="pyretexpr">sieve</tt>: the program above conflates the identifier <tt class="pyretexpr">colname</tt> with the column name <tt class="pyretexpr">colname</tt>. As a result, that program gives an error that the <tt class="pyretexpr">colname</tt> in the query shadows the <tt class="pyretexpr">colname</tt> that’s a parameter of the function.</p><p>Pyret provides facilities for writing programs like the above, they are simply a different set of operations than the query syntax. These table manipulation operations are useful for building abstractions over tables and for creating tables programmatically.</p><div><div class="function">Row&lt;&gt;</div><p>The type of all row values.</p></div><p>collection-doc</p><p>Takes a sequence of tuples and constructs a <tt class="pyretexpr">Row</tt> value. Note that the type for each column may be different. The constructed row can be added to appropriate tables by using the table methods like pyret-method.</p><p>It is often preferable to construct rows for an existing table by using the pyret-method method, which avoids typing out the names of each column for each created row, and provides built-in checking for the count of columns.</p><div><tt>.get-column-names :: <span>Row -&gt; List&lt;String&gt;</span></tt></div><p>Produces a list of strings containing the names of the columns in the row.</p><pre>check:
  r = [raw-row: {"city"; "NYC"}, {"pop"; 8500000}]
  r.get-column-names() is [list: "city", "pop"]
end</pre><div><tt>.get-value :: <span>RowString -&gt; Col</span></tt></div><p>Consumes the name of a column, and produces the corresponding value. Results in an error if the value isn’t found. Square-bracket (<tt class="pyretexpr">[]</tt>) accessor syntax uses <tt class="pyretexpr">get-value</tt>, which is often more pleasant to write than writing out <tt class="pyretexpr">get-value</tt> fully.</p><pre>check:
  r = [raw-row: {"city"; "NYC"}, {"pop"; 8500000}]
  r.get-value("pop") is 8500000
  r["pop"] is 850000
end</pre><div><tt>.get :: <span>RowString -&gt; Option&lt;Col&gt;</span></tt></div><p>Consumes the name of a column, and produces a <tt class="pyretexpr">someoption</tt> containing the corresponding value if it’s present, or <tt class="pyretexpr">noneoption</tt> if it isn’t.</p><div><div class="function">Table&lt;&gt;</div><p>The type of all tables.</p></div><p>collection-doc</p><p>A collection constructor that creates tables from <tt class="pyretexpr">Row</tt> values.</p><pre>check:
  t = [table-from-rows:
    [raw-row: {"A"; 5}, {"B"; 7}, {"C"; 8}],
    [raw-row: {"A"; 1}, {"B"; 2}, {"C"; 3}]
  ]

  t.length() is 2
  t.column("A") is [list: 5, 1]
  t.row-n(0) is [raw-row: {"A"; 5}, {"B"; 7}, {"C"; 8}]
end</pre><p>collection-doc</p><p>A collection constructor that creates tables from columns, where each column is specified as a tuple of its name (as a <tt class="pyretexpr">String&lt;global&gt;</tt>) and a <tt class="pyretexpr">Listlists</tt> of its values.</p><pre>check:
  t = [table-from-columns:
    {"a"; [list: 100, 200, 300]},
    {"b"; [list: true, false, true]}
  ]

  t.length() is 3
  t.column("a") is [list: 100, 200, 300]
  t.row-n(2) is [raw-row: {"a"; 300}, {"b"; true}]
end</pre><div class="function"><p>table-from-column A function that creates a table of a single column from a column name, given as a <tt class="pyretexpr">String&lt;global&gt;</tt> and a <tt class="pyretexpr">Listlists</tt> of values.</p><pre>check:
  col = range(0, 100)
  tfc = table-from-column("a", col)
  tfc.length() is 100
  tfc.column-names() is [list: "a"]
  cs = tfc.all-columns()
  cs.get(0) is col
end</pre><p> :: <span>StringList&lt;A&gt; -&gt; Table</span></p></div><div><tt>.length :: <span>Table -&gt; Number</span></tt></div><p>Evaluates to the number of rows in the table.</p><div><tt>.row :: <span>TableCol1Col2...ColN -&gt; Row</span></tt></div><p>Consumes one value for each column in the table, and produces a <tt class="pyretexpr">Row</tt> value where each provided value is associated with the appropriate column.</p><pre>check:
  t = table: city, pop
    row: "NYC", 8.5 * 1000000
    row: "SD", 1.4 * 1000000
  end
  r = t.row("Houston", 2.3 * 1000000)
  r is [raw-row: {"city"; "Houston"}, {"pop"; 2.3 * 1000000}]
end</pre><div><tt>.build-column :: <span>TableString<span>Row -&gt; Col</span> -&gt; Table</span></tt></div><p>Consumes an existing table, and produces a new table containing an additional column with the given <tt class="pyretexpr">colname</tt>, using <tt class="pyretexpr">compute-new-val</tt> to produce the values for that column, once for each row.</p><p>Here, <tt class="pyretexpr">Col</tt> is the type of the new column, determined by the type of value the <tt class="pyretexpr">compute-new-val</tt> function returns.</p><pre>check:
  foods = table: name, grams, calories
    row: "Fries", 200, 500
    row: "Milkshake", 400, 600
  end
  foods-with-cpg = table: name, grams, calories, cal-per-gram
    row: "Fries", 200, 500, 500/200
    row: "Milkshake", 400, 600, 600/400
  end

  fun add-cpg(r :: Row) -&gt; Number:
    r["calories"] / r["grams"]
  end

  foods.build-column("cal-per-gram", add-cpg) is foods-with-cpg
end</pre><pre>fun add-index(t):
  var ix = -1
  t.build-column("index", lam(_) block:
    ix := ix + 1
    ix
  end)
where:
  before = table: name
      row: "Joe"
      row: "Shriram"
      row: "Kathi"
    end
  after = table: name, index
      row: "Joe", 0
      row: "Shriram", 1
      row: "Kathi", 2
    end
  add-index(before) is after
end</pre><div><tt>.add-column :: <span>TableStringList&lt;Col&gt; -&gt; Table</span></tt></div><p>Consumes a column name and a list of values, and produces a new table with a columng of the given name added, containing the values from <tt class="pyretexpr">new-vals</tt>.</p><p>It is an error if the length of <tt class="pyretexpr">new-vals</tt> is different than the length of the table.</p><div><tt>.add-row :: <span>TableRow -&gt; Table</span></tt></div><p>Consumes a table and a row to add, and produces a new table with the given row at the end.</p><div><tt>.row-n :: <span>TableNumber -&gt; Row</span></tt></div><p>Consumes an index, and returns the row at that index. The first row has index 0.</p><div><tt>.get-column :: <span>TableString -&gt; List&lt;Col&gt;</span></tt></div><p>Consumes the name of a column, and returns the values in that column as a list.</p><div><tt>.column :: <span>TableString -&gt; List&lt;Col&gt;</span></tt></div><p>This method is no longer used (use pyret-method instead).</p><div><tt>.column-n :: <span>TableNumber -&gt; List&lt;Col&gt;</span></tt></div><p>Consumes an index, and returns the values in the column at that index as a list. The first column has index 0.</p><div><tt>.column-names :: <span>Table -&gt; List&lt;String&gt;</span></tt></div><p>Consumes no arguments, and produces the names of the columns of the table as a list.</p><div><tt>.all-rows :: <span>Table -&gt; List&lt;Row&gt;</span></tt></div><p>Consumes no arguments, and produces a list containing all the rows in the table, in the same order they appear in the table.</p><div><tt>.all-columns :: <span>Table -&gt; List&lt;List&lt;Col&gt;&gt;</span></tt></div><p>Consumes no arguments, and produces a list of lists of the column values. The columns and values appear in the same order they appeared in the table.</p><div><tt>.filter :: <span>Table<span>Row -&gt; Boolean</span> -&gt; Table</span></tt></div><p>Consumes a predicate over rows, and produces a new table containing only the rows for which the predicate returned <tt class="pyretexpr">true</tt>.</p><div><tt>.filter-by :: <span>TableString<span>Col -&gt; Boolean</span> -&gt; Table</span></tt></div><p>Consumes a column name and a predicate over the values of that column, and produces a new table containing only the rows for which the predicate returned <tt class="pyretexpr">true</tt> for that column. The type of argument to the predicate has the type of values in the specified column.</p><div><tt>.order-by :: <span>TableStringBoolean -&gt; Table</span></tt></div><p>Consumes a column name and whether to order ascending or descending, and produces a new table with the rows ordered by the given column.</p><p>If <tt class="pyretexpr">true</tt> is given for <tt class="pyretexpr">asce</tt>, the rows are ordered lowest to highest by the given column (e.g. using <tt class="pyretexpr">&lt;</tt>), and if <tt class="pyretexpr">false</tt> is given, they are ordered highest to lowest.</p><div><tt>.order-by-columns :: <span>TableList&lt;a-tuple&gt; -&gt; Table</span></tt></div><p>Consumes a list of tuples describing column orderings, and produces a new table according to the given ordering.</p><p>Each element of the list must be a two-element tuple, containing a column name and a boolean indicating whether to order ascending or not. As with pyret-method, <tt class="pyretexpr">true</tt> indicates ascending and <tt class="pyretexpr">false</tt> indicates descending.</p><div><tt>.increasing-by :: <span>TableString -&gt; Table</span></tt></div><p>Like pyret-method, but <tt class="pyretexpr">ascending</tt> is always <tt class="pyretexpr">true</tt>.</p><div><tt>.decreasing-by :: <span>TableString -&gt; Table</span></tt></div><p>Like pyret-method, but <tt class="pyretexpr">ascending</tt> is always <tt class="pyretexpr">false</tt>.</p><div><tt>.select-columns :: <span>TableList&lt;String&gt; -&gt; Table</span></tt></div><p>Consumes a list of column names, and produces a new table containing only those columns. The order of the values in the columns is the same as in the input table, and the order of the columns themselves is the order they are given in the list.</p><div><tt>.transform-column :: <span>TableString<span>ColIn -&gt; ColOut</span> -&gt; Table</span></tt></div><p>Consumes a column name and a transformation function, and produces a new table where the given function has been applied to all values in the specified column of the original table.</p><div><tt>.rename-column :: <span>TableStringString -&gt; Table</span></tt></div><p>Produces a new table where the specified column name in the original table has been renamed to the new name.  The new name must not already be present in the table’s columns.</p><p>This operation is essentially the following:</p><pre>fun rename-column(t :: Table, old-colname :: String, new-colname :: String):
  new-t = t.build-column(new-colname, lam(r): r["old-colname"] end)
  new-t.drop("old-colname")
end</pre><p>except that in this code, the renamed column will appear as the rightmost column of the result, whereas using pyret-method, the renamed column will stay in its original place.</p><div><tt>.stack :: <span>TableTable -&gt; Table</span></tt></div><p>Returns a new table containing all the rows of this table, followed by all the rows of the <tt class="pyretexpr">bot-table</tt>.  The column names must all match, but the order is not required to match.</p><pre>check:
  t1 = table: city, pop
    row: "Houston", 2400000
    row: "NYC", 8400000
  end
  t2 = table: pop, city # deliberately reversed column order for this example
    row: 1400000, "San Diego"
  end
  t1.stack(t2) is table: city, pop
    row: "Houston", 2400000
    row: "NYC", 8400000
    row: "San Diego", 1400000
  end
  t2.stack(t1) is table: pop, city
    row: 1400000, "San Diego"
    row: 2400000, "Houston"
    row: 8400000, "NYC"
  end
end</pre><div><tt>.empty :: <span>Table -&gt; Table</span></tt></div><p>Returns a new table with the same columns as this table, but with all rows removed.</p><pre>check:
  t1 = table: city, pop
    row: "Houston", 2400000
    row: "NYC", 8400000
  end
  t1.empty() is table: city, pop end
end</pre><div><tt>.drop :: <span>TableString -&gt; Table</span></tt></div><p>Returns a new table that contains all the data from this table except the specified column.</p><pre>check:
  t1 = table: city, pop
    row: "Houston", 2400000
    row: "NYC", 8400000
  end
  t1.drop("city") is table: pop
    row: 2400000
    row: 8400000
  end
  t1.drop("pop") is table: city
    row: "Houston"
    row: "NYC"
  end
end</pre></div></root>
    <hr/>
    The current page is builtin/tables.html.
    The previous page is <a href = "../trove/string-dict.html">../trove/string-dict.html</a>.
    The next page is <a href = "../trove/gdrive-sheets.html">../trove/gdrive-sheets.html</a>.
    </div>
  </body>
</html>