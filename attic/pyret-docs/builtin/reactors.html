<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Untitled</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="reactors" toclevel="1" tocentry="yes"></h1><p>Pyret’s reactors help create reactive programs: ones that respond to the passage of time, user interactions, or other stimuli. Reactors also update any visual output. Combining these lets us write games, animations, simulations, and more. They are also designed well to support various forms of testing. Reactors are inspired by the <a href="https://docs.racket-lang.org/teachpack/2htdpuniverse.html">universe</a> package in Racket. For more on their design, <a href="https://cs.brown.edu/~sk/Publications/Papers/Published/plpk-reactor-design/">read this paper</a>.</p><h2 id="s:reactors" toclevel="2" tocentry="yes">Creating Reactors</h2><div><div class="pyret-display">Reactor&lt;a&gt;</div><p><span><a name="Reactor&lt;a&gt;-24"></a></span>Reactors are values enabling the creation of games, animations, simulations, and other interactive programs.</p></div><p><tt class="pyretexpr">reactor</tt>s are created with special syntax:</p><pre class="nothing_special">reactor:
  init: <py-prod>expr</py-prod>,

  on-tick: <py-prod>expr</py-prod>,
  seconds-per-tick: <py-prod>expr</py-prod>

  on-mouse: <py-prod>expr</py-prod>,
  on-key: <py-prod>expr</py-prod>,

  to-draw: <py-prod>expr</py-prod>,

  stop-when: <py-prod>expr</py-prod>,
  close-when-stop: <py-prod>expr</py-prod>,

  title: <py-prod>expr</py-prod>
end</pre><p>Syntactically, all of the components of a <tt class="pyretexpr">reactor</tt> are optional, with the exception of <tt class="pyretexpr">init:</tt>.  They can also appear in any order—the order displayed above is not required.  Each option can only appear once.  So, for example, these are valid reactors:</p><pre class="good-ex">reactor:
  init: "inert"
end</pre><pre class="good-ex">fun increment(x): x + 1 end

reactor:
  on-tick: increment,
  init: 10,
end</pre><pre class="good-ex">fun tencrement(x): x + 10 end

reactor:
  seconds-per-tick: 0.1,
  title: "Count by 10",
  on-tick: tencrement,
  init: 10,
end</pre><p>These are not allowed:</p><pre class="bad-ex">reactor:
  init: 10,
  init: 11,
end</pre><pre class="bad-ex">reactor:
  title: "No init",
  seconds-per-tick: 0.1,
end</pre><pre class="bad-ex">reactor:
  init: 10,
  not-a-handler: "not allowed"
end</pre><h2 id="Configuring-and-Running-a-Reactor" toclevel="2" tocentry="yes">Configuring and Running a Reactor</h2><div><pre class="pyret-display">interact :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; Reactor&lt;a&gt;</pre><p>While there are a number of useful operations on a reactor, the most central is interacting with one.  The <tt class="pyretexpr">interact</tt> function takes a reactor as an argument starts an interactive event loop as described by the reactor’s configuration.  In <url>https://code.pyret.org</url>, for a very simple reactor with just an initial value, the reactor’s display looks like:</p><p><img src="inert-reactor.png"/></p><p>Any value can be used for <tt class="pyretexpr">init</tt>, and that value will be shown by default by <tt class="pyretexpr">interact</tt>.</p><p>Each of the options below adds or configures some interactive option in the reactor.</p></div><h3 id="" toclevel="3" tocentry="yes"><tt class="pyretexpr">init</tt></h3><p>Specifies the initial value for the reactor.  This is the beginning state of the values that change throughout the simulation or game.</p><h3 id="" toclevel="3" tocentry="yes"><tt class="pyretexpr">on-tick</tt></h3><p>The <tt class="pyretexpr">on-tick</tt> option expects to be given a function of one argument.  The argument should be of the same type as the value given to <tt class="pyretexpr">init</tt>, and the function should return the same type.  So for a Reactor&lt;a&gt;, the type of the on-tick handler is:</p><p><tt class="pyretexpr">on-tick :: <span>a -&gt; a</span></tt></p><p>This function is called every time the reactor’s clock ticks, which happens by default 28 times per second, this can be configured with <a href="builtin/reactors.html#s:seconds-per-tick"><tt class="pyretexpr">seconds-per-tick</tt></a>.  The value returned by the function becomes the new value of the reactor.</p><p><img src="on-tick.gif"/></p><h3 id="s:seconds-per-tick" toclevel="3" tocentry="yes"><tt class="pyretexpr">seconds-per-tick</tt></h3><p>The <tt class="pyretexpr">seconds-per-tick</tt> option expects to be given a Number.</p><p><tt class="pyretexpr">seconds-per-tick :: Number</tt></p><p>If it is provided, the delay between two successive calls to the <tt class="pyretexpr">on-tick</tt> handler is equal to the provided number in seconds (up to the granularity of tick events on the underlying machine).  If not provided, the default delay is 1/28 seconds.</p><h3 id="" toclevel="3" tocentry="yes"><tt class="pyretexpr">to-draw</tt></h3><p>The <tt class="pyretexpr">to-draw</tt> option expects to be given a function of one argument.  The argument should be of the same type as the value given to <tt class="pyretexpr">init</tt>, and the function should return a <tt class="pyretexpr">Imageimage</tt>.  So for a Reactor&lt;a&gt;, the type of the to-draw handler is:</p><p><img src="to-draw.gif"/></p><p><tt class="pyretexpr">to-draw :: <span>a -&gt; Image</span></tt></p><p>This function is called each time the reactor’s value changes, and is displayed instead of the reactor’s value.</p><h3 id="" toclevel="3" tocentry="yes"><tt class="pyretexpr">on-key</tt></h3><p>The <tt class="pyretexpr">on-key</tt> handler expects to be given a function of two arguments, which describe the current reactor state and a key event:</p><p><tt class="pyretexpr">on-key :: <span>aString -&gt; a</span></tt></p><p>The string describes a single keypress.  Most keys map directly to single-character strings (striking the A key produces <tt class="pyretexpr">“a”</tt>, for instance).  A number of special keys are encoded as longer words for ease of use:</p><p><itemlist><item>Backspace key: <tt class="pyretexpr">“backspace”</tt></item><item>Tab key: <tt class="pyretexpr">“tab”</tt></item><item>Enter key: <tt class="pyretexpr">“enter”</tt></item><item>Shift key: <tt class="pyretexpr">“shift”</tt></item><item>Control key: <tt class="pyretexpr">“control”</tt></item><item>Pause key: <tt class="pyretexpr">“pause”</tt></item><item>Escape key: <tt class="pyretexpr">“escape”</tt></item><item>Prior key: <tt class="pyretexpr">“prior”</tt></item><item>Next key: <tt class="pyretexpr">“next”</tt></item><item>End key: <tt class="pyretexpr">“end”</tt></item><item>Home key: <tt class="pyretexpr">“home”</tt></item><item>Left arrow: <tt class="pyretexpr">“left”</tt></item><item>Up arrow: <tt class="pyretexpr">“up”</tt></item><item>Right arrow: <tt class="pyretexpr">“right”</tt></item><item>Down arrow: <tt class="pyretexpr">“down”</tt></item><item>Print key: <tt class="pyretexpr">“print”</tt></item><item>Insert key: <tt class="pyretexpr">“insert”</tt></item><item>Delete key: <tt class="pyretexpr">“delete”</tt></item><item>Backspace key: <tt class="pyretexpr">“backspace”</tt></item><item>Num lock key: <tt class="pyretexpr">“numlock”</tt></item><item>Scroll key: <tt class="pyretexpr">“scroll”</tt></item></itemlist></p><h3 id="" toclevel="3" tocentry="yes"><tt class="pyretexpr">on-mouse</tt></h3><p>The <tt class="pyretexpr">on-mouse</tt> handler expects to be given a function of four arguments, which describe the current reactor state and a mouse event:</p><p><tt class="pyretexpr">on-mouse :: <span>aNumberNumberString -&gt; a</span></tt></p><p>The two numbers indicate the x and y coordinates of the mouse, and the string indicates the type of mouse event, which is one of:</p><p><itemlist><item><tt class="pyretexpr">“button-down”</tt> signals that the computer user has pushed a mouse button down;</item><item><tt class="pyretexpr">“button-up”</tt> signals that the computer user has let go of a mouse button;</item><item><tt class="pyretexpr">“drag”</tt> signals that the computer user is dragging the mouse. A dragging event occurs when the mouse moves while a mouse button is pressed.</item><item><tt class="pyretexpr">“move”</tt> signals that the computer user has moved the mouse;</item><item><tt class="pyretexpr">“enter”</tt> signals that the computer user has moved the mouse into the canvas area; and</item><item><tt class="pyretexpr">“leave”</tt> signals that the computer user has moved the mouse out of the canvas area.</item></itemlist></p><h3 id="s:stop-when" toclevel="3" tocentry="yes"><tt class="pyretexpr">stop-when</tt></h3><p>The <tt class="pyretexpr">stop-when</tt> handler expects to be given a function of one argument. The argument is the reactor state, and it should return a Boolean:</p><p><tt class="pyretexpr">stop-when :: <span>a -&gt; Boolean</span></tt></p><p>This function is called each time the reactor changes its state.  If it returns <tt class="pyretexpr">true</tt>, then the reactor stays in that state and no longer responds to stimuli like clock ticks, key presses, or mouse events.  If <a href="builtin/reactors.html#s:close-when-stop"><tt class="pyretexpr">close-when-stop</tt></a> is <tt class="pyretexpr">true</tt>, the window closes immediately and evaluation continues.</p><h3 id="s:close-when-stop" toclevel="3" tocentry="yes"><tt class="pyretexpr">close-when-stop</tt></h3><p>The <tt class="pyretexpr">close-when-stop</tt> option expects to be given a Boolean.</p><p><tt class="pyretexpr">close-when-stop :: Boolean</tt></p><p>If it is <tt class="pyretexpr">false</tt> or not provided, the window stays open when <tt class="pyretexpr">stop-when</tt> is triggered, showing the last drawn frame.  If it is <tt class="pyretexpr">true</tt>, the window is immediately closed.</p><h3 id="s:title" toclevel="3" tocentry="yes"><tt class="pyretexpr">title</tt></h3><p>The <tt class="pyretexpr">title</tt> option expects to be given a String.</p><p><tt class="pyretexpr">title :: String</tt></p><p>The string is used instead of “reactor” in the title bar of the interaction window.</p><h2 id="s:manual-events" toclevel="2" tocentry="yes">Reacting to Events Programmatically</h2><p>Several functions are provided to programmatically trigger the various handlers of a reactor.  This can be used to simulate an interaction for testing or exploration.</p><div><pre class="pyret-display">get-value :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; a</pre><p>  Given a reactor, returns the current value of its state.</p><pre>include reactors

r = reactor:
  init: 0,
end

check:
  get-value(r) is 0
end</pre></div><div><pre class="pyret-display">react :: (<span>r :: Reactor&lt;a&gt;</span>, <span>event :: Reactor&lt;a&gt;</span>) -&gt; Reactor&lt;a&gt;</pre><p>  Given a reactor and a single <tt class="pyretexpr">Event</tt>, produce a new reactor that   results from calling the appropriate handler.  Note that it does not change   the state of the input reactor; a <i>new</i> reactor is created.</p><pre>include reactors

fun increment(x): x + 1 end

r = reactor:
  init: 0,
  on-tick: increment,
end

check:
  get-value(r) is 0
  r2 = react(r, time-tick)
  get-value(r2) is 1
  get-value(r) is 0
end</pre></div><div><pre class="pyret-display">draw :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; Image</pre><p>Produces the result of calling the <tt class="pyretexpr">to-draw</tt> handler on the given reactor with its current state.</p></div><div><pre class="pyret-display">is-stopped :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; Boolean</pre><p>Produces the result of calling the <tt class="pyretexpr">stop-when</tt> handler on the given reactor with its current state.</p></div><pre><tt>Event&lt;()&gt;:</tt>
<div><tt>   | <span>| time-tick</span></tt>
<tt>   | <span>keypress(<span>key :: String</span>)</span></tt>
<tt>   | <span>mouse(<span>x :: Number</span>, <span>y :: Number</span>, <span>kind :: String</span>)</span></tt></div><tt>end</tt></pre><p><singleton-doc>Eventtime-tickEventRepresents a single tick of the clock</singleton-doc> <span>constructor-doc</span> <span>constructor-doc</span></p><h2 id="Tracing" toclevel="2" tocentry="yes">Tracing</h2><p>Several functions control <i>tracing</i> the evaluation of a reactor to provide the history of states as data.</p><div><pre class="pyret-display">interact-trace :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; Table</pre><p>Evaluates the same as <tt class="pyretexpr">interact</tt>, but instead of returning the final reactor, return a Table of two columns, <tt class="pyretexpr">tick</tt> and <tt class="pyretexpr">state</tt>.  The <tt class="pyretexpr">state</tt> column holds the values of all the states that the reactor held during the interaction, and the <tt class="pyretexpr">tick</tt> column numbers them.</p><p>This is equivalent to <tt class="pyretexpr">get-trace-as-table(interact(start-trace(r)))</tt>.</p></div><div><pre class="pyret-display">simulate-trace :: (<span>r :: Reactor&lt;a&gt;</span>, <span>limit :: Reactor&lt;a&gt;</span>) -&gt; Table</pre><p>Similar to <tt class="pyretexpr">interact-trace</tt>, but instead of opening an interaction window, simply supplies tick events to the reactor until either the <a href="builtin/reactors.html#s:stop-when"><tt class="pyretexpr">stop-when</tt></a> condition becomes true, or <tt class="pyretexpr">limit</tt> ticks have been processed.  Useful for driving simulations without waiting for delayed tick intervals.</p></div><div><pre class="pyret-display">start-trace :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; Reactor&lt;a&gt;</pre><p>Returns a new reactor that is just like the input reactor, but has tracing enabled.  This means on each interaction, or call to <tt class="pyretexpr">react</tt>, the current state will be saved to a list in the reactor, for later extraction with <tt class="pyretexpr">get-trace</tt> or <tt class="pyretexpr">get-trace-as-table</tt>.</p></div><div><pre class="pyret-display">stop-trace :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; Reactor&lt;a&gt;</pre><p>Returns a new reactor with tracing disabled.  This is useful for toggling a reactor back and forth between modes, since storing traces can take up lots of memory for if states are large or an interaction is long-running.</p></div><div><pre class="pyret-display">get-trace :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; List&lt;a&gt;</pre><p>Returns a List of the traced states of the reactor.</p></div><div><pre class="pyret-display">get-trace-as-table :: (<span>r :: Reactor&lt;a&gt;</span>) -&gt; Table</pre><p>Returns a Table of the traced states of the reactor, in two columns, <tt class="pyretexpr">tick</tt> and <tt class="pyretexpr">state</tt>.</p></div></div></root>
    <hr/>
    The current page is builtin/reactors.html.
    The previous page is <a href = "../trove/image.html">../trove/image.html</a>.
    The next page is <a href = "../trove/statistics.html">../trove/statistics.html</a>.
    </div>
  </body>
</html>