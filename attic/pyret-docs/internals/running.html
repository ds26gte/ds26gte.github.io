<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Running Code (Safely)</title>
  </head>
  <body>
    <div class="container">
    <root><h1 id="s:running" toclevel="1" tocentry="yes">Running Code (Safely)</h1><p>In order to support both responsive evaluation and simulate an arbitrarily deep stack, Pyret has an evaluation model that does not exactly match JavaScript’s.</p><p>When a Pyret function is compiled, it gets an extra <tt class="pyretexpr">try/catch</tt> handler wrapped around it that listens for special Pyret-specific exceptions.  That means when it’s running, we can think of the stack frame of the function as having an extra layer around it:</p><p><img src="frames.png"/></p><p>When a Pyret function detects (via a counter stored in the runtime) that the stack depth is approaching the maximum that JavaScript can tolerate, it throws an exception:</p><p><img src="exception.png"/></p><p>When the exception is encountered by one of the handlers, it attaches enough information to the exception to restart the handler’s frame before allowing the exception to coninue:</p><p><img src="first-frame.png"/></p><p>This continues through the entire stack, storing a list of Pyret stack frames stored on the exception object:</p><p><img src="many-frames.png"/></p><p>Until finally, the entire Pyret stack is reified on the exception object, and all the JavaScript frames from the Pyret functions are gone:</p><p><img src="stack.png"/></p><p>This exception is caught by Pyret’s toplevel, which restarts the <emph>bottommost</emph> element of the stack, which now has nothing above it, instead of a full stack.  It can make progress with the available JS stack.  The runtime can store the existing Pyret stack and add to it if the JS stack runs out again.</p><p>This works just fine if all that’s running is Pyret code.  However, there are two cases where JavaScript code that interacts with Pyret needs to be handled delicately.</p><h2 id="JS-Pretending-to-be-Pyret" toclevel="2" tocentry="yes">JS Pretending to be Pyret</h2><p>Many library use cases, like data structures and convenience functions, are written as JavaScript code that emulates Pyret function calls.  However, if JS code calls back into Pyret code, care is in order.  Here’s what the stack looks like if Pyret calls JavaScript that calls Pyret again:</p><p><img src="callback.png"/></p><p>If the stack limit is reached and an exception thrown, the bottom Pyret frames will have their intermediate state stored:</p><p><img src="callback-bottom.png"/></p><p>But the pure JavaScript frames have no stack management handlers installed, so they are skipped without consideration for any intermediate state they may contain.</p><p><img src="callback-middle.png"/></p><p>The resulting stack doesn’t accurately represent the program that was being executed.  It is, quite literally, nonsense, because a Pyret function will return directly to another Pyret function, ignoring all of the intermediate JavaScript logic.  Using this pattern without any guards or protection will create programs that simply produce wrong answers.</p><p><img src="callback-final.png"/></p><p>Pyret’s runtime defines a function called <internal-id>RuntimesafeCall</internal-id> that allows pure JavaScript to participate in the Pyret stack.</p><div><pre>Runtime.safeCall((→ a), (a → b)) !→ b</pre></div><p><internal-id>RuntimesafeCall</internal-id> combines the two provided functions in a special stack frame:</p><p><img src="safe-call.png"/></p><p>The first argument is called, and in normal execution, its return value is passed to the second function.  The second function’s return value is then the return value of the whole call.  However, if a stack exception occurs, the <emph>second</emph> function is registered as the frame stored on the Pyret stack:</p><p><img src="safe-call-catch.png"/></p><p>This means that in the simulated stack, the second callback (blue in the picture), will receive the result of the last call to a stack-managed function from the first callback (pink in the picture):</p><p><img src="return-1.png"/></p><p>Then, when the second callback (blue) is run, it’s return value will be passed up the stack to the Pyret function that called into the use of <tt class="pyretexpr">safeCall</tt>:</p><p><img src="return-2.png"/></p><p>The usual pattern for using <internal-id>RuntimesafeCall</internal-id> is with a single call to a Pyret function, or another function that calls a Pyret function.  As long as all the calls to Pyret functions are in tail position in safeCalls, no information will be lost.</p><p><bold>Examples</bold></p><p>Calling <tt class="pyretexpr">torepr</tt> can consume a lot of stack (for serializing large data structures), so JavaScript-implemented <tt class="pyretexpr">torepr</tt> methods often need to use <tt class="pyretexpr">safeCall</tt>.  For example, a function that does work with the result of a <tt class="pyretexpr">torepr</tt> call needs to use <tt class="pyretexpr">safeCall</tt> to capture the result correctly:</p><pre class="nothing_special">function makeDataType(val) {
  function torepr(self, toreprRecursive) {
    return runtime.safeCall(function() {
      return toreprRecursive.app(val);
    }, function(valAsString) {
      return "Value was: " + valAsString
    })
  }
  return runtime.makeObject({
    _torepr: runtime.makeMethod1(torepr)
  });
}</pre><p><note>We haven’t found a way to turn this into an error, so testing and code review are the only real protections.  The best way to test for this kind of problem is to pass deeply recursive callbacks into the JS library, which can trigger odd behavior.  If you have suggestions for patterns or tools to make this less error-prone, let us know.</note> If instead it was written as:</p><pre class="nothing_special">function makeDataType(val) {
  function torepr(self, toreprRecursive) {
    var valAsString = toreprRecursive.app(val);
    return "Value was: " + valAsString;
  }
  return runtime.makeObject({
    _torepr: runtime.makeMethod1(torepr)
  });
}</pre><p>then, a <tt class="pyretexpr">torepr</tt> call on the resulting object could use up all the stack while evaluating <tt class="pyretexpr">toreprRecursive.app(val)</tt>, causing the string concatenation in the return to simply be ignored.</p><h2 id="Asynchronous-JS-and-Pyret" toclevel="2" tocentry="yes">Asynchronous JS and Pyret</h2><p>Lots of JavaScript code works asynchronously, with callbacks that are registered to be invoked after the stack clears.  The control flow of these callbacks interacts with Pyret’s stack infrastructure.  Most callback-using JavaScript code simply returns <tt class="pyretexpr">undefined</tt> immediately, and all further computation happens in either success or failure continuations.  This doesn’t play nicely with Pyret’s stack-based control flow, because Pyret functions expect a meaningful return value.<note>We could require that all Pyret code that uses JS callback libraries use Pyret callbacks, but it’s hardly elegant to require that all students learn to use callbacks before they can import an image.</note></p><p><img src="ajax.png"/></p><p>In order to weave the control flow of Pyret through the success and failure continuations of callbacks, the runtime provides a way to pause and reify the Pyret stack for later resumption.</p><div><pre>Runtime.pauseStack((Restarter → Undefined)) → Undefined</pre></div><p>When <tt class="pyretexpr">pauseStack</tt> is called, a special <emph>pause</emph> exception is thrown, that stores the callback passed in as the argument to <tt class="pyretexpr">pauseStack</tt>.  The pause exception collects Pyret stack frames in the same way as a stack exception, it just keeps track of the callback as well:</p><p><img src="pause.png"/></p><p>The pause exception is handled specially at the toplevel, by creating a <tt class="pyretexpr">Restarter</tt> object that is capable of resuming, stopping, or signalling an error at the point the Pyret stack was paused.  This <tt class="pyretexpr">Restarter</tt> is passed into the callback argument to <tt class="pyretexpr">pauseStack</tt>, which can then <emph>asynchronously</emph> restart the Pyret process:</p><pre class="nothing_special">Restarter :: {
  resume: PyretVal → Undefined,
  error: (PyretError U PyretVal) → Undefined,
  break: → Undefined
}</pre><p>Example:</p><pre class="nothing_special">myRuntime.pauseStack(function(restarter) {
  var request = $.ajax("/api");
  request.then(function(answer) {
    restarter.resume(toPyretResponse(answer));
  });
  request.fail(function(err) {
    restarter.error(myRuntime.ffi.makeMessageException("Request failed"));
  });
});</pre><p>Some things to note:</p><p><itemlist><item>It is an error to call more than one of <tt class="pyretexpr">resume</tt>/<tt class="pyretexpr">error</tt>/<tt class="pyretexpr">break</tt>: a <tt class="pyretexpr">Restarter</tt> is not a continuation that can be invoked multiple times.</item><item>If none of the callbacks are ever called, from the point of view of the running Pyret process, the program is in an infinite loop (for example, the IDE may show a “running” GIF forever).  This includes the case where executing the callback ends in an error.  So, using <tt class="pyretexpr">pauseStack</tt> requires some care in writing robust JavaScript code, or odd behavior can result.</item></itemlist></p><div><pre>Runtime.schedulePause((Restarter → Undefined)) → Undefined</pre></div><p>Similar to <internal-id>RuntimepauseStack</internal-id>, but used from outside the runtime (e.g. in the REPL), to schedule a pause.  Since the point of interruption (and resumption) is not predictable from outside the Pyret thread, the <tt class="pyretexpr">resume</tt> method of the <tt class="pyretexpr">Restarter</tt> for <tt class="pyretexpr">schedulePause</tt> ignores any value passed to it; it always resumes the computation exactly as it would have continued had it not been paused.</p><p>If <internal-id>RuntimeschedulePause</internal-id> is called during a synchronous <internal-id>Runtimerun</internal-id>, the runtime will still wait until the next stack exception to call the given <tt class="pyretexpr">Restarter</tt>.  If called during an asynchronous run, the next time a setTimeout is triggered, the <tt class="pyretexpr">Restarter</tt> will be called.</p><p>If <internal-id>RuntimeschedulePause</internal-id> is called multiple times before Pyret checks for scheduled pauses, the last call’s <tt class="pyretexpr">Restarter</tt> is used, and any earlier calls are ignored.</p><h2 id="Starting-a-New-Pyret-Stack" toclevel="2" tocentry="yes">Starting a New Pyret Stack</h2><p>The description of <internal-id>RuntimesafeCall</internal-id> and <internal-id>RuntimepauseStack</internal-id> assume that the calls are being made in a running Pyret execution context.  This is the case for most library code that would get run via <tt class="pyretexpr">import</tt>, and be using external APIs.</p><p>However, some applications may need to start new Pyret instances from scratch. In order for the special <tt class="pyretexpr">PauseExceptions</tt> and <tt class="pyretexpr">StackExceptions</tt> to be caught at the top level and correctly restarted, the handlers need to be correctly installed.  This is done by <internal-id>Runtimerun</internal-id>:</p><div><pre>Runtime.run(
  (Runtime, Namespace → a)
  Namespace
  RunOptions
  (RunResult&lt;a&gt; → Undef)
)
→ Undef</pre></div><p>The first argument is the program to run, which takes a <tt class="pyretexpr">Runtime</tt> (which is always the same as the runtime <tt class="pyretexpr">run</tt> is called on), and a <tt class="pyretexpr">Namespace</tt> as arguments.  Pyret programs are compiled to look for any global identifiers in <tt class="pyretexpr">Namespace</tt>.  The second argument is the <tt class="pyretexpr">Namespace</tt> passed to the function to run (adding to the namespace is useful for e.g. putting REPL-defined identifiers into scope).  <tt class="pyretexpr">RunOptions</tt> has only one field: <tt class="pyretexpr">sync</tt>, which is a boolean indicating if the program should be run <emph>synchronously</emph> or not.  This is described more in <a href="internals/running.html#s:synchronous">Synchronous vs. Asynchronous Execution</a>.  Finally, the last argument is a callback that gets either a <tt class="pyretexpr">Success</tt> or <tt class="pyretexpr">Failure</tt> result, described in <a href="internals/running.html#s:result-structures">Result Data Structures</a>.</p><p>Only one <tt class="pyretexpr">run</tt> call can be active for a given <tt class="pyretexpr">runtime</tt> at once.  If it is called more than once, an error that says <tt class="pyretexpr">“run called while already running”</tt> will be raised.  New calls to <internal-id>Runtimerun</internal-id> should only be used at the logical start of a Pyret program’s execution (e.g. running the definitions window, running a REPL entry, running a standalone test case start-to-finish), not for loading libraries, interacting with native JS APIs, or managing asynchronous APIs.</p><h3 id="s:synchronous" toclevel="3" tocentry="yes">Synchronous vs. Asynchronous Execution</h3><p>The <tt class="pyretexpr">sync</tt> flag passed to <internal-id>Runtimerun</internal-id> changes how stack pauses are managed.  In synchronous mode (<tt class="pyretexpr">sync: true</tt>), when a stack or pause exception reaches the top level, it is immediately restarted.  This is the fastest option, and is the default for Pyret running from the command-line.</p><p>However, when executing synchronously, Pyret never yields to the event loop. If <tt class="pyretexpr">sync: true</tt> were used in a context with user interaction, like a browser page, the UI thread would never get a chance to run.  If <tt class="pyretexpr">sync</tt> is set to <tt class="pyretexpr">false</tt>, when the stack limit is reached, or a pause execption is thrown, it is restarted after first yielding to the event loop (using <tt class="pyretexpr">setTimeout</tt>). This provides a window for the browser to process click and key events, avoiding page lockup.  This also gives the ability for UI elements to trigger calls to <internal-id>RuntimeschedulePause</internal-id>, which will call back to the pauser the next time the Pyret thread restarts.</p><h3 id="s:result-structures" toclevel="3" tocentry="yes">Result Data Structures</h3><div><pre>Runtime.makeSuccessResult(a) → SuccessResult&lt;a&gt;</pre></div><p>Represents a successful completion of a Pyret execution with <internal-id>Runtimerun</internal-id>.</p><div><pre>Runtime.isSuccessResult(Any) → Bool</pre></div><p>Checks if a value is a <tt class="pyretexpr">SuccessResult</tt>.</p><div><pre>Runtime.SuccessResult.result :: Any</pre></div><p>The field that stores the answer of a <tt class="pyretexpr">SuccessResult</tt>.</p><div><pre>Runtime.makeFailureResult(a) → FailureResult&lt;a&gt;</pre></div><p>Represents a Pyret execution with <internal-id>Runtimerun</internal-id> that ended in some kind of exception (either from Pyret or an internal JavaScript error).</p><div><pre>Runtime.isFailureResult(Any) → Bool</pre></div><p>Checks if a value is a <tt class="pyretexpr">FailureResult</tt>.</p><div><pre>Runtime.FailureResult.exn :: Any</pre></div><p>The field that stores the exception value of a <tt class="pyretexpr">FailureResult</tt>.</p></root>
    <hr/>
    The current page is internals/running.html.
    The previous page is <a href = "../internals/ffi-helpers.html">../internals/ffi-helpers.html</a>.
    The next page is <a href = "../internals/modules.html">../internals/modules.html</a>.
    </div>
  </body>
</html>