<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Module Representation</title>
  </head>
  <body>
    <div class="container">
    <root><h1 id="Module-Representation" toclevel="1" tocentry="yes">Module Representation</h1><h2 id="s:module-rep" toclevel="2" tocentry="yes">Representation</h2><h3 id="s:single-module" toclevel="3" tocentry="yes">Single Modules</h3><p>Modules are represented as JavaScript object literals.  Aside from the <tt class="pyretexpr">theModule</tt> field, which contains the compiled code of the module, they follow a JSON-structured schema.  The format has several design goals:</p><p><itemlist><item>It should not require any free or global JavaScript identifiers beyond chapter 15 of the ES5 spec, allowing the compiler and runtime system to parameterize the module by its context.<margin-note>Some modules, like <a href="UnDeFiNeD">images</a> and the <a href="trove/world.html#world"></a> library, use global variables like <tt class="pyretexpr">document</tt>, though we’d like to refactor them so they don’t need to.</margin-note></item><item>It should be reasonable for a developer to write by hand, so that modules in pure JavaScript can seamlessly co-exist with compiled Pyret modules.</item><item>It should be simple for the compiler to produce and consume.</item><item>It should contain the information necessary for its dependents to be statically checked, without consulting the original source program.</item></itemlist></p><p>A module, whether compiled or handwritten, has the following form:</p><pre class="nothing_special">module := {
  "requires": [&lt;require&gt;, ...],
  "provides": &lt;provides&gt;,
  "nativeRequires": [&lt;nativeRequire&gt;, ...],
  "theModule": &lt;moduleFunction&gt;
}

require :=
  | { "import-type": "builtin", "name": &lt;string&gt; }
  | { "import-type": "dependency", "protocol": &lt;string&gt;, "args": [&lt;string&gt;, ...] }

nativeRequire :=
  | &lt;string&gt;

provides :=
  {
    aliases: { &lt;name&gt;: &lt;type&gt;, ... },
    values: { &lt;name&gt;: &lt;type&gt;, ... },
    datatypes: { &lt;name&gt;: &lt;type&gt;, ... }
    // &lt;type&gt;s in shorthands cannot use shorthands as types
    // (described below)
    shorthands: { &lt;name&gt;: &lt;type&gt;, ... },
  }

prim-type :=
  | "tany" | "Number" | "String" | "Boolean" | "Any" | "Nothing"


type :=
  | &lt;prim-type&gt;
  | &lt;type-full&gt;
  | &lt;type-array&gt;
  | &lt;string-defined-in-shorthands&gt;

type-full :=
  | { tag: "any" }
  | { tag: "name", origin: &lt;require&gt;, name: &lt;string&gt; }
  | { tag: "forall", args: [&lt;string&gt;, ...], onto: &lt;type&gt; }
  | { tag: "arrow", args: [&lt;type&gt;, ...], ret: &lt;type&gt; }
  | { tag: "tyapp", onto: &lt;type&gt;, args: [&lt;type&gt;, ...] }
  | { tag: "tyvar", name: &lt;string&gt; }
  | { tag: "record", fields: { &lt;name&gt;: &lt;type&gt; }, ... }
  | { tag: "data",
      name: &lt;string&gt;,
      params: [&lt;string&gt;, ...],
      variants: [&lt;variant-full&gt;, ...],
      methods: { &lt;name&gt;: &lt;type&gt;, ... }
    }

variant-full :=
  | { tag: "variant",
      name: &lt;string&gt;,
      vmembers: [&lt;vmember-full&gt;, ...]
    }
  | { tag: "singleton-variant", name: &lt;string&gt; }

vmember-full :=
  | { tag: "variant-member", name: &lt;string&gt;, kind: &lt;variant-kind&gt;, typ: &lt;type&gt; }

variant-kind :=
  | "normal" | "ref"

type-array :=
  | ["Array", &lt;type&gt;]
  | ["RawArray", &lt;type&gt;]
  | ["Option", &lt;type&gt;]
  | ["List", &lt;type&gt;]
    # type of args, resulting constructed type
  | ["Maker", &lt;type&gt;, &lt;type&gt;]
  | ["arrow", [&lt;type&gt;, ...], &lt;type&gt;]
  | ["data",
      &lt;string&gt;,
      [&lt;string&gt;, ...],
      [&lt;variant-array&gt;, ...],
      { &lt;name&gt;: &lt;type&gt;, ... }
    ]
  | ["tid", &lt;string&gt;]
  | ["forall", [&lt;string&gt;, ...], &lt;type&gt;]
  | ["local", &lt;string&gt;]
  | ["record", { &lt;name&gt;: &lt;type&gt;, ... }]
  | ["tyapp", &lt;type&gt;, [&lt;type&gt;, ...]]

variant-array :=
  | [&lt;string&gt;]
  | [&lt;string&gt;, [&lt;vmember-array&gt;, ...]]

vmember-array :=
  | [&lt;string&gt;, &lt;type&gt;]
  | ["ref", &lt;string&gt;, &lt;type&gt;]

moduleFunction :=
  | function(runtime, namespace, uri, &lt;id&gt;, ..., &lt;id&gt;, ...) {
      // compiled or handwritten JavaScript code
    }
</pre><p>The first three fields—<tt class="pyretexpr">requires</tt>, <tt class="pyretexpr">provides</tt>, and <tt class="pyretexpr">nativeRequires</tt>—hold static information about the modules dependencies and exports.</p><h5 id=""><bold>requires</bold></h5><p>The <tt class="pyretexpr">requires</tt> field holds the compiled equivalent of an <tt class="pyretexpr">import</tt> line. This includes the kind of import, and any parameters that are part of the import statement.  For example, the import line <tt class="pyretexpr">import file(”./lib/helpers.arr”) as H</tt> would show up in the compiled code as</p><pre class="nothing_special">{ "import-type": "dependency",
  "protocol": "file",
  "args": ["./lib/helpers.arr"] }</pre><p>Builtin imports, like <tt class="pyretexpr">lists</tt> and <tt class="pyretexpr">sets</tt>, have an <tt class="pyretexpr">import-type</tt> of <tt class="pyretexpr">“builtin”</tt>:</p><pre class="nothing_special">{ "import-type": "builtin", name: "lists" }</pre><p>Note that the <tt class="pyretexpr">require</tt> can be generated from an import line without any special context information.  For example, in the example above, the path is not resolved to an absolute path.  This happens later in [REF].  This decision in large part supports the goal of handwritten modules, where it would be onerous to fill in absolute paths and keep track of them.</p><h5 id=""><bold>provides</bold></h5><p><tt class="pyretexpr">provides</tt> describe the types exported from a module.  This includes:</p><p><itemlist><item><p>The types of exported <tt class="pyretexpr">values</tt>.  So, for example, a program that   defines</p><pre class="nothing_special">x :: Number = 22</pre><p>  would have the following in its in its compiled <tt class="pyretexpr">provides.values</tt>:</p><pre class="nothing_special">x: "Number"</pre></item><item><p>The types of exported <tt class="pyretexpr">aliases</tt>.  For example, a program that   defines</p><pre class="nothing_special">type Point = { x :: Number, y :: Number }</pre><p>  would have the following in its compiled <tt class="pyretexpr">provides.aliases</tt>:</p><pre class="nothing_special">Point: {
  tag: "record",
  fields: { x: "Number", y: "Number" }
}</pre></item><item><p>Any exported <tt class="pyretexpr">datatypes</tt>.  For example, a program that defines</p><pre class="nothing_special">data Point:
  | point(x :: Number, y :: Number)
end</pre><p>  would have the following in its compiled <tt class="pyretexpr">provides.datatypes</tt>:</p><pre class="nothing_special">Point: {
  tag: "data",
  name: "Point",
  params: [],
  variants: [
    {
      tag: "variant",
      name: "point",
      vmembers: [
        {
          tag: "variant-member",
          kind: "normal",
          name: "x"
          typ: "Number"
        },
        {
          tag: "variant-member",
          kind: "normal",
          name: "y"
          typ: "Number"
        }
      ]
    }
  ],
  methods: {}
}</pre></item></itemlist></p><p>Writing out all of the types fully, with <tt class="pyretexpr">tag</tt> and so on, is quite a bit of typing for handwritten modules.  So these types can also be specified in an array notation, where the first element of the array is typically a string indicating the tag, and the rest of the array describes the type positionally. So, for example, the datatype for <tt class="pyretexpr">Point</tt> could be written:</p><pre class="nothing_special">Point: ["data",
         "Point",
         [],
         [
           ["variant", "point", [["x", "Number"], ["y", "Number"]]]
         ],
         {}
       ]</pre><p>Both styles are fully supported and can be interchanged.</p><p>Since often modules refer to the same type many times, it can be painful to write out the same type over and over in a handwritten specification.  The <tt class="pyretexpr">provides</tt> declaration also allows specification of <tt class="pyretexpr">shorthands</tt>, which are not new types exported by the module, but rather shortcuts for writing out its types.  For example, a module that implements dictionaries from a key type <tt class="pyretexpr">K</tt> to a value type <tt class="pyretexpr">V</tt> will likely use a type like this repeatedly:</p><pre class="nothing_special">["tyapp", ["local", "Dict"], [["tid", "K"], ["tid", "V"]]]</pre><p>That is, the locally-defined (within this module) type <tt class="pyretexpr">Dict</tt>, parameterized by two type variables.  Instead of writing:</p><pre class="nothing_special">{
  values: {
    "new-dict": ["forall", ["K", "V"], ["arrow", [],
      ["tyapp", ["local", "Dict"], [["tid", "K"], ["tid", "V"]]]]],
    "set": ["forall", ["K", "V"], ["arrow",
        [
          ["tyapp", ["local", "Dict"], [["tid", "K"], ["tid", "V"]]]
          ["tid", "K"],
          ["tid", "V"]
        ],
        ["tyapp", ["local", "Dict"], [["tid", "K"], ["tid", "V"]]]]],
    "get": ["forall", ["K", "V"], ["arrow",
        [
          ["tyapp", ["local", "Dict"], [["tid", "K"], ["tid", "V"]]]
          ["tid", "K"],
        ],
        ["Option", "V"]]]
  }
  // aliases and types and so on
}</pre><p>It’s easier to define:</p><pre class="nothing_special">{
  shorthands: {
    dOfKV: ["tyapp", ["local", "Dict"], [["tid", "K"], ["tid", "V"]]]
  },
  values: {
    "new-dict": ["forall", ["K", "V"], ["arrow", [], dofKV]],
    "set": ["forall", ["K", "V"], ["arrow",
        [ dOfKV, ["tid", "K"], ["tid", "V"] ],
        dOfKV]],
    "get": ["forall", ["K", "V"], ["arrow",
        [ dOfKV, ["tid", "K"], ],
        ["Option", "V"]]]
  }
  // aliases and types and so on
}</pre><p>There are several examples of the uses of these declarations in [REF].</p><p>Some “shorthands with options” are predefined, namely <tt class="pyretexpr">Option</tt>, <tt class="pyretexpr">Array</tt>, <tt class="pyretexpr">RawArray</tt>, <tt class="pyretexpr">List</tt>, and <tt class="pyretexpr">Maker</tt>.  The first four of these are straightforward, single-argument type constructors.  The last one describes the type of <tt class="pyretexpr">list</tt> in <tt class="pyretexpr">[list: ...]</tt>, namely, the type of the object whose fields allow for the construction of composite values.  Makers accept two type arguments: the type of the <tt class="pyretexpr">...</tt> arguments in the constructor notation, and the resulting type of the constructed value.</p><h5 id=""><bold>nativeRequires</bold></h5><p>Describe dependencies of the module that are not Pyret-based.  The strings in <tt class="pyretexpr">nativeRequires</tt> are processed not by Pyret’s module loading system, but by a (configurable) use of RequireJS.  This is discussed later in [REF].</p><p>Pyret distinguishes <tt class="pyretexpr">nativeRequires</tt> for several reasons.  In some contexts, like running on Node, there needs to be some mechanism for accessing system libraries like <tt class="pyretexpr">fs</tt> for filesystem access.  In addition, there are numerous JavaScript libraries implemented in RequireJS format, and it’s useful to have a way for handwritten Pyret modules to import and use them directly.  To avoid using global scope or other mechanisms, the runtime uses RequireJS as a standard way to locate and load these modules.</p><p><margin-note>Of course, this also assumes that code is run within a sandbox so it cannot simply <tt class="pyretexpr">eval</tt> its way to arbitrary behavior.  While Pyret doesn’t currently run within something like Caja [REF] when evaled, it is a long-term goal.</margin-note> In addition, with the assumption that modules do not rely on globals, this makes the task of auditing modules for their use of special, non-language behavior easier, since such an audit can start from the <tt class="pyretexpr">nativeRequires</tt> specifications across all modules.</p><h5 id=""><bold>theModule</bold></h5><p>The final field, <tt class="pyretexpr">theModule</tt>, holds a function that implements the module’s behavior, and constructs the values that it provides.  Its arguments have a particular shape:</p><p><itemlist><item><bold>runtime</bold>–the first argument is the current runtime (as described in <a href="internals/runtime.html#s:runtime-object">The Pyret Runtime</a>).  This is the entrypoint for most interesting built-in Pyret behavior, and used pervasively in compiled and handwritten modules alike.</item><item><bold>namespace</bold>–the second argument is a dictionary object, called a namespace [REF], that holds the mappings for global identifiers and types available in the module.  This is seldom useful in handwritten code; its main use is in modules at the REPL that have an interesting and changing set of globally-available names.</item><item><bold>uri</bold>–the third argument is the URI of the module, as a string. Since the same code could be loaded for different purposes (e.g. a Google Drive module loaded both from a shared import and a path import), a module does not store its URI at compile time.  The URI is provided when the module is instantiated, which can be used for logging, reporting error messages, and other unique module identification purposes.</item><item><bold>requires</bold> ids–After <tt class="pyretexpr">uri</tt>, there should be a number of identifiers equal to the number of <tt class="pyretexpr">require</tt>s listed.  These will hold the module objects [REF] for the specified dependencies when the module is loaded.</item><item><bold>nativeRequires</bold> ids–After the <tt class="pyretexpr">requires</tt> ids, there should be a number of identifiers equal to the number of <tt class="pyretexpr">nativeRequires</tt> listed. These will hold the values returned from using RequireJS on the native dependencies when the module is loaded.</item></itemlist></p><h3 id="s:js-interop-example" toclevel="3" tocentry="yes">JavaScript Interop Example (node)</h3><p>In command-line Pyret, the module import form <tt class="pyretexpr">js-file</tt> will look for a (relative) path to a JavaScript file in the JavaScript module format, and load it. Here is an example:</p><pre class="nothing_special">$ ls
lib.js     test.arr
$ cat lib.js
({
  requires: [],
  nativeRequires: [],
  provides: {
    values: { "from-a-library": "String" }
  },
  theModule: function(runtime, _, uri) {
    return runtime.makeModuleReturn({
      "from-a-library": "I'm from a library!"
    }, {});
  }
})
$ cat test.arr
import js-file("lib") as L

print(L.from-a-library + "\n")
⤇ pyret -q test.arr
I'm from a library!
The program didn't define any tests.</pre><h3 id="s:complete" toclevel="3" tocentry="yes">Complete Programs</h3><p>Modules as described in <a href="internals/modules.html#s:single-module">Single Modules</a> lack the necessary information and context to run–their dependencies must still be provided, most crucially, and the runtime needs to know in which order to run them.</p><p>To this end, Pyret also specifies a format for complete programs, which contains all the information needed to run a program, given a runtime and an implementation of RequireJS.  Running such a complete program, which can be done in several ways, is discussed in [REF].  This section lays out and motivates its structure.  This structure is not intended to be written by hand.</p><pre class="nothing_special">program := {
  staticModules: &lt;staticModules&gt;,
  depMap: &lt;depmap&gt;,
  toLoad: [&lt;uri&gt;, ...],
}

depmap := { &lt;uri&gt;: { &lt;dependency&gt; : &lt;uri&gt;, ... }, ... }

staticModules := { &lt;uri&gt;: &lt;module&gt;, ... }

dependency := string encoding of &lt;require&gt;

module := as above</pre><p>The dictionary of <tt class="pyretexpr">staticModules</tt> maps from uri to module structures as described in <a href="internals/modules.html#s:single-module">Single Modules</a>.  This includes all the Pyret-based modules and code that the program will use.  It’s worth noting that the information in the <tt class="pyretexpr">provides</tt> block is (potentially) extraneous if the only goal is to run the program.  However, if compiled modules are to provide enough information to e.g. type-check code that is linked against them in the future, it’s worth keeping this static information around.</p><p>The <tt class="pyretexpr">depmap</tt> indicates, for each listed <tt class="pyretexpr">require</tt> dependency, which module should be used to satisfy it.  This is indicated by mapping from a string representation of the <tt class="pyretexpr">require</tt> to the URI for the appropriate module.  The string encoding is straightforward, and creates a string that looks much like the original import line.  For example, a <tt class="pyretexpr">require</tt> like:</p><pre class="nothing_special">{ "import-type": "dependency", "protocol": "file", "args": ["./lib/helpers.arr"] }</pre><p>would appear encoded as</p><pre class="nothing_special">file(./lib/helpers.arr)</pre><p>The <tt class="pyretexpr">toLoad</tt> list indicates the order in which the modules should be loaded. It should always be a valid topological sort of the graph implicit in <tt class="pyretexpr">depmap</tt>.  In that sense, it’s not strictly necessary information, but it makes running a generated program much more straightforward, since its clear in which order to instantiate modules.  This also makes it easy to determine the main entrypoint for the program, which is the <i>last</i> module indicated in the <tt class="pyretexpr">toLoad</tt> list.  That is, the modules leading up to the last one are exactly its (transitive) dependencies, and run in order to create their exports, which will be used later in the <tt class="pyretexpr">toLoad</tt> list to instantiate further modules.</p><p>Concretely, the first few modules in the <tt class="pyretexpr">toLoad</tt> list are typically builtins, like <tt class="pyretexpr">lists</tt> and <tt class="pyretexpr">error</tt>, required for just about every program. Increasing indices in the <tt class="pyretexpr">toLoad</tt> list tend towards user-implemented code until finally reaching the main module that the user requested be compiled.</p></root>
    <hr/>
    The current page is internals/modules.html.
    The previous page is <a href = "../internals/running.html">../internals/running.html</a>.
    The next page is <a href = "../z-glossary.html">../z-glossary.html</a>.
    </div>
  </body>
</html>