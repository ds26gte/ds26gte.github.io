<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <style>
     li.indent2 {
       text-indent: 2em;
     }
     ul.toclist {
       list-style-type: none;
     }
     .pyretexpr {
       color: cornflowerblue;
     }
     .function {
       font-family: monospace;
       background-color: #6bccdf;
     }
  </style>
  <head>
    <title>Runtime API</title>
  </head>
  <body>
    <div class="container">
    <root><h1 id="runtime" toclevel="1" tocentry="yes">Runtime API</h1><p>Pyret exposes most of its internal operations on the <tt class="pyretexpr">runtime</tt> object; most JavaScript code that interacts with Pyret will need to know about the runtime.</p><p>The library that defines runtimes is in <tt class="pyretexpr">src/js/base/runtime-anf.js</tt>, and it is configured to be importable with <tt class="pyretexpr">js/runtime-anf</tt> via RequireJS:</p><pre>define(["js/runtime-anf"], function(runtimeLib) {
  // use runtimeLib
});</pre><pre>RuntimeLib.create(options) → Runtime</pre><p>Create a new Pyret runtime.  The <tt class="pyretexpr">RuntimeLib</tt> value itself only exports this interface, and most other useful functions are referenced from the runtime objecs it creates.  The options are:</p><pre>options :: {
  initialGas: Number,
  stdout: String → Undefined,
  stderr: String → Undefined
}</pre><p>The size of the Pyret stack is constrained to <tt class="pyretexpr">initialGas</tt> frames; most applications have little need to set this.</p><p>For applications that need control over printing, they can set <tt class="pyretexpr">stdout</tt> and <tt class="pyretexpr">stderr</tt> to get called whenever Pyret would print strings (e.g. via <tt class="pyretexpr">print</tt>).  This interface may change to accept all Pyret values at some point, to allow for richer rendering interfaces.</p><h2 id="s:runtime-object" toclevel="2" tocentry="yes">The Pyret Runtime</h2><p>The return value of <internal-id>RuntimeLibcreate</internal-id> is a runtime object with many useful methods for programmatically interacting with Pyret.</p><h3 id="Running-Pyret-Programs" toclevel="3" tocentry="yes">Running Pyret Programs</h3><pre>Runtime.runStandalone(
  modules: JSDict&lt;URI, StaticModules&gt;
  dependencies: JSDict&lt;URI, JSDict&lt;String, URI&gt;&gt;
  toLoad: JSArray&lt;URI&gt;
  postLoadHooks: JSDict&lt;URI, (PyretModuleResult -&gt; Undefined)&gt;
)
!→ PyretModuleResult</pre><p>Uses <tt class="pyretexpr">toLoad</tt>—the list of URIs—to evaluate modules in order.  The modules are found in the <tt class="pyretexpr">modules</tt> dictionary, and the <tt class="pyretexpr">dependencies</tt> dictionary describes which modules they depend on.  This structure is described in <a href="UnDeFiNeD">UnDeFiNeD</a>.</p><p>A more important feature of <internal-id>RuntimerunStandalone</internal-id> is the ability to register <tt class="pyretexpr">postLoadHooks</tt>.  This dictionary, keyed on URI, contains callbacks which are invoked on completion of the corresponding module, and passed the module’s result.  The most obvious candidate for a <tt class="pyretexpr">postLoadHook</tt> is the main module, or the last one in the <tt class="pyretexpr">toLoad</tt> list; this is where test results can be fetched and printed and errors reported, based on the returned [REF PyretModuleResult].</p><p>In addition, Pyret’s default standalones register several <tt class="pyretexpr">postLoadHook</tt>s. For example, after the <tt class="pyretexpr">ffi</tt> library is loaded, a number of new fields are added to <tt class="pyretexpr">runtime</tt> to manipulate lists.  Other uses include:</p><p><itemlist><item>Substituting a different checker library by setting <tt class="pyretexpr">current-checker</tt> after loading the appropriate library.</item><item>Logging the completion time for loading each module in the <tt class="pyretexpr">toLoad</tt> list for benchmarking.</item></itemlist></p><p>While evaluating the modules, the runtime caches the results for each module that completed successfully, in the <tt class="pyretexpr">runtime.modules</tt> dictionary.  This can be accessed later to quickly get the exported values of a module without re-running it.</p><h3 id="Creating-Values" toclevel="3" tocentry="yes">Creating Values</h3><pre>Runtime.makeNumber(JSNumber) → PyretNumber</pre><pre>Runtime.makeNumberFromString(JSString) → PyretNumber</pre><p>Parses the string and creates a representation of the number that avoids float overflows and can represent very large and very small rationals exactly.</p><pre>Runtime.makeString(JSString) → PyretString</pre><p>The representation of Pyret strings is JS strings, though this may change to accommodate better Unicode support in the future.</p><pre>Runtime.pyretTrue :: PyretBoolean</pre><pre>Runtime.pyretFalse :: PyretBoolean</pre><p>The runtime values for <tt class="pyretexpr">true</tt> and <tt class="pyretexpr">false</tt> in Pyret.  Representation is JavaScript <tt class="pyretexpr">true</tt> and <tt class="pyretexpr">false</tt>.</p><pre>Runtime.makeArray(JSArray) → PyretRawArray</pre><p>Creates a Pyret <tt class="pyretexpr">RawArrayraw-arrays</tt> with the given elements. Currently the identity function: Pyret raw arrays are JavaScript arrays.</p><pre>Runtime.makeObject(JSObj) → PyretObject</pre><p>Creates a Pyret object with the fields in the input object.  The representation of an object is <emph>not</emph> one-to-one with JS objects.</p><p>The fields of a Pyret object go in the <tt class="pyretexpr">dict</tt> field of the JS object, and the JS object has an additional field called <tt class="pyretexpr">brands</tt>, which hold information about an object’s type information (if it has any). <tt class="pyretexpr">StringDictstring-dict</tt>s, for example, are branded objects.</p><pre>Runtime.makeFunction(JSFunction) → PyretFunction</pre><p>Returns a Pyret function backed by the provided JS function.  The Pyret function will <emph>not</emph> do any arity checks on behalf of the JS function, so any arity checks need to be done explicitly (see <internal-id>RuntimecheckArity</internal-id>).  The function can be accessed directly via the <tt class="pyretexpr">app</tt> field of the Pyret function, but read the section on <internal-id>RuntimesafeCall</internal-id> in order to suitably protect calls to Pyret functions.</p><pre>Runtime.makeMethodN(JSFunction) → PyretMethod</pre><h3 id="Interacting-with-Objects" toclevel="3" tocentry="yes">Interacting with Objects</h3><pre>Runtime.getField(PyretObject, JSString) → PyretValue</pre><p>Gets the field with the given name from the object.  If the field is a method, it is automatically curried over the object, as with dot.</p><pre>Runtime.getColonField(PyretObject, JSString) → PyretValue</pre><p>Gets the field with the given name from the object.  If the field is a method, no additional work is performed.</p><pre>Runtime.getFields(PyretObject) → JSArray&lt;String&gt;</pre><p>Returns all the field names of the given object.</p><pre>Runtime.hasField(PyretObject, JSString) → JSBoolean</pre><p>Checks if the given object has the named field.</p><h3 id="Assertions" toclevel="3" tocentry="yes">Assertions</h3><pre>Runtime.checkArity(
  JSNumber
  Arguments
  JSString
)
→ Undefined</pre><p>Checks that the given argument list has the given arity.  Throws an exception if they don’t match.</p><p>There are a number of checking functions that check that a given argument is of a particular type, and throw an exception if not:</p><pre>Runtime.checkNumber(Any) → Undefined</pre><pre>Runtime.checkString(Any) → Undefined</pre><pre>Runtime.checkBoolean(Any) → Undefined</pre><pre>Runtime.checkObject(Any) → Undefined</pre><pre>Runtime.checkFunction(Any) → Undefined</pre><pre>Runtime.checkMethod(Any) → Undefined</pre><pre>Runtime.checkArray(Any) → Undefined</pre><pre>Runtime.checkPyretVal(Any) → Undefined</pre><h3 id="runtime:equality" toclevel="3" tocentry="yes">Equality</h3><pre>Runtime.combineEquality(EqualityResult, EqualityResult) → EqualityResult</pre><p>Takes two <tt class="pyretexpr">EqualityResultequality</tt>s and combines them.  Any value paired with <tt class="pyretexpr">NotEqualequality</tt> produces <tt class="pyretexpr">NotEqualequality</tt>, any combination of <tt class="pyretexpr">Equalequality</tt> and <tt class="pyretexpr">Unknownequality</tt> produces <tt class="pyretexpr">Unknownequality</tt>, and two <tt class="pyretexpr">Equalequality</tt> values produce <tt class="pyretexpr">Equalequality</tt>.</p><h3 id="FFI-Helpers" toclevel="3" tocentry="yes">FFI Helpers</h3><pre>Runtime.ffi :: FFIHelpers</pre><p>The Pyret runtime instantiates an <a href="UnDeFiNeD"><span><tt class="pyretexpr">FFIHelpers</tt>  object</span></a> and stores in in the <tt class="pyretexpr">ffi</tt> field.</p></root>
    <hr/>
    The current page is internals/runtime.html.
    The previous page is <a href = "../internal.html">../internal.html</a>.
    The next page is <a href = "../internals/ffi-helpers.html">../internals/ffi-helpers.html</a>.
    </div>
  </body>
</html>