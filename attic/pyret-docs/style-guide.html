<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <link rel="stylesheet" href="styles.css">
  <head>
    <title>Pyret Style Guide</title>
  </head>
  <body>
    <div class="container">
    <root><h1 id="Pyret-Style-Guide" toclevel="1" tocentry="yes">Pyret Style Guide</h1><div class="author">by Frank Goodman and Shriram Krishnamurthi</div><p>Ahoy matey! Here be the style guide for Pyret. Follow me rules to find the hidden treasure, or walk the plank!</p><ul class="toclist"><li class="indent1"><a href="#Pyret-Style-Guide">Pyret Style Guide</a></li><li class="indent2"><a href="#General">General</a></li><li class="indent3"><a href="#Indentation">Indentation</a></li><li class="indent3"><a href="#Line-Length">Line Length</a></li><li class="indent3"><a href="#Variable-Naming">Variable Naming</a></li><li class="indent4"><a href="#Naming-Constants">Naming Constants</a></li><li class="indent4"><a href="#Reusing-Variable-Names">Reusing Variable Names</a></li><li class="indent3"><a href="#File-Naming">File Naming</a></li><li class="indent3"><a href="#eg-tests">Example and Tests</a></li><li class="indent2"><a href="#Functions">Functions</a></li><li class="indent3"><a href="#Naming">Naming</a></li><li class="indent3"><a href="#Documentation-Strings">Documentation Strings</a></li><li class="indent3"><a href="#Annotations">Annotations</a></li><li class="indent3"><a href="#Testing">Testing</a></li><li class="indent2"><a href="#Data">Data</a></li><li class="indent3"><a href="#Definitions">Definitions</a></li><li class="indent3"><a href="#Cases">Cases</a></li><li class="indent2"><a href="#Naming-Intermediate-Expressions">Naming Intermediate Expressions</a></li><li class="indent3"><a href="#Local-Variables">Local Variables</a></li><li class="indent3"><a href="#Beware-of---!">Beware of <code>var</code>!</a></li></ul><h2 id="General" toclevel="2" tocentry="yes">General</h2><h3 id="Indentation" toclevel="3" tocentry="yes">Indentation</h3><p>You should indent your code blocks using two spaces (not tabs).</p><h3 id="Line-Length" toclevel="3" tocentry="yes">Line Length</h3><p>Try to keep the total length of your lines under 100 characters.</p><p>For overly long lines, it’s actually really hard to figure out where to put in good line breaks. This is in every language. Look for something that tries to match the logical structure of your program.</p><p>However, there’s usually a better way to solve this problem: create extra variables to name the intermediate pieces, and use those names. E.g.: instead of worrying where to put in line breaks in</p><pre>fun f(x, y, z):
  g(some-very-long-thing(x * x, y + y), other-very-long-thing((x + y + z) / (2 * 3 * 4)))
end</pre><p>it might be better to write it as</p><pre>fun f(x, y, z):
  sensible-name-1 = some-very-long-thing(x * x, y + y)
  sensible-name-2 = other-very-long-thing((x + y + z) / (2 * 3 * 4))
  g(sensible-name-1, sensible-name-2)
end</pre><p>(and think about indenting/shortening those two new lines).</p><p>Not only does this shorten lines, it makes it clearer what all these pieces are doing, helping a later reader (who may be yourself!).</p><h3 id="Variable-Naming" toclevel="3" tocentry="yes">Variable Naming</h3><p>The programming language world rages about the use of <code>camelCase</code> versus <code>under_scores</code> in variable names. Pyret’s syntax supports both, but we can do better.</p><p>In Pyret, you can use dashes (<code>-</code>) inside variable names.<span class="margin-note">This is sometimes called ``kebab case’’, but it would be more accurate to call it ``shish case’’.</span> Thus, you would write <code>camel-case</code> and <code>under-scores</code>. Unlike underscores, dashes don’t need a shift key (or disappear when text is underlined by an environment). Unlike camelcase, dashes don’t create ambiguities (what if one of the words is in all-caps?). Dashes are also humanizing: they make your program look that little bit more like human prose.</p><p>Most languages can’t support dashes because the dash also stands for infix subtraction. In Pyret, subtraction must be surrounded by space. Therefore, <code>camel-case</code> is a name whereas <code>camel - case</code> is subtraction.</p><h4 id="Naming-Constants" toclevel="4" tocentry="yes">Naming Constants</h4><p>You should name constants in all-capital letters unless an external convention would dictate using some other capitalization for that particular name.  For example,</p><pre>MY-COUNT = 100
e = 2.7182</pre><h4 id="Reusing-Variable-Names" toclevel="4" tocentry="yes">Reusing Variable Names</h4><p>Pyret is picky about letting you reuse variable names. This is to help you avoid confusing two different variables that have the same name and accidentally using the wrong one. Specifically, an inner scope can’t use a name that is already bound in an outer scope; but two different inner scopes can each use the same name. For instance,</p><pre>fun f(x): x + 1 end
fun g(x): x + 2 end</pre><p>is legal, but</p><pre>fun h(x):
  x = 4
  x + 1
end</pre><p>is not.</p><h3 id="File-Naming" toclevel="3" tocentry="yes">File Naming</h3><p>Use <code>.arr</code> as the extension for Pyret files.</p><h3 id="eg-tests" toclevel="3" tocentry="yes">Example and Tests</h3><p>We use the syntax of testing to represent two different tasks: <emph>examples</emph>, which help us explore a problem and take steps towards deriving a solution, and <emph>tests</emph>, which are designed to find errors. These are subtly different.</p><p>We write (most) examples <emph>before</emph> writing the corresponding code. Therefore, it makes sense to put these examples in an <code>examples</code> block:</p><pre>examples:
  f(10) is 25
  f(20) is-not 2000
end</pre><p>The keyword <code>examples</code> is synonymous with <code>check</code>, so we could as well have written <code>check</code> instead. However, by convention we use <code>check</code> for tests rather than examples.</p><h2 id="Functions" toclevel="2" tocentry="yes">Functions</h2><h3 id="Naming" toclevel="3" tocentry="yes">Naming</h3><p>Give functions descriptive names. Do the same for arguments. That way, a quick scan of a function’s header will tell you what it does and what the arguments are supposed to do.</p><h3 id="Documentation-Strings" toclevel="3" tocentry="yes">Documentation Strings</h3><p>Unless the name is self-evident, write a brief documentation string for your function. For instance:</p><pre>fun insert(x, l):
  doc: "consumes sorted list l; returns it with x in the right place"
  ...
end</pre><p>Try to write your documentation in functional form, i.e., describing what the function consumes and what it returns after computation.</p><p>If your comment needs to span multiple lines, use three back-ticks—</p><pre>```</pre><p>—to begin and end the string. For instance:</p><pre>fun f(x):
  doc: ```This is a
       multi-line
       comment here.```
  x + x
end</pre><p>This is also how you write a multi-line string in Pyret.</p><h3 id="Annotations" toclevel="3" tocentry="yes">Annotations</h3><p>Wherever possible, annotate both argument and return values. For instance,</p><pre>fun str-len(str :: String) -&gt; Number:
  # ...
end</pre><p>Even though Pyret does not currently check parametric annotations, you should still write them for their value as user documentation. Thus:</p><pre>fun length(lst :: List&lt;Any&gt;) -&gt; Number:
  # ...
end</pre><p>You can even write an arbitrary predicate when a built-in annotation isn’t expressive enough. For instance, suppose we want to write a function that consumes only non-negative numbers. We can define the predicate—</p><pre>fun non-negative(n :: Number) -&gt; Boolean:
  n &gt;= 0
end</pre><p>and then use it as follows:</p><pre>fun sqrt(n :: Number%(non-negative)) -&gt; Number:
  # ...
end</pre><h3 id="Testing" toclevel="3" tocentry="yes">Testing</h3><p>You should test every function you write for both general cases and edge cases.</p><p>As we have discussed earlier [<a href="style-guide.html#eg-tests">Example and Tests</a>], you can write these using <code>examples</code> and <code>check</code>. In addition, you can also write examples and tests of functions as part of the function declaration, using <code>where</code>:</p><pre>fun double(n :: Number) -&gt; Number:
  n * 2
where:
  double(0) is 0
  double(5) is 10
  double(-5) is -10
  double(100) is 200
  double(-100) is -200
end</pre><p>Usually, the examples you create to help you think through the problem would go in an <code>examples</code> block, and a large suite of tests would end up in a separate <code>check</code> block. In a <code>where</code> block, we should have a small number of <emph>illustrative</emph> examples that help a reader to quickly grasp the essence of the function’s behavior. Try to keep the size of the <code>where</code> block small and manageable. In particular, a large test suite—meant to cover lots of behaviors, including potentially redundant ones, and to find bugs—should go in a separate <code>check</code> block rather than cluttering up the function definition’s <code>where</code> region.</p><h2 id="Data" toclevel="2" tocentry="yes">Data</h2><h3 id="Definitions" toclevel="3" tocentry="yes">Definitions</h3><p>Wherever possible, provide annotations in Data definitions:</p><pre>data Animal:
  | snake(name :: String)
  | dillo(weight :: Number, living :: Boolean)
end</pre><h3 id="Cases" toclevel="3" tocentry="yes">Cases</h3><p>To branch on the variants of a datum, use <code>cases</code>:</p><pre>cases (Animal) a:
  | snake(s) =&gt; s == "Dewey"
  | dillo(w, l) =&gt; (w &lt; 10) and l
end</pre><p>Sometimes, you won’t use all the parts of a datum. You can still name an unused part, but it is suggestive to use <code>_</code> instead; this indicates to the reader that that field won’t be used in this computation, so they can ignore it:</p><pre>cases (Animal) a:
  | snake(s) =&gt; ...
  | dillo(w, _) =&gt; ...
end</pre><p>Note that <code>_</code> is different from identifier names like <code>dummy</code> because you can’t write</p><pre>cases (Animal) a:
  | snake(s) =&gt; ...
  | dillo(dummy, dummy) =&gt; ...
end</pre><p>(you’ll get an error because you’re trying to bind <code>dummy</code> twice), but you can write</p><pre>cases (Animal) a:
  | snake(s) =&gt; ...
  | dillo(_, _) =&gt; ...
end</pre><p>and thus ignore multiple fields.</p><p>Finally, if your conditional is not designed to handle a particular kind of datum, signal an error:</p><pre>cases (Animal) a:
  | snake(s) =&gt; ...
  | dillo(_, _) =&gt; raise("Serpents only, please!")
end</pre><h2 id="Naming-Intermediate-Expressions" toclevel="2" tocentry="yes">Naming Intermediate Expressions</h2><h3 id="Local-Variables" toclevel="3" tocentry="yes">Local Variables</h3><p>You are welcome to create local names for expressions. For instance, instead of writing</p><pre>fun hypo-len(a, b):
  num-sqrt((a * a) + (b * b))
end</pre><p>you are welcome to write</p><pre>fun hypo-len(a, b):
  a2 = a * a
  b2 = b * b
  sum-of-other-two-sides = a2 + b2
  num-sqrt(sum-of-other-two-sides)
end</pre><p>Even though you shouldn’t have multiple <emph>expressions</emph> as a function body, these local definitions are not expressions in their own right, so this is perfectly legal code; the value of calling the function is that produced by its expression (which, here, is <code>num-sqrt(sum-of-other-two-sides)</code>).</p><h3 id="Beware-of---!" toclevel="3" tocentry="yes">Beware of <code>var</code>!</h3><p>You might have noticed that Pyret lets you write <code>var</code> before local names: for instance, you can write the previous example as</p><pre>fun hypo-len(a, b):
  var a2 = a * a
  var b2 = b * b
  var sum-of-other-two-sides = a2 + b2
  num-sqrt(sum-of-other-two-sides)
end</pre><p>instead. In particular, if you have prior experience in a language like JavaScript, you might think this is <emph>good</emph> practice. It’s not: <emph>don’t do this</emph>! In Pyret, adding <code>var</code> turns each name into a <emph>mutable variable</emph>, i.e., one that you can modify using an assignment statement. Therefore, do not use <code>var</code> unless you absolutely mean to create a mutable variable.</p></root>
    <hr/>
    The current page is style-guide.html.
    The previous page is <a href = "libraries-internal.html">libraries-internal.html</a>.
    The next page is <a href = "internal.html">internal.html</a>.
    </div>
  </body>
</html>