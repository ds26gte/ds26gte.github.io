<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>equality</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="equality" toclevel="1" tocentry="yes"></h1><div><p>Usage:</p><p><tt>include equality</tt></p><p><tt>import equality as ...</tt></p></div><h2 id="types-of-equality" toclevel="2" tocentry="yes">Types of Equality</h2><p>Pyret has three notions of equality.  Two values can be <i>equal now</i>, <i>equal always</i>, and/or <i>identical</i>.  The following table summarizes the functions and operators that test for these relationships, and how they compare to some other languages’ operators:</p><table><tr><td><span><bold>Name</bold></span></td><td><span><bold>Operator</bold></span></td><td><span><bold>Partial Predicate</bold></span></td><td><span><bold>Total Predicate</bold></span></td><td><span><bold>Similar To</bold></span></td></tr><tr><td><span><i>Equal Always</i></span></td><td><span><code class="uncolored-code">==</code></span></td><td><span><code class="uncolored-code">equal-always</code></span></td><td><span><code class="uncolored-code">equal-always3</code></span></td><td><span><code class="uncolored-code">=</code></span></td></tr><tr><td><span><i>Equal Now</i></span></td><td><span><code class="uncolored-code">=~</code></span></td><td><span><code class="uncolored-code">equal-now</code></span></td><td><span><code class="uncolored-code">equal-now3</code></span></td><td><span><code class="uncolored-code">equal?</code></span></td></tr><tr><td><span><i>Identical</i></span></td><td><span><code class="uncolored-code">&lt;=&gt;</code></span></td><td><span><code class="uncolored-code">identical</code></span></td><td><span><code class="uncolored-code">identical3</code></span></td><td><span><code class="uncolored-code">eq?</code></span></td></tr></table><p>In most programs, you should use <a href="lang/equality.html#eq-fun-equal-always">Equal Always</a> to compare values that you want to check for same-ness.  If you are working with mutable data, you may want to consider the special behavior of <a href="lang/equality.html#eq-fun-equal-now">Equal Now</a>. For some optimizations, defensive code, and capability patterns, you may have a reason to use <a href="lang/equality.html#eq-fun-identical">Identical</a>.</p><p>The binary operators correspond to the partial predicates. After explaining the basics of these operations, we explain why these are partial [<a href="lang/equality.html#s:undefined-equalities">Partial and Total Equality Predicates</a>], and how the total predicates work [<a href="lang/equality.html#s:total-equality-predicates">Total Equality Predicates (Avoiding Incomparability Errors)</a>].</p><h2 id="eq-fun-equal-always" toclevel="2" tocentry="yes">Equal Always</h2><div><p><span><a name="equal-always"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#equal-always">equal-always</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="=="></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#==">==</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>Checks if two values will be equal for all time. When it returns <tt class="pyretexpr">true</tt>, it means the two values can always be used in place of one another. This is explained in detail below and its relationship to other equality functions is given in <a href="lang/equality.html#eq-func-relationship">Properties of Equality Functions</a>.</p><p>The function <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a> and infix operator <code>==</code> have the same behavior. While the infix operator may sometimes be more readable, the function name conveys meaning that may not be clear from the infix operator’s symbolic form. In addition, the infix operator is not a function and hence cannot be passed as a parameter, etc.</p><p><a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a> checks for primitive and structural equality like <a href="../lang/equality.html#equal-now"><tt class="pyretexpr">equal-now</tt></a>, with the exception that it stops at mutable data and only checks that the mutable values are <a href="../lang/equality.html#identical"><tt class="pyretexpr">identical</tt></a>. Checking that mutable values are <a href="../lang/equality.html#identical"><tt class="pyretexpr">identical</tt></a> is what ensures that if two values were <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a> at any point, they will still be <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a> later.</p><div><p><span><a name="&lt;&gt;"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#&lt;&gt;">&lt;&gt;</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>The negation of <tt class="pyretexpr">==</tt>: returns <tt class="pyretexpr">true</tt> if the values are not <tt class="pyretexpr">equal-always</tt> and <tt class="pyretexpr">false</tt> otherwise.</p><h3 id="s:always-equal-mutable" toclevel="3" tocentry="yes">Equal Always and Mutable Data</h3><p>Here are some examples of <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a> stopping at mutable data, but checking immutable data, contrasted with <a href="../lang/equality.html#equal-now"><tt class="pyretexpr">equal-now</tt></a>.</p><pre class="nothing_special">data MyBox:
  | my-box(ref x)
end

check:
  b1 = my-box(1)
  b2 = my-box(1)

  b1 is-not%(equal-always) b2
  b1 is%(equal-now) b2
  b2!{x : 2}

  b1 is-not%(equal-always) b2
  b1 is-not%(equal-now) b2

  b3 = my-box(2)

  # remember that b2 currently refers to 2
  l1 = [list: b1, b2]
  l2 = [list: b1, b2]
  l3 = [list: b1, b3]

  l1 is%(equal-now) l2
  l1 is%(equal-always) l2
  l1 is-not%(identical) l2

  l1 is%(equal-now) l3
  l1 is-not%(equal-always) l3
  l1 is-not%(identical) l3

  b2!{x: 5}

  l1 is%(equal-now) l2
  l1 is%(equal-always) l2
  l1 is-not%(identical) l2

  l1 is-not%(equal-now) l3
  l1 is-not%(equal-always) l3
  l1 is-not%(identical) l3
end</pre><h2 id="eq-fun-equal-now" toclevel="2" tocentry="yes">Equal Now</h2><div><p><span><a name="equal-now"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#equal-now">equal-now</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="=~"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#=~">=~</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>Checks if the two values are equal <i>now</i>. They may not be equal later, so they can’t be used in place of one another at all times. This is explained in detail below and its relationship to other equality functions is given in <a href="lang/equality.html#eq-func-relationship">Properties of Equality Functions</a>.</p><p>The function <a href="../lang/equality.html#equal-now"><tt class="pyretexpr">equal-now</tt></a> and infix operator <code>=~</code> have the same behavior. While the infix operator may sometimes be more readable, the function name conveys meaning that may not be clear from the infix operator’s symbolic form. In addition, the infix operator is not a function and hence cannot be passed as a parameter, etc.</p><h3 id="s:equal-now-primitives" toclevel="3" tocentry="yes">Equal Now and Primitives</h3><p><code class="uncolored-code">equal-now</code> checks primitive equality on numbers, strings, and booleans:</p><div><p><b>Examples:</b></p><pre>check:
  5 is%(equal-now) 5
  5 is-not%(equal-now) 6
  "abc" is%(equal-now) "abc"
  "a" is-not%(equal-now) "b"
  "a" is-not%(equal-now) 5
end</pre></div><h3 id="s:equal-now-structural" toclevel="3" tocentry="yes">Equal Now and Structured Data</h3><p>For instances of <code class="uncolored-code">data</code> (including, for example, instances of <a href="../trove/lists.html#List"><tt class="pyretexpr">List</tt></a>), and objects, <a href="../lang/equality.html#equal-now"><tt class="pyretexpr">equal-now</tt></a> traverses their members and checks for pairwise equality.  So, for example, lists will recursively check that their contents are the same, including the case where their contents are objects:</p><div><p><b>Examples:</b></p><pre>check:
  l1 = [list: 1, 2, 3]
  l2 = [list: 1, 2, 3]

  l1 is%(equal-now) l2
  link(1, l1) is-not%(equal-now) l2

  l3 = [list: {x: 5}]
  l4 = [list: {x: 5}]
  l5 = [list: {x: 6}]
  l3 is%(equal-now) l4
  l3 is-not%(equal-now) l5
end</pre></div><h3 id="s:equal-now-mutable" toclevel="3" tocentry="yes">Equal Now and References</h3><p>Equal Now checks the contents of mutable data it reaches.  This gives it its name: since it only checks the <i>current</i> values, and those fields might change, it is not true that if <code class="uncolored-code">e1 =~ e2</code>, then later <code class="uncolored-code">e1 =~ e2</code> will hold again.  For example:</p><div><p><b>Examples:</b></p><pre>data MyBox:
  | my-box(ref x)
end

check:
  b1 = my-box(1)
  b2 = my-box(1)

  b1 is%(equal-now) b2
  b1!{x : 2}

  b1 is-not%(equal-now) b2
end</pre></div><p>Equal Now will recognize when references form a cycle, and cycles of the same shape are recognized as equal (even though the references might change their contents later):</p><div><p><b>Examples:</b></p><pre>data InfiniteList:
  | i-link(first, ref rest)
  | i-empty
end

check:
  l1 = i-link(1, i-empty)
  l2 = i-link(1, i-empty)
  l3 = i-link(1, i-link(2, i-empty))
  l1!{rest : l1}
  l2!{rest : l2}
  l3!rest!{rest : l3}

  l1 is%(equal-now) l2
  l1 is-not%(equal-now) l3
end</pre></div><h2 id="eq-fun-identical" toclevel="2" tocentry="yes">Identical</h2><div><p><span><a name="identical"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#identical">identical</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="&lt;=&gt;"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#&lt;=&gt;">&lt;=&gt;</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>Checks if two seemingly different values are in fact exactly the same value. When it returns <tt class="pyretexpr">true</tt>, it means the two values can always be used in place of one another (because they are in fact the same value). This is explained in detail below and its relationship to other equality functions is given in <a href="lang/equality.html#eq-func-relationship">Properties of Equality Functions</a>.</p><p>The function <a href="../lang/equality.html#identical"><tt class="pyretexpr">identical</tt></a> and infix operator <code>&lt;=&gt;</code> have the same behavior. While the infix operator may sometimes be more readable, the function name conveys meaning that may not be clear from the infix operator’s symbolic form. In addition, the infix operator is not a function and hence cannot be passed as a parameter, etc.</p><h3 id="s:identical-primitives" toclevel="3" tocentry="yes">Identical and Primitives</h3><p>Identical has the same behavior on primitives as Equal Now (<a href="lang/equality.html#s:equal-now-primitives">Equal Now and Primitives</a>).</p><h3 id="s:identical-structural" toclevel="3" tocentry="yes">Identical and Structural Equality</h3><p>Identical does not visit members of objects or data instances.  Instead, it checks if the values are actually the same exact value (the operator is meant to indicate that the values are interchangable).  So objects with the same fields are not identical to anything but themselves:</p><div><p><b>Examples:</b></p><pre>check:
  o = { x: 5 }
  o2 = { x: 5 }
  o is-not%(identical) o2
  o is%(identical) o
  o2 is%(identical) o2
end</pre></div><h3 id="s:identical-mutable" toclevel="3" tocentry="yes">Identical and Mutable Data</h3><p>Identical does not inspect the contents of mutable data, either.  It can be used to tell if two references are <i>aliases</i> for the same underlying state, or if they are in fact different (even though they may be equal right now).</p><div><p><b>Examples:</b></p><pre>data InfiniteList:
  | i-link(first, ref rest)
  | i-empty
end

check:
  l1 = i-link(1, i-empty)
  l2 = i-link(1, i-empty)
  l1!{rest : l1}
  l2!{rest : l2}

  l1 is%(identical) l1
  l1!rest is%(identical) l1
  l1 is-not%(identical) l2
  l1!rest is-not%(identical) l2

  l2 is%(identical) l2
  l2!rest is%(identical) l2
  l2 is-not%(identical) l1
  l2!rest is-not%(identical) l1
end</pre></div><h2 id="eq-func-relationship" toclevel="2" tocentry="yes">Properties of Equality Functions</h2><p>The discussion above hints at a relationship between the three functions.  In particular, if two values are Identical, they ought to be Equal Always, and if they are Equal Always, they ought to be Equal Now.  The following table summarizes this relationship, which in fact does hold:</p><table><tr><td><span>If ↓, then →</span></td><td><span><code class="uncolored-code">v1 &lt;=&gt; v2</code></span></td><td><span><code class="uncolored-code">v1 == v2</code></span></td><td><span><code class="uncolored-code">v1 =~ v2</code></span></td></tr><tr><td><span><code class="uncolored-code">v1 &lt;=&gt; v2 is true</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">true</code></span></td><td><span><code class="uncolored-code">true</code></span></td></tr><tr><td><span><code class="uncolored-code">v1 == v2 is true</code></span></td><td><span><code class="uncolored-code">true</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">true</code></span></td></tr><tr><td><span><code class="uncolored-code">v1 =~ v2 is true</code></span></td><td><span><code class="uncolored-code">true</code></span></td><td><span><code class="uncolored-code">true</code></span></td><td><span>-</span></td></tr></table><p>This table doesn’t have all the <tt class="pyretexpr">false</tt> cases in it, because we need to complete the story for a few values that haven’t been discussed before we can give the whole picture.</p><h2 id="s:bounded-equalities" toclevel="2" tocentry="yes">Bounded Equalities</h2><p>When comparing numbers, it’s often useful to be able to compare within a range.  For example, if we write an algorithm that computes an answer to within a given tolerance, we may want to check if the answer is within that tolerance.</p><pre class="nothing_special">check:
  sqrt-5 = num-sqrt(5)
  (sqrt-5 &lt; 2.23) is true
  (sqrt-5 &gt; 2.22) is true
end</pre><p>Pyret has a family of built-in functions for cases like this, and the default is <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a>.  To explain it precisely, it is clearer to first explain the other two functions, <a href="../lang/equality.html#within-rel"><tt class="pyretexpr">within-rel</tt></a> and <a href="../lang/equality.html#within-abs"><tt class="pyretexpr">within-abs</tt></a>:</p><div><p><span><a name="within-rel"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-rel">within-rel</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><p>It takes an argument representing the <i>relative error</i>, and returns a function that can be used to check equality up to that relative error.  For example, we can check if an answer is within 10% of a desired result:</p><pre class="nothing_special">check:
  within-10-percent = within(0.1)
  within-10-percent(9.5, 10.5) is true
end</pre><p>Relative difference is defined by multiplying the <i>smaller</i> of the two numbers by <tt class="pyretexpr">tol</tt>, and checking that the result is less than the difference between them.  That is, in the expression above, <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> checks:</p><pre class="nothing_special">num-abs(9.5 - 10.5) &lt;= (0.1 * num-min(9.5, 10.5))</pre><p><span class="margin-note">Converting to exact numbers first avoids overflows on computing the mean.</span> Put yet another way, aside from some slight differences in bounds checking for errors, we could implement the numeric comparison of <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> as:</p><pre class="nothing_special">fun my-within(tol):
  lam(left, right):
    num-abs(num-exact(left) - num-exact(right))
      &lt;= num-exact(tol) * num-min(num-abs(left), num-abs(right))
  end
end</pre><p>The <tt class="pyretexpr">tol</tt> argument must be between <tt class="pyretexpr">0</tt> and <tt class="pyretexpr">1</tt>.</p><p>Finally, <a href="../lang/equality.html#within-rel"><tt class="pyretexpr">within-rel</tt></a> accepts <i>any</i> two values, not just numbers. On non-numeric arguments, <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> traverses the structures just as in <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a>, but deferring to the bounds-checking equality when a pair of numbers is encountered.  All other values are compared with <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a>.</p><div><p><b>Examples:</b></p><pre>check:
  l7 = [list: 1]
  l8 = [list: ~1.2]
  l7 is%(within-rel(0.5))  l8
  l7 is-not%(within-rel(0.1)) l8
  l7 is%(within-rel(~0.5))  l8
  l7 is-not%(within-rel(~0.1)) l8
end</pre></div><div><p><span><a name="within-abs"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-abs">within-abs</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><p>Like <a href="../lang/equality.html#within-rel"><tt class="pyretexpr">within-rel</tt></a>, but compares with <i>absolute</i> tolerance rather than relative.  The definition is equivalent to:</p><pre class="nothing_special">fun my-within-abs(tol):
  lam(left, right):
    num-abs(num-exact(left) - num-exact(right)) &lt;= tol
  end
end</pre><p>(Note that the right-hand side of the inequality here is <i>not</i> multiplied by the magnitude of the values being compared: the tolerance is therefore <i>absolute</i>, rather than relative to the magnitudes of the values.)</p><div><p><b>Examples:</b></p><pre>check:
  la = [list: 10]
  lb = [list: ~12]
  la is%(within-abs(2))  lb
  la is-not%(within-abs(1))  lb
  la is%(within-abs(~5.5))  lb
  la is-not%(within-abs(~1.9999)) lb
end</pre></div><div><p><span><a name="within"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within">within</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="roughly-equal"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#roughly-equal">roughly-equal</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>The definitions above work smoothly, but provide unintuitive behavior when both values are tiny.  In particular, there are <i>no values at all</i> that are relatively close to zero except zero itself, since the magnitude used to scale the relative tolerance...is zero.  For many purposes, especially with testing (see below) and especially when first developing code, it is common to want to specify a rough tolerance and not especially care whether that tolerance is relative or absolute.  Accordingly, <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> is a function defined to ``smoothe’’ the behavior of <a href="../lang/equality.html#within-rel"><tt class="pyretexpr">within-rel</tt></a> and <a href="../lang/equality.html#within-abs"><tt class="pyretexpr">within-abs</tt></a>, such that the tolerance is treated as <i>relative</i> when the numbers are large in magnitude, and as <i>absolute</i> as they approach zero:</p><div><p><b>Examples:</b></p><pre>check:
  # For large numbers, within behaves like within-rel
  1000 is%(within(0.1)) 1010
  1000 is-not%(within-abs(0.1)) 1010
  1000 is%(within-rel(0.1)) 1010
  # For small numbers, wtihin behaves like within-abs
  0 is%(within(0.1)) 0.0000001
  0 is-not%(within-rel(0.1)) 0.000001
  0 is%(within-abs(0.1)) 0.000001
end</pre></div><p>For even simpler ergonomics, <a href="../lang/equality.html#roughly-equal"><tt class="pyretexpr">roughly-equal</tt></a> is defined to be <tt class="pyretexpr">within(0.000001)</tt>, that is, an error tolerance of one-millionth, or six digits of accuracy.  This tolerance works well in many cases, and the more explicit forms are always available, when more precise control over tolerances is required.</p><p>It’s common to use <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> along with <a href="../lang/testing.html#is%"><tt class="pyretexpr">is%</tt></a> to define the binary predicate inline with the test:</p><div><p><b>Examples:</b></p><pre>check:
  num-sqrt(10) is%(within(0.1)) 3.2
  num-sqrt(10) is-not%(within(0.1)) 5
end</pre></div><p>As a convenient shorthand, <tt class="pyretexpr">is-roughly</tt> is defined as a shorthand for <a href="../lang/testing.html#is%"><tt class="pyretexpr">is%</tt></a>(<a href="../lang/equality.html#roughly-equal"><tt class="pyretexpr">roughly-equal</tt></a>):</p><div><p><b>Examples:</b></p><pre>check:
  num-acos(-1) is-roughly ~3.14159
  num-acos(-1) is%(roughly-equal) ~3.14159
  num-acos(-1) is%(within(0.000001)) ~3.14159
end</pre></div><div><p><span><a name="within-now"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-now">within-now</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="within-rel-now"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-rel-now">within-rel-now</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="within-abs-now"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-abs-now">within-abs-now</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="roughly-equal-now"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#roughly-equal-now">roughly-equal-now</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>Like <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a>, <a href="../lang/equality.html#within-rel"><tt class="pyretexpr">within-rel</tt></a>, <a href="../lang/equality.html#within-abs"><tt class="pyretexpr">within-abs</tt></a> and <a href="../lang/equality.html#roughly-equal"><tt class="pyretexpr">roughly-equal</tt></a>, but they traverse mutable structures as in <tt class="pyretexpr">equal-now</tt>.</p><div><p><b>Examples:</b></p><pre>check:
  aa = [array: 10]
  ab = [array: ~12]
  aa is%(within-rel-now(~0.2))  ab
  aa is-not%(within-rel(~0.2)) ab
  aa is%(within-abs-now(2))  ab
  aa is-not%(within-abs(2))  ab
end</pre></div><h2 id="s:undefined-equalities" toclevel="2" tocentry="yes">Partial and Total Equality Predicates</h2><p>For some values, Pyret refuses to report <tt class="pyretexpr">true</tt> or <tt class="pyretexpr">false</tt> for any equality predicate, and raises an error instead.  For example:</p><pre class="nothing_special">check:
  (~3 == ~3) raises "equality-failure"

  (1 == ~1) raises "equality-failure"

  (lam(x): x end == lam(y): y end) raises "equality-failure"
end</pre><p>This section discusses why this is the case.</p><h3 id="s:roughnum-equality" toclevel="3" tocentry="yes">Roughnums and Equality</h3><p><span class="margin-note"><a href="http://htdp.org/2003-09-26/Book/curriculum-Z-H-41.html#node_chap_33">How to Design Programs</a> describes this design space well.</span> Numbers’ representations in programs reflect a number of tradeoffs, but the upshot is that numbers have finite, approximate representations for performance reasons. Numbers like <tt class="pyretexpr">e</tt>, <tt class="pyretexpr">π</tt>, and <tt class="pyretexpr">√2</tt> are only represented up to some approximation of their true (irrational) value.  When such a result is used in a computation, it represents a <i>rough approximation</i> of the true value.</p><p>Pyret calls these numbers <a href="../builtin/numbers.html#Roughnum"><tt class="pyretexpr">Roughnum</tt></a>s, and they have special rules related to equality.  In particular, they <i>cannot</i> be directly compared for equality, even if it seems like they ought to be equal:</p><pre class="nothing_special">check:
  (~3 == ~3) raises "equality-failure"
end</pre><p>In addition, <a href="../builtin/numbers.html#Roughnum"><tt class="pyretexpr">Roughnum</tt></a>s cannot be compared for equality with <a href="../builtin/numbers.html#Exactnum"><tt class="pyretexpr">Exactnum</tt></a>s, either.</p><pre class="nothing_special">check:
  (~0.1 == 0.1) raises "equality-failure"
end</pre><p><span class="margin-note">This example is not Pyret-specific, but matches the behavior of <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE floating point</a>.</span> Returning either <tt class="pyretexpr">true</tt> or <tt class="pyretexpr">false</tt> in this case would be misleading, as because of unavoidable inaccuracies, both of the following expressions evaluate to <tt class="pyretexpr">~0.1</tt>:</p><pre class="nothing_special">(~1 - ~0.9) + 0.00000000000000003
~0.2 - ~0.1</pre><p>So in the following check block, if we chose either <tt class="pyretexpr">true</tt> or <tt class="pyretexpr">false</tt> for the result of <tt class="pyretexpr">~0.1 == 0.1</tt>, one of the tests would have a misleading failure:</p><pre class="nothing_special">check:
  ((~1 - ~0.9) + 0.00000000000000003) is 0.1
  (~0.2 - ~0.1) is 0.1
end</pre><p>For example, if Pyret answered <tt class="pyretexpr">true</tt> for the rough equivalent, <tt class="pyretexpr">~0.1 == ~0.1</tt>, then this test would pass:</p><pre class="nothing_special">check:
  ((~1 - ~0.9) + 0.00000000000000003) is (~0.2 - ~0.1)
end</pre><p>To avoid giving misleading answers in cases like these, Pyret triggers an error on any number-to-number comparison that involves a <a href="../builtin/numbers.html#Roughnum"><tt class="pyretexpr">Roughnum</tt></a>, which looks like:</p><pre class="nothing_special">These two values cannot be compared for direct equality:

~0.1
~0.1

Approximations of numbers (Roughnums) cannot be compared for equality. The
program may need to use within().</pre><p>If you see this error, it’s a hint that the program should be using an equality from the <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> family of functions to do a relative comparison, rather than a direct equality comparison.  So in this case, we could check that the answer is equal up to an relative error of <tt class="pyretexpr">0.001</tt>:</p><pre class="nothing_special">check:
  ((~1 - ~0.9) + 0.00000000000000003) is%(within(0.001)) (~0.2 - ~0.1)
end</pre><p>It can be useful to check that two <a href="../builtin/numbers.html#Roughnum"><tt class="pyretexpr">Roughnum</tt></a>s are actually indistinguishable, even though they may be approximating different values.  This can be expressed by checking that the numbers are within a tolerance of <tt class="pyretexpr">~0</tt>:</p><pre class="nothing_special">check:
  ((~1 - ~0.9) + 0.00000000000000003) is%(within(~0)) (~0.2 - ~0.1)
end</pre><p>Note that the same won’t work for a tolerance of <tt class="pyretexpr">0</tt>, the exact zero, which will give an error if used to compare two <a href="../builtin/numbers.html#Roughnum"><tt class="pyretexpr">Roughnum</tt></a>s.</p><h3 id="s:function-equality" toclevel="3" tocentry="yes">Functions and Equality</h3><p>When comparing two functions or two methods, all the equality operators raise an exception.  Why?  Well, the traditional way to compare functions for equality (short of solving the halting problem), is to use reference equality (or <a href="../lang/equality.html#identical"><tt class="pyretexpr">identical</tt></a>) on the functions’ representations, the same way as mutable data works.  For a hint of why this can be a misleading definition of equality, consider this data definition:</p><pre class="nothing_special">data Stream&lt;a&gt;:
  | stream(first :: a, rest :: (-&gt; Stream&lt;a&gt;))
end
check:
  fun mk-ones(): stream(1, mk-ones) end
  ones = mk-ones()
  ones is ones # Should this succeed?
  ones is mk-ones() # What about this?
  ones.rest() is mk-ones() # Or this...?
end</pre><p>All of these values (<code class="uncolored-code">ones</code>, <code class="uncolored-code">mk-ones()</code>, etc.) have the same behavior, so we could argue that <code class="uncolored-code">is</code> (which uses <code class="uncolored-code">==</code> behind the scenes) ought to succeed on these.  And indeed, if we used reference equality, it would succeed.  But consider this small tweak to the program:</p><pre class="nothing_special">check:
  fun mk-ones():
    stream(1, lam(): mk-ones() end)  # &lt;-- changed this line
  end
  ones = mk-ones()
  ones is ones # Should this succeed?
  ones is mk-ones() # What about this?
  ones.rest() is mk-ones() # Or this...?
end</pre><p>If we used reference equality on these functions, all of these tests would now fail, and <code class="uncolored-code">ones</code> <i>has the exact same behavior</i>.  Here’s the situation:</p><p><span class="margin-note">In fact, a <a href="http://en.wikipedia.org/wiki/Rice's_theorem">famous result in theoretical computer science</a> is that it is impossible to figure out out if two functions do the same thing in general, even if it is possible in certain special cases (like reference equality).</span></p><p>When reference equality returns <code class="uncolored-code">true</code>, we know that the two functions must have the same behavior.  But when it returns <code class="uncolored-code">false</code>, we know nothing.  The functions may behave exactly the same, or they might be completely different, and the equality predicate can’t tell us either way.</p><p>Pyret takes the following stance: You probably should rethink your program if it relies on comparing functions for equality, since Pyret cannot give reliable answers (no language can).  So, all the examples above (with one notable exception) actually raise errors:</p><pre class="nothing_special">check:
  fun mk-ones():
    stream(1, lam(): mk-ones() end)  # &lt;-- changed this line
  end
  ones = mk-ones()
  ones == ones is true
  ones == mk-ones() raises "Attempted to compare functions"
  ones.rest() == mk-ones() raises "Attempted to compare functions"
end</pre><p>The first test is true because two <a href="../lang/equality.html#identical"><tt class="pyretexpr">identical</tt></a> values are considered <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a>.  This is an interesting point in this design space that Pyret may explore more in the future–it isn’t clear if the benefits of this relationship between <a href="../lang/equality.html#identical"><tt class="pyretexpr">identical</tt></a> and <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a> are worth the slight brittleness in the above example.</p><p><bold>Note 1</bold>: Functions can be compared with non-function values and return <code class="uncolored-code">false</code>.  That is, the equality operators only throw the error if actual function values need to be compared to one another, not if a function value is compared to another type of value:</p><pre class="nothing_special">check:
  f = lam(): "no-op" end
  g = lam(): "also no-op" end

  f == f raises "Attempted to compare functions"
  f == g raises "Attempted to compare functions"
  g == f raises "Attempted to compare functions"

  5 is-not%(equal-always) f

  { x: 5 } is-not%(equal-always) { x: f }
end</pre><p><bold>Note 2</bold>: This rule about functions interacts with structural equality. When comparing two values, it seems at first unclear whether the result should be <code class="uncolored-code">false</code> or an error for this test:</p><pre class="nothing_special">check:
  { x: 5, f: lam(): "no-op" end } is%(equal-always)
    { x: 6, f: lam(): "no-op" end }
end</pre><p>This comparison will return <code class="uncolored-code">false</code>.  The rule is that if the equality algorithm can find values that differ without comparing functions, it will report the difference and return <code class="uncolored-code">false</code>.  However, if all of the non-function comparisons are <code class="uncolored-code">true</code>, and some functions were compared, then an error is raised.  A few more examples:</p><pre class="nothing_special">
check:
  o = { x: 5, y: { z: 6 }, lam(): "no-op" end }
  o2 = { x: 5, y: { z: 7 }, lam(): "no-op" end }

  (o == o) raises "Attempted to compare functions"
  o is-not%(equal-always) o2  # Test succeeds, because z fields differ
end
</pre><h2 id="s:total-equality-predicates" toclevel="2" tocentry="yes">Total Equality Predicates (Avoiding Incomparability Errors)</h2><p>Most Pyret programs should be written using <code class="uncolored-code">equal-always</code>, <code class="uncolored-code">equal-now</code>, and <code class="uncolored-code">identical</code>, which guarantee that an error will be raised if functions are compared.  Some programs, however, need to be able to compare arbitrary values, and it’s convenient to have the ability to compare values without raising an exception.  Since the equality of functions is unknown, we define the result of a total equality check with a new datatype:</p><pre class="nothing_special">data EqualityResult:
  | Equal
  | NotEqual(reason :: String, value1 :: Any, value2 :: Any)
  | Unknown(reason :: String, value1 :: Any, value2 :: Any)</pre><p>  </p><div class="insetpara nested"><pre class="nothing_special">Equal :: EqualityResult

NotEqual :: (
  reason :: String,
  value1 :: Any,
  value2 :: Any
)
-&gt; EqualityResult

Unknown :: (
  reason :: String,
  value1 :: Any,
  value2 :: Any
)
-&gt; EqualityResult</pre></div><p>We define three parallel functions to the equality predicates that return <a href="../missing_gloss"><tt class="pyretexpr">EqualityResult</tt></a> values.  They return <a href="../missing_gloss"><tt class="pyretexpr">Equal</tt></a> and <a href="../missing_gloss"><tt class="pyretexpr">NotEqual</tt></a> whenever the corresponding function would, and <a href="../missing_gloss"><tt class="pyretexpr">Unknown</tt></a> whenever the corresponding function would throw an error:</p><p>  </p><div><p><span><a name="equal-always3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#equal-always3">equal-always3</a> :: <span>Any, Any -&gt; EqualityResult</span></pre></div><p>  </p><div><p><span><a name="equal-now3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#equal-now3">equal-now3</a> :: <span>Any, Any -&gt; EqualityResult</span></pre></div><p>  </p><div><p><span><a name="identical3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#identical3">identical3</a> :: <span>Any, Any -&gt; EqualityResult</span></pre></div><div><p><b>Examples:</b></p><pre>check:
  f = lam(): 5 end
  equal-always3(f, f) is Unknown
  equal-always3(f, 5) satisfies is-NotEqual
  equal-now3(f, f) is Unknown
  equal-now3("a", f) satisfies is-NotEqual
  identical3(f, f) is Unknown
  identical3("a", f) satisfies is-NotEqual
end</pre></div><p>We can now modify our table from above to be more complete:</p><table><tr><td><span>If ↓, then →</span></td><td><span><code class="uncolored-code">identical(v1, v2)</code></span></td><td><span><code class="uncolored-code">equal-always(v1, v2)</code></span></td><td><span><code class="uncolored-code">equal-now(v1, v2)</code></span></td></tr><tr><td><span><code class="uncolored-code">identical(v1, v2) is Equal</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">Equal</code></span></td><td><span><code class="uncolored-code">Equal</code></span></td></tr><tr><td><span><code class="uncolored-code">equal-always(v1, v2) is Equal</code></span></td><td><span><code class="uncolored-code">Equal</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">Equal</code></span></td></tr><tr><td><span><code class="uncolored-code">equal-now(v1, v2) is Equal</code></span></td><td><span><code class="uncolored-code">Equal</code></span></td><td><span><code class="uncolored-code">Equal</code></span></td><td><span>-</span></td></tr><tr><td><span></span></td><td><span></span></td><td><span></span></td><td><span></span></td></tr><tr><td><span><code class="uncolored-code">identical(v1, v2) is NotEqual</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">Equal</code></span></td><td><span><code class="uncolored-code">Equal</code></span></td></tr><tr><td><span><code class="uncolored-code">equal-always(v1, v2) is NotEqual</code></span></td><td><span><code class="uncolored-code">NotEqual</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">Equal</code></span></td></tr><tr><td><span><code class="uncolored-code">equal-now(v1, v2) is NotEqual</code></span></td><td><span><code class="uncolored-code">NotEqual</code></span></td><td><span><code class="uncolored-code">NotEqual</code></span></td><td><span>-</span></td></tr><tr><td><span></span></td><td><span></span></td><td><span></span></td><td><span></span></td></tr><tr><td><span><code class="uncolored-code">identical(v1, v2) is Unknown</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">Unknown</code></span></td><td><span><code class="uncolored-code">Unknown</code></span></td></tr><tr><td><span><code class="uncolored-code">equal-always(v1, v2) is Unknown</code></span></td><td><span><code class="uncolored-code">Unknown</code></span></td><td><span>-</span></td><td><span><code class="uncolored-code">Unknown</code></span></td></tr><tr><td><span><code class="uncolored-code">equal-now(v1, v2) is Unknown</code></span></td><td><span><code class="uncolored-code">Unknown</code></span></td><td><span><code class="uncolored-code">Unknown</code></span></td><td><span>-</span></td></tr></table><p>There are corresponding total functions defined for <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> as well:</p><div><p><span><a name="within3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within3">within3</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="within-rel3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-rel3">within-rel3</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="within-rel-now3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-rel-now3">within-rel-now3</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="within-abs3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-abs3">within-abs3</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><div><p><span><a name="within-abs-now3"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#within-abs-now3">within-abs-now3</a> :: <span><a href="../trove/globals.html#Number">Number</a> -&gt; Any</span></pre></div><h2 id="s:datatype-defined-equality" toclevel="2" tocentry="yes">Datatype-defined Equality</h2><p>The functions <a href="../lang/equality.html#equal-now"><tt class="pyretexpr">equal-now</tt></a> and <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a> are defined to work over values created with <tt class="pyretexpr">data</tt> by comparing fields in the same position.  However, sometimes user-defined values need a more sophisticated notion of equality than this simple definition provides.</p><p>For consider implementing an unordered <i>set</i> of values in Pyret.  We might choose to implement it as a function that creates an object closing over the implementation of the set itself:</p><pre class="nothing_special">fun make-empty-set&lt;a&gt;():
  {
    add(self, element :: a): ... end,
    member(self, element :: a) -&gt; Boolean: ... end,
    equal-to-other-set(self, other) -&gt; Boolean: ... end
  }
end</pre><p>We could fill in the bodies of the methods to have this implementation let clients create sets and add elements to them, but it won’t work well with testing:</p><pre class="nothing_special">check:
  s = make-empty-set().add(5)
  s2 = make-empty-set().add(5)

  s.member(5) is true
  s2.member(5) is true

  s.equal-to-other-set(s2) is true

  s == s2 raises "Attempted to compare functions"
end</pre><p>The final test raises an exception because it traverses the structure of the object, and the only visible values are the three methods, which cannot be compared.  We might just say that users of custom datatypes have to use custom predicates for testing, for example they could write:</p><pre class="nothing_special">check:
  # as before ...
  fun equal-sets(set1, set2): set1.equal-to-other-set(set2) end
  s is%(equal-sets) s2
end</pre><p>This works for sets on their own, but the built-in testing and equality operators will not work with nested user-defined data structures.  For example, since lists are a dataype that checks built-in equality on their members, a list of sets as defined above will not use the equal-to-other-set method when comparing elements, and give an <tt class="pyretexpr">“Attempted to compare functions”</tt> error:</p><pre class="nothing_special">check:
  # as before ...
  ([list: s] == [list: s2]) raises "Attempted to compare functions"
end</pre><p>To help make this use case more pleasant, Pyret picks a method name to call, if it is present, on user-defined objects when checking equality.  The method name is <tt class="pyretexpr">_equals</tt>, and it has the following signature:</p><pre class="nothing_special">._equals :: (
  other :: a,
  equal-rec :: (Any, Any -&gt; EqualityResult)
)
-&gt; EqualityResult</pre><p>Where <tt class="pyretexpr">a</tt> is the type of the object itself (so for sets, <tt class="pyretexpr">other</tt> would be annotated with <tt class="pyretexpr">Set&lt;a&gt;</tt>).</p><p>The <tt class="pyretexpr">_equals</tt> method is called in the equality algorithm when:</p><ul><li>The two values are either both data values or both objects, AND</li><li>If they are data values, the two values are of the same data type and variant, AND</li><li>If they are objects not created by data, they have the same set of <a href="lang/brands.html#brands"></a></li></ul><p>So, for example, an object with an <tt class="pyretexpr">_equals</tt> method that always returns <a href="../missing_gloss"><tt class="pyretexpr">Equal</tt></a> is not considered equal to values that aren’t also objects:</p><pre class="nothing_special">import Equal from equality
check:
  eq-all = { _equals(self, other, eq): Equal end }
  eq-all is-not== f
  eq-all is-not== m
  eq-all is-not== 0
  eq-all is-not== "a"
  eq-all is== {}
end</pre><p>The last argument to <tt class="pyretexpr">_equals</tt> is the recursive equality callback to use for checking equality of any members.  When checking for equality of members (say in our set implementation above), we would use this callback rather than one of <a href="../lang/equality.html#equal-always3"><tt class="pyretexpr">equal-always3</tt></a> or <a href="../lang/equality.html#equal-now3"><tt class="pyretexpr">equal-now3</tt></a>.  The reasons for this are threefold:</p><ul><li>In order to check for equality of cyclic values, Pyret needs to do internal bookkeeping of visited references.  This information is stored within the callback, and calling e.g. <a href="../lang/equality.html#equal-now3"><tt class="pyretexpr">equal-now3</tt></a> directly would not take previously visted references into account.</li><li>To avoid requiring datatypes to implement two equality methods, the callback also knows whether this equality call was started by <a href="../lang/equality.html#equal-now"><tt class="pyretexpr">equal-now</tt></a> or by <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a>.  Any recursive calls should use the original semantics for comparing references, so using the callback ensures that equality checks on elements have the right semantics (even in deeply nested data structures).</li><li>The recursive equality predicate closes over and remembers the <i>tolerance</i> for <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a>-family functions, and whether or not the tolerance is absolute or relative.</li></ul><h2 id="inequalities" toclevel="2" tocentry="yes">Inequalities</h2><p>The inequality operators and functions in Pyret follow different rules than those for equality.  In particular:</p><ul><li>There are no 3-valued forms for the inequality functions, because...</li><li>All the inequalities (even non-strict inequality like <a href="../lang/equality.html#&lt;="><tt class="pyretexpr">&lt;=</tt></a>) are defined on <a href="../builtin/numbers.html#Roughnum"><tt class="pyretexpr">Roughnum</tt></a>s.</li></ul><p>Comparing approximate numbers with inequalities is technically a bit fraught. If <tt class="pyretexpr">x &lt; y</tt> and <tt class="pyretexpr">x</tt> and <tt class="pyretexpr">y</tt> are both approximations, it may be that the approximation error causes the comparison to return <tt class="pyretexpr">true</tt> rather than <tt class="pyretexpr">false</tt>.  The same argument holds for the other inequality operators.  However, the inequality operators can be a part of correct use of approximations, for example by using a test like <tt class="pyretexpr">x &lt; (y + tolerance)</tt>, (where <tt class="pyretexpr">tolerance</tt> could be usefully specified as either positive or negative), in applications that closely track approximation error.  Since in common cases inequality comparison of approximation is quite useful, and it is quite onerous to program with an analog of <a href="../lang/equality.html#within"><tt class="pyretexpr">within</tt></a> for inequalities as well, Pyret chooses to allow the inequality operators to work on approximations.</p><p>The inequality operators all work on either:</p><ul><li>Pairs of numbers (whether exact or approximate)</li><li>Pairs of strings</li><li>Left-hand-side objects with an appropriately-named method (for example, for the <a href="../lang/equality.html#&lt;"><tt class="pyretexpr">&lt;</tt></a> operator, the object must have a <tt class="pyretexpr">_lessthan</tt> method.)</li></ul><p>Numbers are compared in their standard mathematical order.  Strings are compared lexicographically (examples below).  For objects with overloaded methods, the method should return a <a href="../trove/globals.html#Boolean">Boolean</a> and that return value is used as the result.</p><div><p><span><a name="&lt;="></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#&lt;=">&lt;=</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="_lessequal"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#_lessequal">_lessequal</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="&lt;"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#&lt;">&lt;</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="_lessthan"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#_lessthan">_lessthan</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="&gt;="></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#&gt;=">&gt;=</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="_greaterequal"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#_greaterequal">_greaterequal</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="&gt;"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#&gt;">&gt;</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="_greaterthan"></a></span></p><pre class="pyret-display"><a href="../lang/equality.html#_greaterthan">_greaterthan</a> :: <span>Any, Any -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><pre class="nothing_special">check "strings":
  "a" &lt; "b" is true
  "b" &gt; "a" is true

  "a" &lt; "a" is false
  "a" &gt; "a" is false

  "a" &lt;= "a" is true
  "a" &gt;= "a" is true

  "A" &lt; "a" is true
  "a" &gt; "A" is true

  "a" &lt; "A" is false
  "A" &gt; "a" is false

  "a" &lt; "aa" is true
  "a" &gt; "aa" is false

  "a" &lt; "baa" is true
  "a" &gt; "baa" is false
  "abb" &lt; "b" is true
  "abb" &gt; "b" is false

  "ab" &lt; "aa" is false
  "ab" &gt; "aa" is true

  "aa" &lt; "ab" is true
  "aa" &gt; "ab" is false
end</pre><pre class="nothing_special">check "numbers":
  ~5 &lt; 5 is false
  ~5 &gt; 5 is false

  ~5 &lt;= 5 is true
  ~5 &gt;= 5 is true

  ~5 &lt; ~5 is false
  ~4.9 &lt; ~5 is true

  ~5 &lt;= ~5 is true
  ~5 &gt;= ~5 is true
end</pre></div></root>
    <hr/>
    The current page is lang/equality.html.
    The previous page is <a href = "../lang/testing.html">../lang/testing.html</a>.
    The next page is <a href = "../lang/op-precedence.html">../lang/op-precedence.html</a>.
    </div>
  </body>
</html>