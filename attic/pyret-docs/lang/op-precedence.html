<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Combining Multiple Operators</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="op-precedence" toclevel="1" tocentry="yes">Combining Multiple Operators</h1></div><p>Pyret has only one rule for using multiple operators in a single expression: different operators must be explicitly grouped by parentheses, and evaluation always proceeds from left to right.</p><p>Therefore, the following expressions are <bold>not</bold> allowed:</p><pre class="bad-ex">1 + 1 - 1
1 + 1 &gt; 1
1 + 1 == 2
(3 * 4 / 2)
(3 * 4) / 1 + 1
3 * (4 / 2) + 1</pre><p>And will raise an error like:</p><p><img src="src/lang/binop-error.png"/></p><p>Pyret disallows mixing operators without clearly defining the operator precedence using parentheses.  Conversely, any number of identical operators can be grouped without pairwise parentheses.  These expressions are all valid in Pyret:</p><pre class="good-ex">1 + (1 - 1)
(1 + 1) &gt; 1
1 + 1 + 1
1 - 1 - 1
(1 + 1) == 2
3 * (4 / 2)
(3 * (4 / 2))
(3 * 4) / (1 + 1)
(3 * (4 / 2)) + 1</pre><h2 id="But-why-not-use-precedence?" toclevel="2" tocentry="yes">But why not use precedence?</h2><p>Pyret does not use implicit operator precedence or the order of operations that you learned in math class.  ``Please Excuse My Dear Aunt Sally’’ does not apply here.<margin-note>Note for non-American readers: if you’ve never heard of dear Aunt Sally, it’s a <a href="https://en.wikipedia.org/wiki/Order_of_operations#Mnemonics">mnemonic</a> often used to memorize a standard order-of-operations.</margin-note></p><p>Implicit operator precedence is a common source of errors among even experienced developers, so getting in the habit of explicitly defining precedence using parentheses is a good idea even when using languages that support implicit precedence.</p><p>Pyret has many operators, besides just the arithmetic ones: <a href="lang/forms.html#s:binop-expr">comparison and logical operators</a>, <a href="lang/equality.html#types-of-equality">equality operators</a>, <a href="lang/testing.html#testing-operators">testing operators</a>, and others.  While it’s possible to memorize the precedence among just a few of these operations, it’s both tedious and unenlightening to memorize precedences among every possible combination of operators.  Instead, parentheses make the programmer’s intent explicit.</p><p>To make life easier, as said above, Pyret allows you to group multiple uses of the same operator without parentheses: instead of having to write <tt class="pyretexpr">(1 + (2 + 3)) + 4</tt>, you can simply write <tt class="pyretexpr">1 + 2 + 3 + 4</tt>.  The astute reader may immediately object that while this seems fine for addition, it may be confusing for subtraction: after all, <tt class="pyretexpr">1 - (2 - 3)</tt> produces a different result than <tt class="pyretexpr">(1 - 2) - 3</tt>, because subtraction is not associative.  Even this is more subtle than it may seem at first: <i>roughnums</i> are not associative even for addition!</p><pre class="nothing_special">check:
  (~100000000000000 + ~-100000000000000) + ~0.0001 is-roughly ~0.0001
  ~100000000000000 + (~-100000000000000 + ~0.0001) is-roughly ~0
end</pre><p>A similarly nuanced problem occurs with comparison operators: writing <tt class="pyretexpr">1 &lt; 2 &lt; 3</tt> is <i>legal</i>, but will produce an error at runtime, because <tt class="pyretexpr">true</tt> cannot be compared to <tt class="pyretexpr">3</tt>.  Likewise, <tt class="pyretexpr">1 == 1 == 1</tt> will produce <tt class="pyretexpr">false</tt>, because <tt class="pyretexpr">1 == 1</tt> evaluates to <tt class="pyretexpr">true</tt>, which is not equal to <tt class="pyretexpr">1</tt>.  Some other languages attempt to make these expressions ``work’’ and evaluate to true, but by doing so they’ve effectively created new operators that take in <i>three</i> arguments, since their behavior cannot be expressed in terms of any pairwise usage of a binary operator.</p><p>Pyret takes the firm stance that since every operator has its own quirks, it does not make sense to create a complex, hard-to-predict set of rules for how different operators interact.  Instead, it uses just one single rule, with the easy use of parentheses to resolve any unintended behaviors.</p></root>
    <hr/>
    The current page is lang/op-precedence.html.
    The previous page is <a href = "../lang/equality.html">../lang/equality.html</a>.
    The next page is <a href = "../lang/modules.html">../lang/modules.html</a>.
    </div>
  </body>
</html>