<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Testing</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="testing" toclevel="1" tocentry="yes">Testing</h1><h2 id="testing-blocks" toclevel="2" tocentry="yes"><tt class="pyretexpr">check:</tt> and <tt class="pyretexpr">where:</tt> blocks</h2><p>Tests in Pyret are written in special <i>testing blocks</i>.  These blocks can contain any Pyret code that isn’t toplevel-only (like data definitions and import or provide statements), and are the only places where <a href="lang/testing.html#testing-operators">Testing Operators</a> can be used.</p><h3 id="--blocks" toclevel="3" tocentry="yes"><tt class="pyretexpr">check:</tt> blocks</h3><p>The simplest testing blocks are <tt class="pyretexpr">check:</tt> blocks.  They can be written at the top-level or inside other testing blocks.  Check blocks are a unit of reporting test results, so all the test operators that evaluate inside a check block will be reported as part of that block.  For example, these two check blocks:</p><pre class="nothing_special">check "a first block":
  5 is 5
  4 is 5
end

check "a second block":
  6 is 7
end</pre><p>will report:</p><pre class="nothing_special">Check block: a first block
  test (5 is 5): ok
  test (4 is 5): failed, reason:
    Values not equal:
    4
    5
  1/2 tests passed in check block: a first block

Check block: a second block
  test (6 is 7): failed, reason:
    Values not equal:
    6
    7
  The test failed.

1/3 tests passed in all check blocks</pre><p>Testing blocks are also a unit of failure: most of the time an error stops the whole program, but inside a check block (and also inside <tt class="pyretexpr">raises</tt>, mentioned later), the error is stopped and reported, and Pyret goes on to evaluating the next check block:</p><pre class="nothing_special">check "error-block":
  raise("an error here doesn't stop the next check block from running")
  string-length("this test doesn't run") is 21
end

check "a later block":
  string-length("these tests still run") is 21
end</pre><p>Keep an eye out for the message <tt class="pyretexpr">“Check block &lt;some-block&gt; ended in an error (all tests may not have run):”</tt>, because it means that later tests in the same block may not have run, so the output doesn’t reflect all the tests that were written.</p><h3 id="--blocks" toclevel="3" tocentry="yes"><tt class="pyretexpr">where:</tt> blocks</h3><p>Sometimes a function has tests that are explicitly associated with it.  For these cases, the function can end in a <tt class="pyretexpr">where:</tt> block rather than immediately with <tt class="pyretexpr">end</tt>.  <tt class="pyretexpr">where:</tt> blocks run the same way that <tt class="pyretexpr">check:</tt> blocks do, and their name is taken from the function they are attached to.</p><div><p><b>Examples:</b></p><pre>fun double(n):
  n + n
where:
  double(10) is 20
  double(15) is 30
end</pre></div><h2 id="testing-operators" toclevel="2" tocentry="yes">Testing Operators</h2><p>Testing operators should be written on their own line inside a <tt class="pyretexpr">check:</tt> or <tt class="pyretexpr">where:</tt> block.  They can check for a number of properties and come in several forms.</p><h3 id="Binary-Test-Operators" toclevel="3" tocentry="yes">Binary Test Operators</h3><p>Many useful tests compare two values, whether for a specific type of <a href="lang/equality.html#equality">equality</a> or a more sophisticated predicate.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is expr2</tt></p><p>Evaluates <tt class="pyretexpr">expr1</tt> and <tt class="pyretexpr">expr2</tt> to values, and checks if two values are equal via <tt class="pyretexpr">equal-alwaysequality</tt>, reporting success if they are equal, and failure if they are not.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is-not expr2</tt></p><p>Like <tt class="pyretexpr">is</tt>, but failure and success are reversed.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is-roughly expr2</tt></p><p>Like <tt class="pyretexpr">is</tt>, but tolerant of roughnum values: specifically, this is a shorthand for <tt class="pyretexpr">is%</tt>(<tt class="pyretexpr">withinequality</tt>(0.000001)).</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is%(pred) expr2</tt></p><p>Evaluates <tt class="pyretexpr">expr1</tt> and <tt class="pyretexpr">expr2</tt> to values, and <tt class="pyretexpr">pred</tt> to a value that must be a function (an error is reported if <tt class="pyretexpr">pred</tt> is not a function).  It then applies <tt class="pyretexpr">pred</tt> to the two values from <tt class="pyretexpr">expr1</tt> and <tt class="pyretexpr">expr2</tt>.  If the result of that call is <tt class="pyretexpr">true</tt>, reports success, otherwise reports failure.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is-not%(pred) expr2</tt></p><p>Like <tt class="pyretexpr">is%</tt>, but failure and success are reversed.</p><div><p><b>Examples:</b></p><pre>check:
  fun less-than(n1, n2): n1 &lt; n2 end

  1 is%(less-than) 2
  2 is-not%(less-than) 1
end

check:
  fun longer-than(s1, s2):
    string-length(s1) &gt; string-length(s2)
  end

  "abc" is%(longer-than) "ab"
  "" is-not%(longer-than) ""
end

check:
  fun equal-any-order&lt;a&gt;(l1 :: List&lt;a&gt;, l2 :: List&lt;a&gt;):
    same-length = (l1.length() == l2.length())
    all-present = for lists.all(elt from l1):
      lists.member(l2, elt)
    end
    same-length and all-present
  end

  [list: 1, 2, 3] is%(equal-any-order) [list: 3, 2, 1]
  [list: 1, 2, 3] is%(equal-any-order) [list: 2, 1, 3]
  [list: 1, 2, 3, 3] is-not%(equal-any-order) [list: 2, 1, 3]
end

check:
  fun one-of(ans, elts):
    lists.member(elts, ans)
  end

  some-strings = [list: "123", "132", "213", "231", "312", "321"]
  "321" is%(one-of) some-strings
  "123" is%(one-of) some-strings
end

check:
  fun around(delta):
    lam(actual, target):
      num-abs(target - actual) &lt;= delta
    end
  end

  5.05 is%(around(0.1)) 5
  5.00002 is-not%(around(0.00001)) 5
end</pre></div><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is== expr2</tt></p><p>Shorthand for <tt class="pyretexpr">expr1 is%(<tt class="pyretexpr">equal-alwaysequality</tt>) expr2</tt>. Same as <tt class="pyretexpr">is</tt>.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is-not== expr2</tt></p><p>Like <tt class="pyretexpr">is==</tt>, but failure and success are reversed. Same as <tt class="pyretexpr">is-not</tt>.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is=~ expr2</tt></p><p>Shorthand for <tt class="pyretexpr">expr1 is%(<tt class="pyretexpr">equal-nowequality</tt>) expr2</tt></p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is-not=~ expr2</tt></p><p>Like <tt class="pyretexpr">is=~</tt>, but failure and success are reversed.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is&lt;=&gt; expr2</tt></p><p>Shorthand for <tt class="pyretexpr">expr1 is%(<tt class="pyretexpr">identicalequality</tt>) expr2</tt></p><p class="boxed pyret-header"><tt class="pyretexpr">expr1 is-not&lt;=&gt; expr2</tt></p><p>Like <tt class="pyretexpr">is&lt;=&gt;</tt>, but failure and success are reversed.</p><h3 id="Unary-Test-Operators" toclevel="3" tocentry="yes">Unary Test Operators</h3><p class="boxed pyret-header"><tt class="pyretexpr">expr satisfies pred</tt></p><p>Evaluates <tt class="pyretexpr">expr</tt> to a value and <tt class="pyretexpr">pred</tt> to a value expected to be a function (if not a function, an error is thrown).  Then, <tt class="pyretexpr">pred(val)</tt> is evaluated, and if the result is <tt class="pyretexpr">true</tt>, the test succeeds, and if <tt class="pyretexpr">false</tt>, the test fails.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr violates pred</tt></p><p>Like <tt class="pyretexpr">satisfies</tt>, but failure and success are reversed.</p><div><p><b>Examples:</b></p><pre>check:
  [list:] satisfies is-empty
  [list:] satisfies lam(l): l.length() == 0 end

  is-odd = lam(n :: Number): num-modulo(n, 2) == 1 end
  5 satisfies is-odd
  6 violates is-odd
end</pre></div><h3 id="Exception-Test-Operators" toclevel="3" tocentry="yes">Exception Test Operators</h3><p class="boxed pyret-header"><tt class="pyretexpr">expr raises exn-string</tt></p><p>Evaluates <tt class="pyretexpr">expr</tt> and expects an error to be raised.  If no error is raised, the test fails.</p><p>If an error is the result, the <tt class="pyretexpr">torepr&lt;global&gt;</tt> function is called on the exception value, and <tt class="pyretexpr">raises</tt> checks that <tt class="pyretexpr">exn-string</tt> is contained within that string.  If so, the test passes, otherwise, it fails.</p><p>For simple errors (like those in many programming assignments), it works to use <tt class="pyretexpr">raise&lt;global&gt;</tt> on a string value and check that that string is raised.  For larger programs, it can be useful to construct more sophisticated error values and use <tt class="pyretexpr">raises-satisfies</tt> to test them.</p><div><p><b>Examples:</b></p><pre>check:
  raise("the roof!") raises "the roof"

  string-length("too", "many", "strings") raises "arity-mismatch"

  {}.x raises "field-not-found"
end</pre></div><p><bold>Warning!</bold> These two tests are not equivalent:</p><pre class="nothing_special">check "actually catches the error":
  raise("error!") raises "error!"
end

check "error happens before raises":
  value = raise("error!")
  value raises "error!"
end</pre><p>This is because the left-hand-side of <tt class="pyretexpr">raises</tt> is a special position that can detect and catch errors, which normal expressions do not do.  So the second check block fails before even getting to the <tt class="pyretexpr">raises</tt> line; try it out and see what happens.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr raises-other-than exn-string</tt></p><p>Like <tt class="pyretexpr">raises</tt>, but the result must <i>not</i> contain <tt class="pyretexpr">exn-string</tt>.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr does-not-raise</tt></p><p>Evaluates <tt class="pyretexpr">expr</tt> and checks that no error is raised while evaluating it.  The expression can evaluate to any value.</p><p class="boxed pyret-header"><tt class="pyretexpr">expr raises-satisfies pred</tt></p><p>As the name suggests, this combines the idea of <tt class="pyretexpr">raises</tt> with <tt class="pyretexpr">satisfies</tt> and calls <tt class="pyretexpr">pred</tt> on the exception that <tt class="pyretexpr">expr</tt> raises (if any).  Still fails if no exception is raised.</p><div><p><b>Examples:</b></p><pre>import is-field-not-found from error
check:
  o = {}
  o.x raises-satisfies is-field-not-found
end</pre></div><p class="boxed pyret-header"><tt class="pyretexpr">expr raises-violates pred</tt></p><p>Like <tt class="pyretexpr">raises-satisfies</tt>, but the predicate must return <tt class="pyretexpr">false</tt>.  Still fails if no exception is raised.</p></div><h2 id="Reasons-for-tests:----clauses" toclevel="2" tocentry="yes">Reasons for tests: <tt class="pyretexpr">because</tt> clauses</h2><p><test-index-tag>because</test-index-tag></p><p>When writing a test case, we may have several goals in mind: we might want to demonstrate <i>whether</i> a particular function works properly, or we might want to explore <i>why</i> a particular function works the way it does. Consider the following two test cases: when reading them, what meaning do they convey?</p><div><p><b>Examples:</b></p><pre>check:
  distance-to-origin(3, 4) is 5
  distance-to-origin(3, 4) is num-sqrt(num-sqr(3) + num-sqr(4))
end</pre></div><p>Reading the first test case is concise and clear: the expected distance is simply 5.  But why?  Nothing in the expected output gives any insight into how the function works.  By contrast, the second test case gives far more insight, and ``shows our work’’...but it is also much lengthier.  Writing many such test cases would get very tedious, very quickly.  Additionally, there’s nothing tying the two test cases together: we have to notice that the two tests are adjacent in our program and their left sides are identical, to notice that both tests are about the same input scenario.</p><p>Pyret allows us to write test cases in a slightly different way, that addresses both of these concerns:</p><div><p><b>Examples:</b></p><pre>check:
  distance-to-origin(3, 4) is-roughly 5
    because num-sqrt(num-sqr(3) + num-sqr(4))
end</pre></div><p>Read this aloud as ``The distance to origin of (3, 4) is roughly 5, because the square-root of three squared plus four squared is roughly 5.‘’  The <tt class="pyretexpr">because</tt> clause lets us show work, while also connecting the explanation to the original test case.</p><p>Now that there are potentially <i>three</i> components to writing a single test case, there are multiple ways a test case can fail:</p><ul><li>The explanation could be wrong, and so the expected value and the explanation do not match.</li><li>The expected value could be wrong, and so the explanation does not match the expected value even if the explanation is correct.</li><li>The function itself could be wrong, and so the left-hand side produces the wrong value and does not match the expected value.</li><li>The expected value could be wrong, and so the left-hand side does not match the right-hand side even if the function behaves properly.</li></ul><p>As an example of the first case, suppose we had a typo in our explanation (we used <tt class="pyretexpr">num-sqrt</tt> instead of <tt class="pyretexpr">num-sqr</tt>):</p><pre class="bad-ex">check:
  distance-to-origin(3, 4) is-roughly 5
    because num-sqrt(num-sqrt(3) + num-sqr(4))
end</pre><p>Pyret will show us</p><p><img src="test-inconsistent.png"/></p><p>Here, even if the function is defined properly, the explanation and the expected result are inconsistent.  Pyret will show this inconsistency as a test failure, even if the left-hand side and the expected value do match—after all, we might simply have gotten lucky, and the explanation is more accurate! A test case using a <tt class="pyretexpr">because</tt> clause will pass only if the explanation matches the expected value <i>and</i> the left-hand side matches the expected value.</p><p>Using a <tt class="pyretexpr">because</tt> clause is optional, and is most helpful to illustrate a few select examples to demonstrate how we think a function should be working. Once we have a few test cases are passing, we can easily add several more and leave out the <tt class="pyretexpr">because</tt> clauses for them...but if any of them unexpectedly fail, we can easily add a <tt class="pyretexpr">because</tt> clause to them to help debug the failure.</p><h3 id="Using----with-other-testing-operators" toclevel="3" tocentry="yes">Using <tt class="pyretexpr">because</tt> with other testing operators</h3><p>For an arbitrary test case <tt class="pyretexpr">expr1 &lt;test-op&gt; expr2 because expr3</tt>, read this aloud as ``<tt class="pyretexpr">expr1 &lt;test-op&gt; expr2</tt> because <tt class="pyretexpr">expr3 &lt;test-op&gt; expr2</tt>.‘’  So for example:</p><ul><li><tt class="pyretexpr">times-two(3) is 6 because 2 * 3</tt> reads as ``<tt class="pyretexpr">times-two</tt> of 3 is 6, because two times 3 is 6.‘’  Note that this reads analogously for <tt class="pyretexpr">is-roughly</tt>, <tt class="pyretexpr">is==</tt>, <tt class="pyretexpr">is=~</tt>, <tt class="pyretexpr">is&lt;=&gt;</tt>, and <tt class="pyretexpr">is%(...)</tt>.</li><li><tt class="pyretexpr">times-two(3) satisfies is-even because 2 * 3</tt> reads as ``<tt class="pyretexpr">times-two</tt> of 3 should be even, because two times 3 should be even.‘’</li><li><tt class="pyretexpr">reciprocal(0) raises “division by zero” because 1 / 0</tt> reads as ``The reciprocal of zero raises a division-by-zero error, because <tt class="pyretexpr">1 / 0</tt> raises a division-by-zero error.‘’</li></ul><p>The other testing operators also work with <tt class="pyretexpr">because</tt> in the same way, though it is a bit harder to read them aloud.</p></root>
    <hr/>
    The current page is lang/testing.html.
    The previous page is <a href = "../lang/forms.html">../lang/forms.html</a>.
    The next page is <a href = "../lang/equality.html">../lang/equality.html</a>.
    </div>
  </body>
</html>