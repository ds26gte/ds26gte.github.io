<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Use</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="use" toclevel="1" tocentry="yes">Use</h1><h2 id="s:use:context" toclevel="2" tocentry="yes">Contexts</h2><div><p><span><a name="use-context-47"></a></span></p><pre class="pyret-display">use context &lt;import&gt;</pre><p><a href="lang/modules.html#modules">Modules</a> are a useful mechanism for providing and including names between different parts of a program that is split across files. One limitation of modules is that importing or including names from a module is strictly <bold>additive</bold>–including can only make <bold>more names</bold> available. For different course contexts and applications, sometimes we want more control over exactly which names are available, including leaving some out, or redefining some common names ourselves.</p><p>This is what <tt class="pyretexpr">use context</tt> is for. The meaning of <tt class="pyretexpr">use context</tt> is to start the program in an context with no names at all available, and then adding only what’s provided from the module listed after <tt class="pyretexpr">context</tt> <tt class="pyretexpr">&lt;import&gt;</tt>. The <tt class="pyretexpr">&lt;import&gt;</tt> part of  <tt class="pyretexpr">use context</tt> line can use any of the <a href="lang/modules.html#s:modules:finding-modules">dependency types</a>.</p></div><p>As an example, consider an assignment where students write their own implementation of lists, defining functions named <tt class="pyretexpr">map</tt>, <tt class="pyretexpr">filter</tt>, and so on. In this case, the context they use should not be the default context (because it already has <tt class="pyretexpr">map</tt> and so on):</p><pre class="bad-ex">use context essentials2021

data List&lt;A&gt;:
  | empty
  | link(first :: A, rest :: List&lt;A&gt;)
end

# causes a shadowing error because empty and link already are defined and
# provided by essentials2021</pre><p>You could create a context with just a limited set of global names, and publish it as a <tt class="pyretexpr">shared-gdrive</tt> module:</p><pre class="good-ex"># In file "list-assignment-context.arr"
use context global # This is a good default environment to use when constructing namespaces
# Basic functions/types like num-max, to-string, Number, String
import global as G
provide from G: *, type * end

# Option and Either might be used as return types for some list functions,
# so provide those
import option as O
provide from O: *, type * end

import either as E
provide from E: *, type * end</pre><p>Then students could use that module as their context:</p><pre class="good-ex">use context shared-gdrive("list-assignment-context.arr", "google-id-goes-here")

data List&lt;A&gt;:
  | empty
  | link(first :: A, rest :: List&lt;A&gt;)
end</pre><h3 id="s:use:compat" toclevel="3" tocentry="yes">Backwards and Forwards Compatibility</h3><p>By default, until <tt class="pyretexpr">use context</tt> was released, all Pyret programs had a single default context. It had provided common names related to, for example, <a href="trove/lists.html#lists">Lists</a> and <a href="trove/option.html#option">Option</a>.  Now files that don’t have a <tt class="pyretexpr">use</tt> line are treated as if they start with <tt class="pyretexpr">use context essentials2020</tt>, which is equivalent to this historically available default context. The online environment <a href="https://code.pyret.org">code.pyret.org</a> inserts <tt class="pyretexpr">use context essentialsYEAR</tt> into new programs, where <tt class="pyretexpr">YEAR</tt> will change when new useful names are available. Notably, <tt class="pyretexpr">essentials2021</tt> includes all of the names for the untyped <a href="UnDeFiNeD">Image</a> library by default, removing the need to <tt class="pyretexpr">include image</tt> in new programs.</p><p>Existing contexts provided by Pyret, like <tt class="pyretexpr">essentials2020</tt> and <tt class="pyretexpr">essentials2021</tt>, aren’t intended to change the names they provide, so files with a <tt class="pyretexpr">use context</tt> line won’t have their set of available names changed with updates to the language. This is important for <bold>forwards</bold> compatibility, because Pyret is particular about <a href="lang/forms.html#s:shadowing">shadowing</a>, so context stability ensures that definitions in files using a context in this way won’t suddenly shadow a newly-provided name after an update.</p><p>In general, if you are the author of a context, you should carefully consider whether you want to add new names to an existing context, or create a new context with new names. The decision is mostly based on if active users are likely to have their own definitions of newly-provided names, because changing the context could cause a shadowing error in that case.</p><p>This means that sometimes programmers will want to manually update the year in a context, if it’s convenient for getting access to some new library function. Of course, they could always add the appropriate <tt class="pyretexpr">import</tt> statement to access it directly.</p></div></root>
    <hr/>
    The current page is lang/use.html.
    The previous page is <a href = "../lang/modules.html">../lang/modules.html</a>.
    The next page is <a href = "../lang/brands.html">../lang/brands.html</a>.
    </div>
  </body>
</html>