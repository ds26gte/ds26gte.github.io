<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="embed-api.js"></script>
  <link rel="stylesheet" href="styles.css">
  <head>
    <title>A Tour of Pyret</title>
  </head>
  <body>
    <div class="container">
    <root><h1 id="A-Tour-of-Pyret" toclevel="1" tocentry="yes">A Tour of Pyret</h1><p>You can start playing with Pyret right away at <url>https://code.pyret.org/editor</url>.  You can copy the examples below, run them, and play with them to get a feel for the language.</p><h2 id="Testing-and-Assertions" toclevel="2" tocentry="yes">Testing and Assertions</h2><p>The simplest way to add a test to a Pyret program is to use a <tt class="pyretexpr">check:</tt> block and a testing assertion.  Try running the following:</p><pre class="nothing_special">check:
  "Ahoy " + "world!" is "Ahoy world!"
end</pre><p>Upon running this program, Pyret reports:</p><pre class="nothing_special">Looks shipshape, your 1 test passed, mate!</pre><p>This program uses a <tt class="pyretexpr">check:</tt> block to register a set of tests to be run. The special <tt class="pyretexpr">is</tt> statement inside the check block compares the expressions on the left and right for equality.  It reports the result to the built-in testing framework, which produces a report when all the tests have been run.</p><p>If we break the test slightly, we can see that Pyret reports the error for us:</p><pre class="nothing_special">check:
  "Ahoy" + "world!" is "Ahoy world!"
end</pre><pre class="nothing_special">Check block: check-block-1
  test ("Ahoy" + "world!" is "Ahoy world!"): failed, reason:

Values not equal:
"Ahoyworld!"
"Ahoy world!"

  The test failed.</pre><p>The usual flow of writing a Pyret program involves writing tests along with your code, running your code to check the test output, and repeating until you’re satisfied with the functionality of your program.  The more tests you write, the more useful feedback you get.</p><p>The examples in this tour will all be presented in testing blocks (you’ll see one kind other than <tt class="pyretexpr">check:</tt> later).  Unless we’re explicitly pointing out a failure, you can assume that the tests all pass, and we’re showing correct behavior.</p><h2 id="Primitive-Values-and-Operators" toclevel="2" tocentry="yes">Primitive Values and Operators</h2><p>Primitives values are the basic building blocks of the language; structured data exists to organize computation over a small set of primitive values.  We describe Pyret’s primitives here.</p><h3 id="Numbers" toclevel="3" tocentry="yes">Numbers</h3><p>Numbers can be written with or without decimals.  For example:</p><pre class="nothing_special">check:
  5.0 is 5
end</pre><p>Pyret defines a number of binary operators over numbers (the full list is available in <a href="lang/forms.html#s:binop-expr">the documentation for binary
operators</a>):</p><pre class="nothing_special">check:
  4 + 5 is 9
  1 / 3 is 2 / 6
  9 - 3 is 6
  5 &gt; 4 is true
end</pre><p>Once we have binary operators, it is natural to ask what operator precedence Pyret has chosen.  In order to avoid ambiguity and confusing updates to precedence tables when new operators are added, chains of operators in Pyret simply disallows mixing operators without disambiguating parentheses.  For example:</p><pre class="nothing_special">check:
  5 - 4 + 1 is 2
end</pre><pre class="nothing_special">well-formedness: Cannot mix binary operators of different
types: `+` and `-`. Use parentheses to disambiguate.</pre><p>This holds not just for numeric operations, but for all binary operators in the language.  To give this program the meaning intended by the test, we should write:</p><pre class="nothing_special">check:
  (5 - 4) + 1 is 2
end</pre><p>You can see more utilities on numbers at <a href="builtin/numbers.html#numbers"></a>.</p><h2 id="Booleans" toclevel="2" tocentry="yes">Booleans</h2><p>Pyret has two distinguished boolean values, <tt class="pyretexpr">true</tt> and <tt class="pyretexpr">false</tt>.  Neither is a number or string or nullary or any other kind of value; both are booleans and they are the only two booleans.  The comparison operators on numbers evaluate to them, for instance:</p><pre class="nothing_special">check:
  3 &lt; 4 is true
  (2 + 2) == 5 is false
end</pre><h2 id="Strings" toclevel="2" tocentry="yes">Strings</h2><p>Strings can be written single- or double- quoted. Character escapes like <tt class="pyretexpr">\n</tt> work, and the enclosing quote character can be included if escaped like <tt class="pyretexpr">\”</tt>.</p><pre class="nothing_special">"hello world"

"\"yields falsehood when...\" yields falsehood when"

"an example\n\nwith explicit newline\ncharacters"</pre><p>Multi-line strings can be written with three backtick characters:</p><pre class="nothing_special">check:
  s = ```
    a
    multi
    line
    string
    ```
  s is "a\n    multi\n    line\n    string"
end</pre><h2 id="Lists" toclevel="2" tocentry="yes">Lists</h2><p>Lists aren’t primitive values, but they come up a lot in Pyret programs. Pyret’s list are of the head-and-tail variety found in many functional languages.  They are most easily written as a comma-separated list of values enclosed in square brackets and using the <tt class="pyretexpr">listlists</tt> constructor.  The elements of a list can be accessed through the dot lookup expression, via the members called `first` and `rest`:</p><pre class="nothing_special">check:
  [list: 1,2,3].first is 1
  [list: 1,2,3].rest  is [list: 2,3]
end</pre><p>It is an error to access a field that isn’t there; for example trying to access <tt class="pyretexpr">first</tt> on a list with no elements.  We can use the <tt class="pyretexpr">raisestesting</tt> test assertion to check the error that’s signalled:</p><pre class="nothing_special">check:
  [list:].first raises "first"
end</pre><p>The <tt class="pyretexpr">raisestesting</tt> form is useful for checking explicit error conditions.  It succeeds if the expression on the left signals an error with a message that contains the string on the right.</p><p>The <tt class="pyretexpr">[list:]</tt> notation is a convenience form for a more verbose form that creates the same lists.  The special <tt class="pyretexpr">emptylists</tt> value is equivalent to <tt class="pyretexpr">[list:]</tt>, and the <tt class="pyretexpr">linklists</tt> function attaches a value to the front of an existing list.  These constructors can be freely mixed with bracket notation:</p><pre class="nothing_special">check:
  empty is [list:]
  link(1, empty) is [list: 1]
  link(1, link(2, empty)) is [list: 1,2]
  link(empty, link(empty, [list: ])) is [list: [list:],[list:]]
end</pre><h2 id="Identifiers-and-Binding" toclevel="2" tocentry="yes">Identifiers and Binding</h2><h3 id="Identifiers" toclevel="3" tocentry="yes">Identifiers</h3><p>It’s often useful to name intermediate results of a computation.  Pyret uses <tt class="pyretexpr">=</tt> to bind identifiers to values:</p><pre class="nothing_special">check:
  list1 = [list: 2,3]
  list2 = link(1, list1)
  list2 is [list: 1,2,3]
end</pre><p>Identifiers bound with <tt class="pyretexpr">=</tt> are <i>not</i> variables.  They cannot be updated, and they cannot even be re-bound.  So, for example, using <tt class="pyretexpr">list1</tt> twice gives an error:</p><pre class="nothing_special">check:
  list1 = [list: 2,3]
  list1 = link(1, list1)
  list1 is [list: 1,2,3]
end</pre><pre class="nothing_special">It looks like you defined the name list1 twice, at</pre><p>Pyret takes a strong stance on the integrity of the <tt class="pyretexpr">=</tt> statement.  If the program says the name is equal to the value, then it had better continue to be! This has a very real correlation to something every high school algebra class teaches: the substitutability of names for expressions.  Defining names that, by default, can later be changed conflicts with basic notions of reasoning about expressions and programs.</p><h2 id="Variables" toclevel="2" tocentry="yes">Variables</h2><p>For names that can be updated, Pyret provides variables, which are distinct from identifiers at their declaration site, using <tt class="pyretexpr">var</tt>.  Such declarations must always give an initial value for the name, which can be later updated with <tt class="pyretexpr">:=</tt>:</p><pre class="nothing_special">check:
  var x = 10
  x is 10
  x := 15
  x is 15
end</pre><p>Mixing variables and identifiers of the same name is disallowed, and all of the following programs are errors:</p><pre class="nothing_special">x = 10
x := 15

var x = 10
x = 15

x = 10
var x = 15</pre><h2 id="functions-tour" toclevel="2" tocentry="yes">Functions</h2><p>In Pyret, most functions are defined with a function declaration. A function declaration looks like:</p><pre class="nothing_special">fun square(n):
  n * n
end</pre><p>This binds the name <tt class="pyretexpr">square</tt> to a function.  Note that Pyret has no explicit <tt class="pyretexpr">return</tt> keyword, and the function body “returns” whatever it evaluates to.  We can call <tt class="pyretexpr">square</tt> by passing arguments in parentheses:</p><pre class="nothing_special">check:
  square(4) is 16
  square(2) is 4
end</pre><p>Since there are often tests that go along with a function declaration, a declaration can directly attach a testing block using <tt class="pyretexpr">where:</tt>.  So we could write the above as:</p><pre class="nothing_special">fun square(n):
  n * n
where:
  square(4) is 16
  square(2) is 4
end</pre><p>This runs the same tests as the <tt class="pyretexpr">check:</tt> block, but it is now obvious to the reader (and to the programming environment!) that these tests go with the <tt class="pyretexpr">square</tt> function.</p><p>Functions are first-class values in Pyret, which means they can be passed as arguments to other functions or returned from them:</p><pre class="nothing_special">fun apply-twice(f, x):
  f(f(x))
where:
  apply-twice(square, 2) is 16
  apply-twice(square, 3) is 81
end</pre><p>Functions don’t need to have names.  An anonymous function can be written by using <tt class="pyretexpr">lam</tt> rather than <tt class="pyretexpr">fun</tt>:</p><pre class="nothing_special">check:
  apply-twice(lam(x): x + 1 end, 10) is 12
end</pre><h2 id="data-tour" toclevel="2" tocentry="yes">Data</h2><p>Pyret has a builtin form for declaring and manipulating structured data.</p><h3 id="definitions-tour" toclevel="3" tocentry="yes">Definitions</h3><p>One example that you’ve already seen is <tt class="pyretexpr">Listlists</tt>. A <tt class="pyretexpr">Listlists</tt> list is either <tt class="pyretexpr">empty</tt> or it is a <tt class="pyretexpr">link</tt> of an element and another list.  While very important to the code that we write, <tt class="pyretexpr">List</tt>s are not a special internal value, they are just defined with the <tt class="pyretexpr">data</tt> form. A simplified version of what appears in the standard library of Pyret:</p><pre class="nothing_special">data List:
  | empty
  | link(first, rest)
end</pre><p>Though this won’t actually run, because Pyret will complain that you’re trying to re-define <tt class="pyretexpr">List</tt>.  This is the general syntax of a <tt class="pyretexpr">data</tt> definition: the name of the datatype, then a list of one or more variants, which may have members (like <tt class="pyretexpr">link</tt> does), or may not. The values of the datatype are constructed by calling the constructor with initial members, if any were defined:</p><pre class="nothing_special">y = link(10, empty)</pre><p>Or by simply writing the name, if the variant doesn’t have members defined on it, in which case it is a singleton value.</p><pre class="nothing_special">x = empty</pre><p>This is the basic form. In addition to the functions to construct the values, you also get functions to check whether values are of the type. In this case, there are two functions: <tt class="pyretexpr">is-emptylists</tt> checks if a value is the <tt class="pyretexpr">empty</tt> value, and <tt class="pyretexpr">is-linklists</tt> checks if a value is a <tt class="pyretexpr">link</tt> value:</p><pre class="nothing_special">check:
  is-empty(empty) is true
  is-link(link(1, empty)) is true
end</pre><p><bold>An aside on testing:</bold> There’s actually a more natural way to write the above test.  Along with <tt class="pyretexpr">istesting</tt> and <tt class="pyretexpr">raisestesting</tt>, Pyret defines a test assertion called <tt class="pyretexpr">satisfiestesting</tt> that checks if a predicate returns <tt class="pyretexpr">true</tt> on a test value.  We could instead write the above as:</p><pre class="nothing_special">check:
  empty satisfies is-empty
  link(1, empty) satisfies is-link
end</pre><p>The <tt class="pyretexpr">satisfies</tt> form is quite handy for testing properties of a value, rather than just that a value is equal to another.  The second form also gives better error reporting than the first (what happens if you swap <tt class="pyretexpr">is-link</tt> and <tt class="pyretexpr">is-empty</tt> in either approach?).</p><p><span class="margin-note">Check out <a href="lang/testing.html#testing">the documentation on testing</a> to see all the testing forms.</span></p><h2 id="cases-tour" toclevel="2" tocentry="yes">Cases</h2><p>A common pattern is to do different things based on the variant of a <tt class="pyretexpr">data</tt> definition.  The <tt class="pyretexpr">cases</tt> expression allows you to write branches that split computation along the boundaries defined by your data definition.  For example:</p><pre class="nothing_special">fun length(l):
  cases(List) l:
    | empty =&gt; 0
    | link(f, r) =&gt; 1 + length(r)
  end
end</pre><p>If you don’t care about a specific attribute, you can replace it with an underscore. Since we did not use <tt class="pyretexpr">f</tt> in the <tt class="pyretexpr">link</tt> case in the previous example, we could write it instead as:</p><pre class="nothing_special">fun length(l):
  cases(List) l:
    | empty =&gt; 0
    | link(_, r) =&gt; 1 + length(r)
  end
end</pre><p>This makes it clearer to the reader, especially if the blocks become large, what the program does and does not use.</p><p>Finally, it is an error, caught at runtime, to pass a value that isn’t of the type inside the <tt class="pyretexpr">cases</tt>, or if a branch isn’t defined for the variant that’s passed to <tt class="pyretexpr">cases</tt>. If you want to have a catch-all, you can use <tt class="pyretexpr">else</tt> to create a branch that will run if no others match. For example:</p><pre class="nothing_special">check:
  result =  cases(List) empty:
    | link(first, _) =&gt; first
    | else =&gt; 0
  end
  result is 0
end</pre><h2 id="annotations-tour" toclevel="2" tocentry="yes">Annotations</h2><p>Pyret is not currently a typed language (a static checker is an ongoing project), but it allows type-like annotations, both to document the type structure of programs, and for some run-time checking.  Annotations can be added to function arguments, to variable bindings, and to the members in data variants.  For example:</p><pre class="nothing_special">data BinTree:
  | leaf
  | node(value :: Number, left :: BinTree, right :: BinTree)
end</pre><p>Note that <tt class="pyretexpr">BinTree</tt>, the name of a datatype, can be used as an annotation.  Any data type that you define can also be used in an annotation. These annotations will stop the program from creating a <tt class="pyretexpr">BinTree</tt> with fields that don’t match the annotations:</p><pre class="nothing_special">check:
  node("not-a-num", leaf, leaf) raises "Number"
  node(37, leaf, "not-a-bin-tree") raises "BinTree"
end</pre><p>You can also define arbitrary predicates for use in annotations to <i>refine</i> the annotation with additional checks. For example:</p><pre class="nothing_special">fun non-negative(n :: Number) -&gt; Boolean:
  n &gt;= 0
end

fun replicate(n :: Number%(non-negative), e) -&gt; List:
  if n == 0:
    [list:]
  else:
    link(e, replicate(n - 1, e))
  end
end</pre><p>And if you were to call <tt class="pyretexpr">replicate</tt> with a negative number, it would not run (instead of running forever):</p><pre class="nothing_special">check:
  replicate(-1, "val") raises "non-negative"
end</pre><p>Some kinds of annotations only get limited checks:</p><p><itemlist><item>Arrow annotations, like <tt class="pyretexpr">(Number, String -&gt; String)</tt> will only check that the value is a function, and not wrap the function to check its arguments.</item><item>Parameterized annotations, like <tt class="pyretexpr">List&lt;Number&gt;</tt>, will only check the annotation before the <tt class="pyretexpr">&lt;&gt;</tt>, the contents the <tt class="pyretexpr">&lt;&gt;</tt> will be ignored.</item><item>Type variables, like the <tt class="pyretexpr">a</tt> in <tt class="pyretexpr">lam &lt;a&gt; (x :: a) -&gt; a: x end</tt>, accept values of any type</item></itemlist></p><p>These are features that we plan to check statically rather than at runtime.</p><h2 id="Control" toclevel="2" tocentry="yes">Control</h2><h3 id="For-loops" toclevel="3" tocentry="yes">For loops</h3><p>Pyret provides syntactic support for common patterns of iteration. For example, to <tt class="pyretexpr">maplists</tt> over a list, running some block of code to produce a new value for each existing value, we can write:</p><pre class="nothing_special">x = for map(elem from [list: 1,2,3,4]):
  elem + 2
end
check:
  x is [list: 3,4,5,6]
end</pre><p>Note a few things:</p><p><itemlist><item><tt class="pyretexpr">for</tt> is an expression, and is legal to write on the right hand side of a binding</item><item>The whole <tt class="pyretexpr">for</tt> expression evaluates to a value (in this case, a new list)</item></itemlist></p><p>The <tt class="pyretexpr">for</tt> syntax is designed to create patterns for functional iteration. Indeed, there are several other built in functions that work with <tt class="pyretexpr">for</tt>:</p><pre class="nothing_special">z = for filter(elem from [list: 1,2,3,4]):
  elem &lt; 3
end
check:
  z is [list: 1,2]
end

y = for fold(sum from 0, elem from [list: 1,2,3]):
  sum + elem
end
check:
  y is 6
end</pre><p>And you are free to define your own <tt class="pyretexpr">for</tt> operators.  A <tt class="pyretexpr">for</tt> operator is a function that takes a function as its first argument, and a number of other values as the rest of its arguments.  The function argument is expected to have the same arity as the number of initial values.  To use the operator in a <tt class="pyretexpr">for</tt> expression, the <tt class="pyretexpr">for</tt> header should have a number of <tt class="pyretexpr">from</tt> bindings equal to this arity.  For example:</p><pre class="nothing_special">fun keep-every-other(body-fun, l):
  fun iter(flip, lst):
    cases(List) lst:
      | empty =&gt; empty
      | link(first, rst) =&gt;
        if flip:
          link(body-fun(first), iter(not(flip), rst))
        else:
          iter(not(flip), rst)
        end
    end
  end
  iter(true, l)
end
w = for keep-every-other(elt from range(0,10)):
  elt + 1
end
check:
  w is [list: 1, 3, 5, 7, 9]
end</pre><p>What the <tt class="pyretexpr">for</tt> expression does is create a new function from the names on the left-hand sides of the <tt class="pyretexpr">from</tt> clauses and the body, and pass that new function along with the values on the right of <tt class="pyretexpr">from</tt> to the operator (<tt class="pyretexpr">keep-every-other</tt>, in this case).</p><h2 id="If" toclevel="2" tocentry="yes">If</h2><p>Branching on conditionals is an <tt class="pyretexpr">if</tt> branch followed by zero or more <tt class="pyretexpr">else if</tt> branches and an optional <tt class="pyretexpr">else</tt> branch. It is a runtime error to not match one of the branches - if you are writing code to purely cause side effects, write a <tt class="pyretexpr">when</tt> block instead. A few examples:</p><pre class="nothing_special">if x &lt; 10:
  print("Small")
else if x &gt; 20:
  print("Large")
else:
  print("Medium")
end</pre><pre class="nothing_special">if false:
  print("Can't happen")
else if false:
  print("Can't happen either")
  # this is a runtime error, Pyret requires an else branch
end</pre><pre class="nothing_special">if true and false:
  #...
else:
  #...
end</pre><p>Pyret expects that <tt class="pyretexpr">if</tt> expressions take some branch, and signals an error if control falls off the end:</p><pre class="nothing_special">check:
  fun if-falls-off():
    if false:
      ""
    else if false:
      ""
    end
  end
  if-falls-off() raises "no-branches-matched"
end</pre><p>For this reason, Pyret syntactically rules out single-branch if expressions, which make little sense given this rule.</p><h3 id="When-blocks" toclevel="3" tocentry="yes">When blocks</h3><p>Sometimes there is certain code that should only be run when something is true. This is code that exists solely to <i>do</i> something; often, for example, to report an error. For example:</p><pre class="nothing_special">fun get-second&lt;a&gt;(l :: List&lt;a&gt;) -&gt; a block:
  when l.length() &lt; 2:
    raise("List too short")
  end
  l.rest.first
where:
  get-second([list: 1]) raises "too short"
  get-second([list: 1, 2, 3]) is 2
end</pre><p>This covers the cases that single-branch if expressions are usually used for, but makes it explicit that the body is used for its side effects.</p><h2 id="And-more..." toclevel="2" tocentry="yes">And more...</h2><p>This introduction should get you to the point where you can write non-trivial Pyret programs.  From here, you can check out the rest of the documentation to learn more about the language and for reference.  If your interest is piqued by the tour, or if you have suggestions or questions, you should sign up for the <a href="https://groups.google.com/forum/#!forum/pyret-discuss">Pyret discussion
list</a>.</p></root>
    <hr/>
    The current page is tour.html.
    The previous page is <a href = "platforms/platforms.html">platforms/platforms.html</a>.
    The next page is <a href = "language-concepts.html">language-concepts.html</a>.
    </div>
  </body>
</html>