<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>lists</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="lists" toclevel="1" tocentry="yes"></h1><div><p>Usage:</p><p><tt>include lists</tt></p><p><tt>import lists as ...</tt></p></div><p>  </p><p>  </p><h2 id="The-List-Datatype" toclevel="2" tocentry="yes">The List Datatype</h2><p>  </p><pre class="pyret-display"><span><a name="List"></a></span><span>data <a href="../trove/lists.html#List">List</a>&lt;a&gt;</span>
<div><tt>   | <span>empty</span></tt>
<tt>   | <span><a href="../trove/lists.html#link">link</a>(<span>first :: a</span>, <span>rest :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>)</span></tt></div><tt>end</tt></pre><p>  </p><div class="insetpara nested"><div><p><span><a name="empty"></a></span></p><pre class="pyret-display">empty :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></pre></div><p>  </p><div><p><span><a name="link"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#link">link</a> :: (<span>first :: a</span>, <span>rest :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></pre><p></p></div><p>  </p><div><p><span><a name="is-empty"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#is-empty">is-empty</a> :: <span>(<span><span class="pyret-content">val :: Any</span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>  </p><div><p><span><a name="is-link"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#is-link">is-link</a> :: <span>(<span><span class="pyret-content">val :: Any</span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>A <tt class="pyretexpr">List</tt> is an immutable, fixed-length collection indexed by non-negative integers.</p><p>As in most programming languages, you can use <tt class="pyretexpr">List</tt>s in Pyret without understanding much, if anything, about how they are implemented internally in the language.</p><p>However, in functional languages such as Pyret a particular implementation of lists—the linked list—has a central role for both historical and practical reasons, and a fuller understanding of linked lists goes hand in hand with a fuller understanding of Pyret.  If you have not encountered linked lists before and would like to know more, we recommend reading <a href="http://dcic-world.org/">the material on
lists in DCIC</a>.</p><p>In lieu of a full explanation on this page, here are a few quick points to help parse some of the following examples:</p><ul><li>A <tt class="pyretexpr">List</tt> is made up of elements, usually referred to as <tt class="pyretexpr">elt</tt>s in examples.</li><li>Elements are of two types: <tt class="pyretexpr">link</tt> and <tt class="pyretexpr">empty</tt>.</li><li>Every <tt class="pyretexpr">link</tt> actually has two parts: a <b>first</b> value and the <b>rest</b> of the <tt class="pyretexpr">List</tt>.</li><li>The rest of the <tt class="pyretexpr">List</tt> is itself a <tt class="pyretexpr">link</tt>, or if you have reached the end of the <tt class="pyretexpr">List</tt>, the rest will be <tt class="pyretexpr">empty</tt>.</li></ul><p>and here are some illustrative examples:</p><div><p><b>Examples:</b></p><pre>check:
  l0 = empty
  l1 = link(1, l0)
  l2 = link(2, l1)
  is-empty(l0) is true
  is-link(l0) is false

  is-empty(l1) is false
  is-link(l1) is true

  is-empty(l2) is false
  is-link(l2) is true
end</pre><p><a class="show-embed" code="check: 
    l0 = empty 
    l1 = link(1, l0) 
    l2 = link(2, l1) 
    is-empty(l0) is true 
    is-link(l0) is false 

    is-empty(l1) is false 
    is-link(l1) is true 

    is-empty(l2) is false 
    is-link(l2) is true 
 end">(Try it!)</a></p></div></div><h2 id="List-Creation-Functions" toclevel="2" tocentry="yes">List Creation Functions</h2><div><p><span><a name="list"></a></span></p><pre class="pyret-display">[<a href="../trove/lists.html#list">list</a><span></span>: <span class="pyret-content">elt :: a</span>, ...] -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></pre></div><div class="margin-note">This illustrates the underlying structure created when you define a <tt class="pyretexpr">List</tt> with <tt class="pyretexpr">[list: ...]</tt></div><p>Constructs a <tt class="pyretexpr">List</tt> out of <tt class="pyretexpr">elt</tt>s by chaining <a href="../trove/lists.html#link"><tt class="pyretexpr">link</tt></a>s, ending in a single <a href="../trove/lists.html#empty"><tt class="pyretexpr">empty</tt></a>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: ] is L.empty
  [L.list: 1] is L.link(1, L.empty)
  [L.list: 1, 2] is L.link(1, link(2, L.empty))
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: ] is L.empty 
    [L.list: 1] is L.link(1, L.empty) 
    [L.list: 1, 2] is L.link(1, link(2, L.empty)) 
 end">(Try it!)</a></p></div><p>Though it is neither required nor enforced by the language, conventionally, when writing the empty list using the constructor notation, we write an extra spce between the <tt class="pyretexpr">:</tt> and <tt class="pyretexpr">]</tt>.</p><p><b>Note</b>: You should <i>not</i> write a trailing <a href="../trove/lists.html#empty"><tt class="pyretexpr">empty</tt></a> when using this constructor notation. Everything you write is an <i>element</i> of the list. Thus,</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: ] is-not [L.list: L.empty]
  L.link(L.empty, L.empty) is [L.list: L.empty]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: ] is-not [L.list: L.empty] 
    L.link(L.empty, L.empty) is [L.list: L.empty] 
 end">(Try it!)</a></p></div><div><p><span><a name="build-list"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#build-list">build-list</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span><a href="../trove/globals.html#Number">Number</a></span>) -&gt; a</span></span>, <span class="pyret-content">size :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Constructs a list of length <tt class="pyretexpr">size</tt>, and fills it with the result of calling the function <tt class="pyretexpr">f</tt> with each index from <tt class="pyretexpr">0</tt> to <tt class="pyretexpr">size - 1</tt>.</p><p>Similar to <a href="../trove/arrays.html#build-array"><tt class="pyretexpr">build-array</tt></a>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun sq(x): x * x end
  L.build-list(sq, 4)
    is [L.list: 0, 1, 4, 9]
    because [L.list: sq(0), sq(1), sq(2), sq(3)]
end

check:
  fun build-from(base :: Number) -&gt; List&lt;String&gt;:
    L.build-list({(n): base + n}, 3)
  end

  a = L.build-list(build-from, 3)

  a is [L.list:
    [L.list: 0, 1, 2],
    [L.list: 1, 2, 3],
    [L.list: 2, 3, 4]]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun sq(x): x * x end 
    L.build-list(sq, 4) 
      is [L.list: 0, 1, 4, 9] 
      because [L.list: sq(0), sq(1), sq(2), sq(3)] 
 end 

 check: 
    fun build-from(base :: Number) -&gt; List&lt;String&gt;: 
      L.build-list({(n): base + n}, 3) 
    end 

    a = L.build-list(build-from, 3) 

    a is [L.list: 
      [L.list: 0, 1, 2], 
      [L.list: 1, 2, 3], 
      [L.list: 2, 3, 4]] 
 end">(Try it!)</a></p></div><h2 id="List-Methods" toclevel="2" tocentry="yes">List Methods</h2><p>These methods are available on all <tt class="pyretexpr">List</tt>s whether empty or a link.</p><div><p><span><a name=".length"></a></span></p><pre class="pyret-display">.length :: <span>(<span></span>) -&gt; <a href="../trove/globals.html#Number">Number</a></span></pre></div><p>Returns the number of elements in the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 'a', 'b'].length() is 2
  L.empty.length() is 0
  L.link("a", L.empty).length() is 1
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 'a', 'b'].length() is 2 
    L.empty.length() is 0 
    L.link(&quot;a&quot;, L.empty).length() is 1 
 end">(Try it!)</a></p></div><div><p><span><a name=".map"></a></span></p><pre class="pyret-display">.map :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; b</span>)</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></pre></div><p>Applies function <tt class="pyretexpr">f</tt> to each element of the list from left to right, and constructs a new <tt class="pyretexpr">List</tt> out of the return values in the corresponding order.</p><p><tt class="pyretexpr">a</tt> represents the type of the elements in the original <tt class="pyretexpr">List</tt>, <tt class="pyretexpr">b</tt> is the type of the elements in the new <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2].map(num-tostring) is [L.list: "1", "2"]
  [L.list: 1, 2].map(lam(n): n + 1 end) is [L.list: 2, 3]
  [L.list: 1, 2].map(_ + 1) is [L.list: 2, 3]
  L.empty.map(lam(x): raise("This never happens!") end) is L.empty
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2].map(num-tostring) is [L.list: &quot;1&quot;, &quot;2&quot;] 
    [L.list: 1, 2].map(lam(n): n + 1 end) is [L.list: 2, 3] 
    [L.list: 1, 2].map(_ + 1) is [L.list: 2, 3] 
    L.empty.map(lam(x): raise(&quot;This never happens!&quot;) end) is L.empty 
 end">(Try it!)</a></p></div><div><p><span><a name=".each"></a></span></p><pre class="pyret-display">.each :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><p>Applies <tt class="pyretexpr">f</tt> to each element of the <tt class="pyretexpr">List</tt> from left to right, and returns <tt class="pyretexpr">nothing</tt>.  Because it returns <tt class="pyretexpr">nothing</tt>, use <a href="../trove/lists.html#each"><tt class="pyretexpr">each</tt></a> instead of <a href="../trove/lists.html#map"><tt class="pyretexpr">map</tt></a> when the function <tt class="pyretexpr">f</tt> is needed only for its side-effects.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var x = 1
  [L.list: 1, 2].each(lam(n): x := x + n end) is nothing
  x is 4
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var x = 1 
    [L.list: 1, 2].each(lam(n): x := x + n end) is nothing 
    x is 4 
 end">(Try it!)</a></p></div><div><p><span><a name=".filter"></a></span></p><pre class="pyret-display">.filter :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>)</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Applies function <tt class="pyretexpr">f</tt> to each element of <tt class="pyretexpr">List</tt> from left to right, constructing a new <tt class="pyretexpr">List</tt> out of the elements for which <tt class="pyretexpr">f</tt> returned <tt class="pyretexpr">true</tt>.</p><p>The original <tt class="pyretexpr">List</tt> elements are of type <tt class="pyretexpr">a</tt> and the function <tt class="pyretexpr">f</tt> must return a <tt class="pyretexpr">Boolean</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-is-one(s :: String) -&gt; Boolean:
    string-length(s) == 1
  end
  [L.list: "ab", "a", "", "c"].filter(length-is-one) is [L.list: "a", "c"]
  [L.list: L.empty, L.link(1, L.empty), L.empty].filter(L.is-link)
    is [L.list: L.link(1, L.empty)]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun length-is-one(s :: String) -&gt; Boolean: 
      string-length(s) == 1 
    end 
    [L.list: &quot;ab&quot;, &quot;a&quot;, &quot;&quot;, &quot;c&quot;].filter(length-is-one) is [L.list: &quot;a&quot;, &quot;c&quot;] 
    [L.list: L.empty, L.link(1, L.empty), L.empty].filter(L.is-link) 
      is [L.list: L.link(1, L.empty)] 
 end">(Try it!)</a></p></div><div><p><span><a name=".push"></a></span></p><pre class="pyret-display">.push :: <span>(<span><span class="pyret-content">elt :: a</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Returns <tt class="pyretexpr">link(elt, self)</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.empty.push("a") is L.link("a", L.empty)
  L.link("a", L.empty).push("b") is L.link("b", L.link("a", L.empty))
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.empty.push(&quot;a&quot;) is L.link(&quot;a&quot;, L.empty) 
    L.link(&quot;a&quot;, L.empty).push(&quot;b&quot;) is L.link(&quot;b&quot;, L.link(&quot;a&quot;, L.empty)) 
 end">(Try it!)</a></p></div><p>In other words, returns a <tt class="pyretexpr">List</tt> with <tt class="pyretexpr">elt</tt> appended to the beginning of the original <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 'a', 'b'].push('c') is [L.list: 'c', 'a', 'b']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 'a', 'b'].push('c') is [L.list: 'c', 'a', 'b'] 
 end">(Try it!)</a></p></div><div><p><span><a name=".split-at"></a></span></p><pre class="pyret-display">.split-at :: <span>(<span><span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; <span>{<span class="pyret-content">prefix :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">suffix :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>}</span></span></pre></div><p>Produces a record containing two <tt class="pyretexpr">List</tt>s, consisting of the items before and the items at-or-after the splitting index of the current <tt class="pyretexpr">List</tt>.  The index is 0-based, so splitting a <tt class="pyretexpr">List</tt> at index <math>n</math> will produce a prefix of length exactly <math>n</math>.  Moreover, <a href="../trove/lists.html#append"><tt class="pyretexpr">append</tt></a>ing the two <tt class="pyretexpr">List</tt>s together will be equivalent to the original <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 'a', 'b', 'c', 'd'].split-at(2)
    is {prefix: [L.list: "a", "b"], suffix: [L.list: "c", "d"]}
  one-four = L.link(1, L.link(2, L.link(3, L.link(4, L.empty))))
  one-four.split-at(0) is {prefix: L.empty, suffix: one-four}
  one-four.split-at(4) is {prefix: one-four, suffix: L.empty}
  one-four.split-at(2) is
  {prefix: [L.list: 1, 2], suffix: [L.list: 3, 4]}
  one-four.split-at(-1) raises "Invalid index"
  one-four.split-at(5) raises "Index too large"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 'a', 'b', 'c', 'd'].split-at(2) 
      is {prefix: [L.list: &quot;a&quot;, &quot;b&quot;], suffix: [L.list: &quot;c&quot;, &quot;d&quot;]} 
    one-four = L.link(1, L.link(2, L.link(3, L.link(4, L.empty)))) 
    one-four.split-at(0) is {prefix: L.empty, suffix: one-four} 
    one-four.split-at(4) is {prefix: one-four, suffix: L.empty} 
    one-four.split-at(2) is 
    {prefix: [L.list: 1, 2], suffix: [L.list: 3, 4]} 
    one-four.split-at(-1) raises &quot;Invalid index&quot; 
    one-four.split-at(5) raises &quot;Index too large&quot; 
 end">(Try it!)</a></p></div><div><p><span><a name=".take"></a></span></p><pre class="pyret-display">.take :: <span>(<span><span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Given a length <tt class="pyretexpr">n</tt>, returns a new <tt class="pyretexpr">List</tt> containing the first <tt class="pyretexpr">n</tt> items of the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3, 4, 5, 6].take(3) is [L.list: 1, 2, 3]
  [L.list: 1, 2, 3].take(6) raises "Index too large"
  [L.list: 1, 2, 3].take(-1) raises "Invalid index"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3, 4, 5, 6].take(3) is [L.list: 1, 2, 3] 
    [L.list: 1, 2, 3].take(6) raises &quot;Index too large&quot; 
    [L.list: 1, 2, 3].take(-1) raises &quot;Invalid index&quot; 
 end">(Try it!)</a></p></div><div><p><span><a name=".drop"></a></span></p><pre class="pyret-display">.drop :: <span>(<span><span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>] Given a length <tt class="pyretexpr">n</tt>, returns a <tt class="pyretexpr">List</tt> containing all but the first <tt class="pyretexpr">n</tt> items of the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3, 4, 5, 6].drop(3) is [L.list: 4, 5, 6]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3, 4, 5, 6].drop(3) is [L.list: 4, 5, 6] 
 end">(Try it!)</a></p></div><div><p><span><a name=".get"></a></span></p><pre class="pyret-display">.get :: <span>(<span><span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; a</span></pre></div><p>Returns the <tt class="pyretexpr">n</tt>th element of the given <tt class="pyretexpr">List</tt>.</p><p>Using an index too large, negative, or not a whole number raises an error.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3]

  l.get(0) is 1
  l.get(4) raises "too large"
  l.get(-1) raises "invalid argument"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3] 

    l.get(0) is 1 
    l.get(4) raises &quot;too large&quot; 
    l.get(-1) raises &quot;invalid argument&quot; 
 end">(Try it!)</a></p></div><div><p><span><a name=".set"></a></span></p><pre class="pyret-display">.set :: <span>(<span><span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">e :: a</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Returns a new <tt class="pyretexpr">List</tt> with the same values as the given <tt class="pyretexpr">List</tt> but with the <tt class="pyretexpr">n</tt>th element set to the given value, or raises an error if <tt class="pyretexpr">n</tt> is out of range.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].set(0, 5) is [L.list: 5, 2, 3]
  [L.list: ].set(0, 5) raises "too large"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].set(0, 5) is [L.list: 5, 2, 3] 
    [L.list: ].set(0, 5) raises &quot;too large&quot; 
 end">(Try it!)</a></p></div><div><p><span><a name=".foldl"></a></span></p><pre class="pyret-display">.foldl :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, Base</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span></span>) -&gt; Base</span></pre></div><p>Computes <tt class="pyretexpr">f(last-elt, ... f(second-elt, f(first-elt, base))...)</tt>.  For <a href="../trove/lists.html#empty"><tt class="pyretexpr">empty</tt></a>, returns <tt class="pyretexpr">base</tt>.</p><p>In other words, <tt class="pyretexpr">.foldl</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the <i>left</i> (hence, fold<b>l</b>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 3, 2, 1].foldl(lam(elt, acc): elt + acc end, 10) is 16
  fun combine(elt, acc) -&gt; String:
    tostring(elt) + " - " + acc
  end
  [L.list: 3, 2, 1].foldl(combine, "END") is "1 - 2 - 3 - END"
  L.empty.foldl(combine, "END") is "END"
  [L.list: 3, 2, 1].foldl(L.link, L.empty) is [L.list: 1, 2, 3]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 3, 2, 1].foldl(lam(elt, acc): elt + acc end, 10) is 16 
    fun combine(elt, acc) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    [L.list: 3, 2, 1].foldl(combine, &quot;END&quot;) is &quot;1 - 2 - 3 - END&quot; 
    L.empty.foldl(combine, &quot;END&quot;) is &quot;END&quot; 
    [L.list: 3, 2, 1].foldl(L.link, L.empty) is [L.list: 1, 2, 3] 
 end">(Try it!)</a></p></div><div><p><span><a name=".foldr"></a></span></p><pre class="pyret-display">.foldr :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, Base</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span></span>) -&gt; Base</span></pre></div><p>Computes <tt class="pyretexpr">f(first-elt, f(second-elt, ... f(last-elt, base)))</tt>.  For <a href="../trove/lists.html#empty"><tt class="pyretexpr">empty</tt></a>, returns <tt class="pyretexpr">base</tt>.</p><p>In other words, <tt class="pyretexpr">.foldr</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the <i>right</i> (hence, fold<b>r</b>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 3, 2, 1].foldr(lam(elt, acc): elt + acc end, 10) is 16
  fun combine(elt, acc) -&gt; String:
    tostring(elt) + " - " + acc
  end
  [L.list: 3, 2, 1].foldr(combine, "END") is "3 - 2 - 1 - END"
  empty.foldr(combine, "END") is "END"
  [L.list: 3, 2, 1].foldr(L.link, L.empty) is [L.list: 3, 2, 1]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 3, 2, 1].foldr(lam(elt, acc): elt + acc end, 10) is 16 
    fun combine(elt, acc) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    [L.list: 3, 2, 1].foldr(combine, &quot;END&quot;) is &quot;3 - 2 - 1 - END&quot; 
    empty.foldr(combine, &quot;END&quot;) is &quot;END&quot; 
    [L.list: 3, 2, 1].foldr(L.link, L.empty) is [L.list: 3, 2, 1] 
 end">(Try it!)</a></p></div><div><p><span><a name=".member"></a></span></p><pre class="pyret-display">.member :: <span>(<span><span class="pyret-content">elt :: a</span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div class="margin-note">Passing a <tt class="pyretexpr">Roughnum</tt> as an argument will raise an error.</div><p>Returns true if the current <tt class="pyretexpr">List</tt> contains the given value, as compared by <tt class="pyretexpr">==</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].member(2) is true
  [L.list: 2, 4, 6].member(3) is false
  [L.list: ].member(L.empty) is false
  [L.list: 1, 2, 3].member(~1) raises "Roughnums"
  [L.list: ~1, 2, 3].member(1) raises "Roughnums"
  [L.list: 1, 2, 3].member(4) is false
  [L.list: 1, 2, 3].member(~4) raises "Roughnums"

  [L.list: 'a'].member('a') is true
  [L.list: false].member(false) is true
  [L.list: nothing].member(nothing) is true
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].member(2) is true 
    [L.list: 2, 4, 6].member(3) is false 
    [L.list: ].member(L.empty) is false 
    [L.list: 1, 2, 3].member(~1) raises &quot;Roughnums&quot; 
    [L.list: ~1, 2, 3].member(1) raises &quot;Roughnums&quot; 
    [L.list: 1, 2, 3].member(4) is false 
    [L.list: 1, 2, 3].member(~4) raises &quot;Roughnums&quot; 

    [L.list: 'a'].member('a') is true 
    [L.list: false].member(false) is true 
    [L.list: nothing].member(nothing) is true 
 end">(Try it!)</a></p></div><div><p><span><a name=".append"></a></span></p><pre class="pyret-display">.append :: <span>(<span><span class="pyret-content">other :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Produces a new <tt class="pyretexpr">List</tt> with all the elements of the current <tt class="pyretexpr">List</tt>, followed by all the elements of the <tt class="pyretexpr">other</tt> <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2].append([list: 3, 4]) is [L.list: 1, 2, 3, 4]
  L.empty.append([L.list: 1, 2]) is [L.list: 1, 2]
  [L.list: 1, 2].append(empty) is [L.list: 1, 2]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2].append([list: 3, 4]) is [L.list: 1, 2, 3, 4] 
    L.empty.append([L.list: 1, 2]) is [L.list: 1, 2] 
    [L.list: 1, 2].append(empty) is [L.list: 1, 2] 
 end">(Try it!)</a></p></div><div><p><span><a name=".last"></a></span></p><pre class="pyret-display">.last :: <span>(<span></span>) -&gt; a</span></pre></div><p>Returns the last item of the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].last() is 3
  L.empty.last() raises "last of empty list"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].last() is 3 
    L.empty.last() raises &quot;last of empty list&quot; 
 end">(Try it!)</a></p></div><div><p><span><a name=".reverse"></a></span></p><pre class="pyret-display">.reverse :: <span>(<span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Produces a new <tt class="pyretexpr">List</tt> with the items of the original <tt class="pyretexpr">List</tt> in reversed order.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].reverse() is [L.list: 3, 2, 1]
  L.empty.reverse() is L.empty
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].reverse() is [L.list: 3, 2, 1] 
    L.empty.reverse() is L.empty 
 end">(Try it!)</a></p></div><div><p><span><a name=".sort"></a></span></p><pre class="pyret-display">.sort :: <span>(<span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Produces a new <tt class="pyretexpr">List</tt> whose contents are the same as those of the current <tt class="pyretexpr">List</tt>, sorted by <a href="../lang/equality.html#&lt;"><tt class="pyretexpr">&lt;</tt></a> and <a href="../lang/equality.html#=="><tt class="pyretexpr">==</tt></a>.  This requires that the items of the <tt class="pyretexpr">List</tt> be comparable by <a href="../lang/equality.html#&lt;"><tt class="pyretexpr">&lt;</tt></a> (see <a href="lang/forms.html#s:binop-expr">Binary Operators</a>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 5, 3, 2, 4].sort() is [L.list: 1, 2, 3, 4, 5]
  [L.list: "aaaa", "B", "a"].sort() is [L.list: "B", "a", "aaaa"]
  [L.list: 'a', 1].sort() raises "binop-error"
  [L.list: true, false].sort() raises "binop-error"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 5, 3, 2, 4].sort() is [L.list: 1, 2, 3, 4, 5] 
    [L.list: &quot;aaaa&quot;, &quot;B&quot;, &quot;a&quot;].sort() is [L.list: &quot;B&quot;, &quot;a&quot;, &quot;aaaa&quot;] 
    [L.list: 'a', 1].sort() raises &quot;binop-error&quot; 
    [L.list: true, false].sort() raises &quot;binop-error&quot; 
 end">(Try it!)</a></p></div><div><p><span><a name=".sort-by"></a></span></p><pre class="pyret-display">.sort-by :: <span>(<span><span class="pyret-content">cmp :: <span>(<span>a, a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></span>, <span class="pyret-content">eq :: <span>(<span>a, a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Like <a href="../trove/lists.html#sort"><tt class="pyretexpr">sort</tt></a>, but the comparison and equality operators can be specified.  This allows for sorting <tt class="pyretexpr">List</tt>s whose contents are not comparable by <tt class="pyretexpr">&lt;</tt>, or sorting by custom comparisons, for example, sorting by string length instead of alphabetically.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) &gt; string-length(s2)
  end
  fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) == string-length(s2)
  end
  [L.list: 'a', 'aa', 'aaa'].sort-by(length-comparison, length-equality) is
    [L.list: 'aaa', 'aa', 'a']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) &gt; string-length(s2) 
    end 
    fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) == string-length(s2) 
    end 
    [L.list: 'a', 'aa', 'aaa'].sort-by(length-comparison, length-equality) is 
      [L.list: 'aaa', 'aa', 'a'] 
 end">(Try it!)</a></p></div><div><p><span><a name=".join-str"></a></span></p><pre class="pyret-display">.join-str :: <span>(<span><span class="pyret-content">sep :: <a href="../trove/globals.html#String">String</a></span></span>) -&gt; <a href="../trove/globals.html#String">String</a></span></pre></div><p>Combines the values of the current <tt class="pyretexpr">List</tt> by converting them to strings with <tt class="pyretexpr">tostring</tt> and joining them with the given separator <tt class="pyretexpr">sep</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].join-str("; ") is "1; 2; 3"
  [L.list: "a", true, ~5.3].join-str(" : ") is "a : true : ~5.3"
  L.empty.join-str("nothing at all") is ""
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].join-str(&quot;; &quot;) is &quot;1; 2; 3&quot; 
    [L.list: &quot;a&quot;, true, ~5.3].join-str(&quot; : &quot;) is &quot;a : true : ~5.3&quot; 
    L.empty.join-str(&quot;nothing at all&quot;) is &quot;&quot; 
 end">(Try it!)</a></p></div><div><p><span><a name=".join-str-last"></a></span></p><pre class="pyret-display">.join-str-last :: <span>(<span><span class="pyret-content">sep :: <a href="../trove/globals.html#String">String</a></span>, <span class="pyret-content">last-sep :: <a href="../trove/globals.html#String">String</a></span></span>) -&gt; <a href="../trove/globals.html#String">String</a></span></pre></div><p>Combines the values of the current <tt class="pyretexpr">List</tt> by converting them to strings with <tt class="pyretexpr">tostring</tt> and joining them with the given separator <tt class="pyretexpr">sep</tt>. If the list has more than one element, the function will use <tt class="pyretexpr">last-sep</tt> to join the last element instead of the regular <tt class="pyretexpr">sep</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].join-str-last(", ", " and ") is "1, 2 and 3"
  [L.list: "a", true, ~5.3].join-str-last(" : ", " # ") is "a : true # ~5.3"
  L.empty.join-str-last("nothing at all", "really nothing") is ""
  [L.list: 1, 2].join-str-last("a", "b") is "1b2"
  [L.list: 1].join-str-last("a", "b") is "1"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].join-str-last(&quot;, &quot;, &quot; and &quot;) is &quot;1, 2 and 3&quot; 
    [L.list: &quot;a&quot;, true, ~5.3].join-str-last(&quot; : &quot;, &quot; # &quot;) is &quot;a : true # ~5.3&quot; 
    L.empty.join-str-last(&quot;nothing at all&quot;, &quot;really nothing&quot;) is &quot;&quot; 
    [L.list: 1, 2].join-str-last(&quot;a&quot;, &quot;b&quot;) is &quot;1b2&quot; 
    [L.list: 1].join-str-last(&quot;a&quot;, &quot;b&quot;) is &quot;1&quot; 
 end">(Try it!)</a></p></div><h2 id="List-Functions" toclevel="2" tocentry="yes">List Functions</h2><p>  These functions are available on the <tt class="pyretexpr">lists</tt> module object.   Some of the functions require the <tt class="pyretexpr">lists</tt> module to be   <tt class="pyretexpr">import</tt>ed, as indicated in the examples.</p><p>  </p><div><p><span><a name="length"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#length">length</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Number">Number</a></span></pre><p>Returns the number of elements in the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.length([list: 'a', 'b']) is 2
  L.length(L.empty) is 0
  L.length(L.link("a", L.empty)) is 1
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.length([list: 'a', 'b']) is 2 
    L.length(L.empty) is 0 
    L.length(L.link(&quot;a&quot;, L.empty)) is 1 
 end">(Try it!)</a></p></div></div><p>  </p><div><p><span><a name="get"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#get">get</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; a</span></pre></div><p>Equivalent to <tt class="pyretexpr">list</tt><a href="../trove/lists.html#.get">.get</a><tt class="pyretexpr">(n)</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3]

  L.get(l, 0) is 1
  L.get(l, 4) raises "too large"
  L.get(l, -1) raises "invalid argument"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3] 

    L.get(l, 0) is 1 
    L.get(l, 4) raises &quot;too large&quot; 
    L.get(l, -1) raises &quot;invalid argument&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="set"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#set">set</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">v :: a</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.set([L.list: 1, 2, 3], 0, 5) is [L.list: 5, 2, 3]
  L.set([L.list: ], 0, 5) raises "too large"
end</pre></div><div><p><span><a name="sort"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#sort">sort</a> :: <span>(<span><span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span></pre><p>Produces a new <tt class="pyretexpr">List</tt> whose contents are the same as those of the current <tt class="pyretexpr">List</tt>, sorted by <a href="../lang/equality.html#&lt;"><tt class="pyretexpr">&lt;</tt></a> and <a href="../lang/equality.html#=="><tt class="pyretexpr">==</tt></a>.  This requires that the items of the <tt class="pyretexpr">List</tt> be comparable by <a href="../lang/equality.html#&lt;"><tt class="pyretexpr">&lt;</tt></a> (see <a href="lang/forms.html#s:binop-expr">Binary Operators</a>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.sort([L.list: 1, 5, 3, 2, 4]) is [L.list: 1, 2, 3, 4, 5]
  L.sort([L.list: "aaaa", "B", "a"]) is [L.list: "B", "a", "aaaa"]
  L.sort([L.list: 'a', 1]) raises "binop-error"
  L.sort([L.list: true, false]) raises "binop-error"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.sort([L.list: 1, 5, 3, 2, 4]) is [L.list: 1, 2, 3, 4, 5] 
    L.sort([L.list: &quot;aaaa&quot;, &quot;B&quot;, &quot;a&quot;]) is [L.list: &quot;B&quot;, &quot;a&quot;, &quot;aaaa&quot;] 
    L.sort([L.list: 'a', 1]) raises &quot;binop-error&quot; 
    L.sort([L.list: true, false]) raises &quot;binop-error&quot; 
 end">(Try it!)</a></p></div></div><div><p><span><a name="sort-by"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#sort-by">sort-by</a> :: <span>(<span><span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span>, <span>(<span>A, A</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>, <span>(<span>A, A</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span></pre><p>Like <a href="../trove/lists.html#sort"><tt class="pyretexpr">sort</tt></a>, but the comparison and equality operators can be specified.  This allows for sorting <tt class="pyretexpr">List</tt>s whose contents are not comparable by <a href="../lang/equality.html#&lt;"><tt class="pyretexpr">&lt;</tt></a>,  or sorting by custom comparisons, for example, sorting by string length instead of alphabetically.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) &gt; string-length(s2)
  end
  fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) == string-length(s2)
  end
  L.sort-by([L.list: 'a', 'aa', 'aaa'], length-comparison, length-equality) is
    [L.list: 'aaa', 'aa', 'a']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) &gt; string-length(s2) 
    end 
    fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) == string-length(s2) 
    end 
    L.sort-by([L.list: 'a', 'aa', 'aaa'], length-comparison, length-equality) is 
      [L.list: 'aaa', 'aa', 'a'] 
 end">(Try it!)</a></p></div></div><div><p><span><a name="join-str"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#join-str">join-str</a> :: <span>(<span><span class="pyret-content">sep :: <a href="../trove/globals.html#String">String</a></span></span>) -&gt; <a href="../trove/globals.html#String">String</a></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].join-str("; ") is "1; 2; 3"
  [L.list: "a", true, ~5.3].join-str(" : ") is "a : true : ~5.3"
  L.empty.join-str("nothing at all") is ""
end</pre></div><p>  </p><div><p><span><a name="range"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#range">range</a> :: <span>(<span><span class="pyret-content">start :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">stop :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span><a href="../trove/globals.html#Number">Number</a></span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>check:
  range(0, 0) is [list: ]
  range(0, 1) is [list: 0]
  range(-5, 5) is [list: -5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
end</pre></div><p>  </p><div><p><span><a name="range-by"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#range-by">range-by</a> :: <span>(<span><span class="pyret-content">start :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">stop :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">delta :: <a href="../trove/globals.html#Number">Number</a></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span><a href="../trove/globals.html#Number">Number</a></span>&gt;</span></span></pre></div><p>  </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.range-by(1, 10, 4) is [L.list: 1, 5, 9]
  L.range-by(10, 1, -4) is [L.list: 10, 6, 2]
  L.range-by(3, 20, 9) is [L.list: 3, 12]
  L.range-by(20, 3, 9) is L.empty
  L.range-by(20, 3, -9) is [L.list: 20, 11]
  L.range-by(2, 3, 0) raises "interval of 0"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.range-by(1, 10, 4) is [L.list: 1, 5, 9] 
    L.range-by(10, 1, -4) is [L.list: 10, 6, 2] 
    L.range-by(3, 20, 9) is [L.list: 3, 12] 
    L.range-by(20, 3, 9) is L.empty 
    L.range-by(20, 3, -9) is [L.list: 20, 11] 
    L.range-by(2, 3, 0) raises &quot;interval of 0&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="repeat"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#repeat">repeat</a> :: <span>(<span><span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">e :: a</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.repeat(0, 10) is L.empty
  L.repeat(3, -1) is [L.list: -1, -1, -1]
  L.repeat(1, "foo") is L.link("foo", L.empty)
  L.repeat(3, L.empty) is [L.list: [L.list: ], [L.list: ], [L.list: ]]
end</pre></div><p>  </p><div><p><span><a name="distinct"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#distinct">distinct</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre><p>  Given a <tt class="pyretexpr">List</tt>, returns a new <tt class="pyretexpr">List</tt> containing only one copy of each element   that is duplicated in the <tt class="pyretexpr">List</tt>.</p><p>  The last (latest in the <tt class="pyretexpr">List</tt>) copy is kept.   <tt class="pyretexpr">Roughnums</tt> are not compared for equality, and so will always appear in the   output <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.distinct([L.list: 3, 1, 2, 2, 3, 2]) is [L.list: 1, 3, 2]
  L.distinct([L.list: ~1, ~1]) is-roughly [L.list: ~1, ~1]
  L.distinct([L.list: ~1, ~1, 1]) is-roughly [L.list: ~1, ~1, 1]
  L.distinct([L.list: ~1, ~1, 1, 1]) is-roughly [L.list: ~1, ~1, 1]
  L.distinct([L.list: ~1, ~2, ~3]) is-roughly [L.list: ~1, ~2, ~3]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.distinct([L.list: 3, 1, 2, 2, 3, 2]) is [L.list: 1, 3, 2] 
    L.distinct([L.list: ~1, ~1]) is-roughly [L.list: ~1, ~1] 
    L.distinct([L.list: ~1, ~1, 1]) is-roughly [L.list: ~1, ~1, 1] 
    L.distinct([L.list: ~1, ~1, 1, 1]) is-roughly [L.list: ~1, ~1, 1] 
    L.distinct([L.list: ~1, ~2, ~3]) is-roughly [L.list: ~1, ~2, ~3] 
 end">(Try it!)</a></p></div></div><p>  </p><div><p><span><a name="filter"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#filter">filter</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-is-one(s :: String) -&gt; Boolean:
    string-length(s) == 1
  end
  L.filter(length-is-one, [L.list: "ab", "a", "", "c"])
    is [L.list: "a", "c"]
  L.filter(is-link, [L.list: L.empty, L.link(1, L.empty), L.empty])
    is [L.list: L.link(1, L.empty)]
end</pre></div><p>  </p><div><p><span><a name="partition"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#partition">partition</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>{<span class="pyret-content">is-true :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">is-false :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>}</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.partition(lam(e): e &gt; 0 end, [L.list: -1, 1])
    is {is-true: [L.list: 1], is-false: [L.list: -1]}
  L.partition(lam(e): e &gt; 5 end, [L.list: -1, 1])
    is {is-true: [L.list: ], is-false: [L.list: -1, 1]}
  L.partition(lam(e): e &lt; 5 end, [L.list: -1, 1])
    is {is-true: [L.list: -1, 1], is-false: [L.list: ]}
end</pre></div><div><p><span><a name="find"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#find">find</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/option.html#Option">Option</a>&lt;<span>a</span>&gt;</span></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L
import option as O

check:
  L.find(num-is-integer,  [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(100)
  L.find(num-is-rational, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2.5)
  L.find(num-is-negative, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none
  L.find(lam(n): n &lt;= 2 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2)
  L.find(lam(n): n &lt; 1 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none
end</pre><p><a class="show-embed" code="import lists as L 
 import option as O 

 check: 
    L.find(num-is-integer,  [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(100) 
    L.find(num-is-rational, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2.5) 
    L.find(num-is-negative, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none 
    L.find(lam(n): n &lt;= 2 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2) 
    L.find(lam(n): n &lt; 1 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="split-at"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#split-at">split-at</a> :: <span>(<span><span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>{<span class="pyret-content">prefix :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">suffix :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>}</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.split-at(2, [L.list: 'a', 'b', 'c', 'd'])
    is {prefix: [L.list: "a", "b"], suffix: [L.list: "c", "d"]}
  L.split-at(0, [L.list: 1, 2, 3, 4])
    is {prefix: L.empty, suffix: [L.list: 1, 2, 3, 4]}
  L.split-at(4, [L.list: 1, 2, 3, 4])
    is {prefix: [L.list: 1, 2, 3, 4], suffix: L.empty}
  L.split-at(2, [L.list: 1, 2, 3, 4])
    is {prefix: [L.list: 1, 2], suffix: [L.list: 3, 4]}
  L.split-at(-1, [L.list: 1, 2, 3, 4]) raises "Invalid index"
  L.split-at(5, [L.list: 1, 2, 3, 4]) raises "Index too large"
end</pre></div><p>  </p><div><p><span><a name="last"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#last">last</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span></span>) -&gt; A</span></pre><p>Returns the last element in <tt class="pyretexpr">lst</tt>.  Raises an error if the <tt class="pyretexpr">List</tt> is empty.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.last([L.list: 1, 3, 5]) is 5
  L.last([L.list: 1]) is 1
  L.last([L.list: ]) raises "last of empty list"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.last([L.list: 1, 3, 5]) is 5 
    L.last([L.list: 1]) is 1 
    L.last([L.list: ]) raises &quot;last of empty list&quot; 
 end">(Try it!)</a></p></div></div><div><p><span><a name="push"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#push">push</a> :: <span>(<span><span class="pyret-content">l :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span>, <span class="pyret-content">elt :: A</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span></pre><p>Constructs a list with the given element prepended to the front of the given list.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.push(L.empty, "a") is L.link("a", L.empty)
  L.push(L.link("a", empty), "b") is L.link("b", L.link("a", L.empty))
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.push(L.empty, &quot;a&quot;) is L.link(&quot;a&quot;, L.empty) 
    L.push(L.link(&quot;a&quot;, empty), &quot;b&quot;) is L.link(&quot;b&quot;, L.link(&quot;a&quot;, L.empty)) 
 end">(Try it!)</a></p></div></div><p>  </p><div><p><span><a name="append"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#append">append</a> :: <span>(<span><span class="pyret-content">front :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span>, <span class="pyret-content">back :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>A</span>&gt;</span></span></pre><p>Produce a new <tt class="pyretexpr">List</tt> with the elements of <tt class="pyretexpr">front</tt> followed by the elements of <tt class="pyretexpr">back</tt>.</p><pre class="good-ex">import lists as L

check:
  L.append([L.list: 1, 2, 3], [L.list: 4, 5, 6])
    is [L.list: 1, 2, 3, 4, 5, 6]
  L.append([L.list: ], [L.list: ]) is [L.list: ]
  L.append([L.list: 1], [L.list: 2]) is [L.list: 1, 2]
end</pre><p>Note that it does <i>not</i> change either <tt class="pyretexpr">List</tt>:</p><pre class="bad-ex">import lists as L

check:
  l = [L.list: 1, 2, 3]
  L.append(l, [L.list: 4])
  l is [L.list: 1, 2, 3, 4] # this test fails
end</pre></div><p>  </p><div><p><span><a name="any"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#any">any</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.any(is-number, [L.list: 1, 2, 3]) is true
  L.any(is-string, [L.list: 1, 2, 3]) is false
  L.any(lam(n): n &gt; 1 end, [L.list: 1, 2, 3]) is true
  L.any(lam(n): n &gt; 3 end, [L.list: 1, 2, 3]) is false
end</pre></div><p>  </p><div><p><span><a name="all"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#all">all</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.all(is-number, [L.list: 1, 2, 3]) is true
  L.all(is-string, [L.list: 1, 2, 'c']) is false
  L.all(lam(n): n &gt; 1 end, [L.list: 1, 2, 3]) is false
  L.all(lam(n): n &lt;= 3 end, [L.list: 1, 2, 3]) is true
end</pre></div><p>  </p><div><p><span><a name="all2"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#all2">all2</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, b</span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span>)</span></span>, <span class="pyret-content">lst1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">lst2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when both <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true
  L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 3], [L.list: 2, 1, 0]) is true
  L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2], [L.list: 2, 1, 0]) is true
  L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 6], [L.list: 2, 1]) is true
  L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true
  L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 0], [L.list: 0, 1]) is true
  L.all2(lam(n, m): n &lt; m end, [L.list: 1], [L.list: 2, 0]) is true
  L.all2(lam(n, m): n &lt; m end, [L.list: 1, 2, 3], L.empty) is true
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true 
    L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 3], [L.list: 2, 1, 0]) is true 
    L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2], [L.list: 2, 1, 0]) is true 
    L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 6], [L.list: 2, 1]) is true 
    L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true 
    L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 0], [L.list: 0, 1]) is true 
    L.all2(lam(n, m): n &lt; m end, [L.list: 1], [L.list: 2, 0]) is true 
    L.all2(lam(n, m): n &lt; m end, [L.list: 1, 2, 3], L.empty) is true 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map">map</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; b</span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map(num-tostring, [L.list: 1, 2]) is [L.list: "1", "2"]
  L.map(lam(x): x + 1 end, [L.list: 1, 2]) is [L.list: 2, 3]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map(num-tostring, [L.list: 1, 2]) is [L.list: &quot;1&quot;, &quot;2&quot;] 
    L.map(lam(x): x + 1 end, [L.list: 1, 2]) is [L.list: 2, 3] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map2"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map2">map2</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, b</span>) -&gt; c</span>)</span></span>, <span class="pyret-content">l1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">l2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when both <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map2(string-append, [L.list: "mis", "mal"], [L.list: "fortune", "practice"])
    is [L.list: "misfortune", "malpractice"]
  L.map2(_ + _, [L.list: "mis", "mal"], [L.list: "fortune", "practice"])
    is [L.list: "misfortune", "malpractice"]
  L.map2(string-append, [L.list: "mis", "mal"], [L.list: "fortune"])
    is [L.list: "misfortune"]
  L.map2(string-append, [L.list: "mis", "mal"], L.empty)
    is L.empty
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map2(string-append, [L.list: &quot;mis&quot;, &quot;mal&quot;], [L.list: &quot;fortune&quot;, &quot;practice&quot;]) 
      is [L.list: &quot;misfortune&quot;, &quot;malpractice&quot;] 
    L.map2(_ + _, [L.list: &quot;mis&quot;, &quot;mal&quot;], [L.list: &quot;fortune&quot;, &quot;practice&quot;]) 
      is [L.list: &quot;misfortune&quot;, &quot;malpractice&quot;] 
    L.map2(string-append, [L.list: &quot;mis&quot;, &quot;mal&quot;], [L.list: &quot;fortune&quot;]) 
      is [L.list: &quot;misfortune&quot;] 
    L.map2(string-append, [L.list: &quot;mis&quot;, &quot;mal&quot;], L.empty) 
      is L.empty 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map3"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map3">map3</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, b, c</span>) -&gt; d</span>)</span></span>, <span class="pyret-content">l1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">l2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">l3 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>d</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun full-name(n1, n2, n3) -&gt; String:
    n1 + " " + n2 + " " + n3
  end
  full-name("Thomas", "Alva", "Edison") is "Thomas Alva Edison"
  L.map3(full-name, [L.list: "Martin", "Mohandas", "Pelé"],
    [L.list: "Luther", "Karamchand"], [L.list: "King", "Gandhi"]) is
  [L.list: "Martin Luther King", "Mohandas Karamchand Gandhi"]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun full-name(n1, n2, n3) -&gt; String: 
      n1 + &quot; &quot; + n2 + &quot; &quot; + n3 
    end 
    full-name(&quot;Thomas&quot;, &quot;Alva&quot;, &quot;Edison&quot;) is &quot;Thomas Alva Edison&quot; 
    L.map3(full-name, [L.list: &quot;Martin&quot;, &quot;Mohandas&quot;, &quot;Pelé&quot;], 
      [L.list: &quot;Luther&quot;, &quot;Karamchand&quot;], [L.list: &quot;King&quot;, &quot;Gandhi&quot;]) is 
    [L.list: &quot;Martin Luther King&quot;, &quot;Mohandas Karamchand Gandhi&quot;] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map4"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map4">map4</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, b, c, d</span>) -&gt; e</span>)</span></span>, <span class="pyret-content">l1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">l2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">l3 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span>, <span class="pyret-content">l4 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>d</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>e</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun title-name(title, n1, n2, n3) -&gt; String:
    title + " " + n1 + " " + n2 + " " + n3
  end
  L.map4(title-name, [L.list: "Reverend", "Mahātmā"],
    [L.list: "Martin", "Mohandas", "Pele"],
    [L.list: "Luther", "Karamchand"], [list: "King", "Gandhi"]) is
  [L.list: "Reverend Martin Luther King", "Mahātmā Mohandas Karamchand Gandhi"]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun title-name(title, n1, n2, n3) -&gt; String: 
      title + &quot; &quot; + n1 + &quot; &quot; + n2 + &quot; &quot; + n3 
    end 
    L.map4(title-name, [L.list: &quot;Reverend&quot;, &quot;Mahātmā&quot;], 
      [L.list: &quot;Martin&quot;, &quot;Mohandas&quot;, &quot;Pele&quot;], 
      [L.list: &quot;Luther&quot;, &quot;Karamchand&quot;], [list: &quot;King&quot;, &quot;Gandhi&quot;]) is 
    [L.list: &quot;Reverend Martin Luther King&quot;, &quot;Mahātmā Mohandas Karamchand Gandhi&quot;] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map_n">map_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span><a href="../trove/globals.html#Number">Number</a>, a</span>) -&gt; b</span></span>, <span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></pre></div><p>  Like map, but also includes a numeric argument for the position in the <tt class="pyretexpr">List</tt>   that is currently being mapped over.</p><p>  </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map_n(num-expt, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 1, 4, 9]
  L.map_n(lam(n, elem): n * elem end, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6]
  L.map_n(_ * _, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6]
  L.map_n(_ * _, 1, [L.list: 2, 2, 2, 2]) is [L.list: 2, 4, 6, 8]
  L.map_n(_ + _, 10, [L.list: 2, 2, 2, 2]) is [L.list: 12, 13, 14, 15]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map_n(num-expt, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 1, 4, 9] 
    L.map_n(lam(n, elem): n * elem end, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6] 
    L.map_n(_ * _, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6] 
    L.map_n(_ * _, 1, [L.list: 2, 2, 2, 2]) is [L.list: 2, 4, 6, 8] 
    L.map_n(_ + _, 10, [L.list: 2, 2, 2, 2]) is [L.list: 12, 13, 14, 15] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map2_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map2_n">map2_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span><a href="../trove/globals.html#Number">Number</a>, a, b</span>) -&gt; c</span></span>, <span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span></pre></div><p>Like <a href="../trove/lists.html#map_n"><tt class="pyretexpr">map_n</tt></a>, but for two-argument functions.</p><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map2_n(lam(n, a, b): n * (a + b) end, 10,
    [L.list: 2, 2, 2, 2], [L.list: 0, 3, 9, 12])
    is [L.list: 20, 55, 132, 182]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map2_n(lam(n, a, b): n * (a + b) end, 10, 
      [L.list: 2, 2, 2, 2], [L.list: 0, 3, 9, 12]) 
      is [L.list: 20, 55, 132, 182] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map3_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map3_n">map3_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span><a href="../trove/globals.html#Number">Number</a>, a, b, c</span>) -&gt; d</span></span>, <span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>d</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun combine(n, l1, l2, l3) -&gt; String:
    string-repeat(l1, n) + string-repeat(l2, n) +
    string-repeat(l3, n)
  end
  combine(2, 'a', 'b', 'c') is "aabbcc"
  L.map3_n(combine, 1, [L.list: 'a', 'a'], [L.list: 'b', 'b'],
    [L.list: 'c', 'c']) is [L.list: 'abc', 'aabbcc']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun combine(n, l1, l2, l3) -&gt; String: 
      string-repeat(l1, n) + string-repeat(l2, n) + 
      string-repeat(l3, n) 
    end 
    combine(2, 'a', 'b', 'c') is &quot;aabbcc&quot; 
    L.map3_n(combine, 1, [L.list: 'a', 'a'], [L.list: 'b', 'b'], 
      [L.list: 'c', 'c']) is [L.list: 'abc', 'aabbcc'] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="map4_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#map4_n">map4_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span><a href="../trove/globals.html#Number">Number</a>, a, b, c, d</span>) -&gt; e</span></span>, <span class="pyret-content">n :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>d</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>e</span>&gt;</span></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun combine(n, l1, l2, l3, l4) -&gt; String:
    string-repeat(l1, n) + string-repeat(l2, n) +
    string-repeat(l3, n) + string-repeat(l4, n)
  end
  combine(2, 'a', 'b', 'c', 'd') is "aabbccdd"
  L.map4_n(combine, 1, L.repeat(3, 'a'), L.repeat(3, 'b'),
    L.repeat(3, 'c'), L.repeat(3, 'd')) is
  [L.list: 'abcd', 'aabbccdd', 'aaabbbcccddd']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun combine(n, l1, l2, l3, l4) -&gt; String: 
      string-repeat(l1, n) + string-repeat(l2, n) + 
      string-repeat(l3, n) + string-repeat(l4, n) 
    end 
    combine(2, 'a', 'b', 'c', 'd') is &quot;aabbccdd&quot; 
    L.map4_n(combine, 1, L.repeat(3, 'a'), L.repeat(3, 'b'), 
      L.repeat(3, 'c'), L.repeat(3, 'd')) is 
    [L.list: 'abcd', 'aabbccdd', 'aaabbbcccddd'] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="each"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each">each</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  one-four = [list: 1, 2, 3, 4]
  block:
    var counter = 0
    L.each(lam(n): counter := counter + n end, one-four)
    counter is 1 + 2 + 3 + 4
    counter is 10
  end
  block:
    var counter = 1
    L.each(lam(n): counter := counter * n end, one-four)
    counter is 1 * 2 * 3 * 4
    counter is 24
  end
end</pre></div><p>  </p><div><p><span><a name="each2"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each2">each2</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, b</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each2(lam(x, y): counter := counter + x + y end,
    [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10])
  counter is 33
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each2(lam(x, y): counter := counter + x + y end, 
      [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10]) 
    counter is 33 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="each3"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each3">each3</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, b, c</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each3(lam(x, y, z): counter := counter + x + y + z end,
    [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10], [L.list: 100, 100])
  counter is 222
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each3(lam(x, y, z): counter := counter + x + y + z end, 
      [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10], [L.list: 100, 100]) 
    counter is 222 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="each4"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each4">each4</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>a, b, c, d</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>d</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each4(lam(w, x, y, z): counter := counter + w + x + y + z end,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100],
    [L.list: 1000, 1000])
  counter is 2222
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each4(lam(w, x, y, z): counter := counter + w + x + y + z end, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100], 
      [L.list: 1000, 1000]) 
    counter is 2222 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="each_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each_n">each_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span><a href="../trove/globals.html#Number">Number</a>, a</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">num :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><p>Like <a href="../trove/lists.html#each"><tt class="pyretexpr">each</tt></a>, but also includes a numeric argument for the current index in the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each_n(lam(i, w): counter := counter + (i * w) end,
    1,
    [L.list: 1, 1, 1])
  counter is 6
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each_n(lam(i, w): counter := counter + (i * w) end, 
      1, 
      [L.list: 1, 1, 1]) 
    counter is 6 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="each2_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each2_n">each2_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span><a href="../trove/globals.html#Number">Number</a>, a, b</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">num :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each2_n(lam(i, w, x): counter := counter + (i * (w + x)) end,
    1,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10])
  counter is 66
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each2_n(lam(i, w, x): counter := counter + (i * (w + x)) end, 
      1, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10]) 
    counter is 66 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="each3_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each3_n">each3_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span><a href="../trove/globals.html#Number">Number</a>, a, b, c</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">num :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">lst3 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each3_n(lam(i, w, x, y): counter := counter + (i * (w + x + y)) end,
    1,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100])
  counter is 666
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each3_n(lam(i, w, x, y): counter := counter + (i * (w + x + y)) end, 
      1, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100]) 
    counter is 666 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="each4_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#each4_n">each4_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span><a href="../trove/globals.html#Number">Number</a>, a, b, c, d</span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span>)</span></span>, <span class="pyret-content">num :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">lst1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">lst2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>b</span>&gt;</span></span>, <span class="pyret-content">lst3 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>c</span>&gt;</span></span>, <span class="pyret-content">lst4 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>d</span>&gt;</span></span></span>) -&gt; <a href="../trove/globals.html#Nothing">Nothing</a></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each4_n(lam(i, w, x, y, z): counter := counter + (i * (w + x + y + z)) end,
    1,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100],
    [L.list: 1000, 1000, 1000])
  counter is 6666
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each4_n(lam(i, w, x, y, z): counter := counter + (i * (w + x + y + z)) end, 
      1, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100], 
      [L.list: 1000, 1000, 1000]) 
    counter is 6666 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="fold-while"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#fold-while">fold-while</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>Base, Elt</span>) -&gt; <span><a href="../trove/either.html#Either">Either</a>&lt;<span>Base, Base</span>&gt;</span></span></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L
import either as EI

check:
  fun stop-at-not-one(acc :: Number, n :: Number) -&gt; EI.Either:
    if n == 1:
      EI.left(acc + n)
    else:
      EI.right(acc)
    end
  end

  L.fold-while(stop-at-not-one, 0, [L.list: 1, 1, 1, 0, 1, 1]) is 3
end</pre><p><a class="show-embed" code="import lists as L 
 import either as EI 

 check: 
    fun stop-at-not-one(acc :: Number, n :: Number) -&gt; EI.Either: 
      if n == 1: 
        EI.left(acc + n) 
      else: 
        EI.right(acc) 
      end 
    end 

    L.fold-while(stop-at-not-one, 0, [L.list: 1, 1, 1, 0, 1, 1]) is 3 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="fold"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#fold">fold</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre><p><tt class="pyretexpr">fold</tt> computes <tt class="pyretexpr">f(... f(f(base, first-elt), second-elt) ..., last-elt)</tt>.  For <a href="../trove/lists.html#empty"><tt class="pyretexpr">empty</tt></a>, returns <tt class="pyretexpr">base</tt>.</p><p>In other words, <tt class="pyretexpr">fold</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the left.</p></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.fold((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6
  L.fold((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16

  fun combine(acc, elt) -&gt; String:
    tostring(elt) + " - " + acc
  end
  L.fold(combine, "END", [L.list: 3, 2, 1]) is "1 - 2 - 3 - END"
  L.fold(combine, "END", L.empty) is "END"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.fold((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6 
    L.fold((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16 

    fun combine(acc, elt) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    L.fold(combine, &quot;END&quot;, [L.list: 3, 2, 1]) is &quot;1 - 2 - 3 - END&quot; 
    L.fold(combine, &quot;END&quot;, L.empty) is &quot;END&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="foldl"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#foldl">foldl</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><p>  Another name for <a href="../trove/lists.html#fold"><tt class="pyretexpr">fold</tt></a>.   </p><div><p><span><a name="foldr"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#foldr">foldr</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><p>Computes <tt class="pyretexpr">f(f(... f(base, last-elt) ..., second-elt), first-elt)</tt>.  For <a href="../trove/lists.html#empty"><tt class="pyretexpr">empty</tt></a>, returns <tt class="pyretexpr">base</tt>.  In other words, it uses <tt class="pyretexpr">f</tt> to combine <tt class="pyretexpr">base</tt> with each item in the <tt class="pyretexpr">List</tt> starting from the right.</p><p>In other words, <tt class="pyretexpr">foldr</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the right.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.foldr((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6
  L.foldr((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16

  fun combine(acc, elt) -&gt; String:
    tostring(elt) + " - " + acc
  end
  L.foldr(combine, "END", [L.list: 3, 2, 1]) is "3 - 2 - 1 - END"
  L.foldr(combine, "END", L.empty) is "END"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.foldr((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6 
    L.foldr((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16 

    fun combine(acc, elt) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    L.foldr(combine, &quot;END&quot;, [L.list: 3, 2, 1]) is &quot;3 - 2 - 1 - END&quot; 
    L.foldr(combine, &quot;END&quot;, L.empty) is &quot;END&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="fold2"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#fold2">fold2</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>Base, Elt1, Elt2</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">l1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt1</span>&gt;</span></span>, <span class="pyret-content">l2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt2</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.fold2(lam(acc, elt1, elt2): acc + elt1 + elt2 end,
    11,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10])
    is 44
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.fold2(lam(acc, elt1, elt2): acc + elt1 + elt2 end, 
      11, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10]) 
      is 44 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="fold3"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#fold3">fold3</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>Base, Elt1, Elt2, Elt3</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">l1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt1</span>&gt;</span></span>, <span class="pyret-content">l2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt2</span>&gt;</span></span>, <span class="pyret-content">l3 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt3</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fold3(lam(acc, elt1, elt2, elt3): acc + elt1 + elt2 + elt3 end,
    111,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100])
    is 444
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fold3(lam(acc, elt1, elt2, elt3): acc + elt1 + elt2 + elt3 end, 
      111, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100]) 
      is 444 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="fold4"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#fold4">fold4</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span>Base, Elt1, Elt2, Elt3, Elt4</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">l1 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt1</span>&gt;</span></span>, <span class="pyret-content">l2 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt2</span>&gt;</span></span>, <span class="pyret-content">l3 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt3</span>&gt;</span></span>, <span class="pyret-content">l4 :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt4</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.fold4(lam(acc, elt1, elt2, elt3, elt4):
    acc + elt1 + elt2 + elt3 + elt4 end,
    1111,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100],
    [list: 1000, 1000])
    is 3333
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.fold4(lam(acc, elt1, elt2, elt3, elt4): 
      acc + elt1 + elt2 + elt3 + elt4 end, 
      1111, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100], 
      [list: 1000, 1000]) 
      is 3333 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="fold_n"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#fold_n">fold_n</a> :: <span>(<span><span class="pyret-content">f :: <span>(<span>(<span><a href="../trove/globals.html#Number">Number</a>, Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-content">num :: <a href="../trove/globals.html#Number">Number</a></span>, <span class="pyret-content">base :: Base</span>, <span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  # for comparison, here is a map_n example:
  L.map_n(lam(index, elt): index * elt end, 0, [L.list: 2, 2, 2, 2])
    is [L.list: 0, 2, 4, 6]
  # this fold_n version adds up the result
  L.fold_n(lam(index, acc, elt): acc + (index * elt) end, 0, 0,
    [L.list: 2, 2, 2, 2])
    is 12
  L.fold_n(lam(index, acc, elt): acc + (index * elt) end, 0, 10,
    [L.list: 2, 2, 2, 2])
    is 22
  L.fold_n(lam(index, acc, elt): acc + (index * elt) end, 10, 0,
    [L.list: 2, 2, 2, 2])
    is 92 because 20 + 22 + 24 + 26
end</pre></div><p>  {</p><p>  Like <a href="../trove/lists.html#fold"><tt class="pyretexpr">fold</tt></a>, but takes a numeric argument for the position in the   <tt class="pyretexpr">List</tt> that is currently being visited.</p><p>  }</p><p>  </p><div><p><span><a name="member"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member">member</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="member-always"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member-always">member-always</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="member-identical"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member-identical">member-identical</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><div><p><span><a name="member-now"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member-now">member-now</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; <a href="../trove/globals.html#Boolean">Boolean</a></span></pre></div><p><tt class="pyretexpr">member</tt> returns <tt class="pyretexpr">true</tt> if <tt class="pyretexpr">List</tt> <tt class="pyretexpr">lst</tt> contains the element <tt class="pyretexpr">elt</tt>, as compared by <tt class="pyretexpr">==</tt>. The other three functions are analogous to <a href="../trove/lists.html#member"><tt class="pyretexpr">member</tt></a>, but use <a href="../lang/equality.html#equal-always"><tt class="pyretexpr">equal-always</tt></a>, <a href="../lang/equality.html#identical"><tt class="pyretexpr">identical</tt></a>, or <a href="../lang/equality.html#equal-now"><tt class="pyretexpr">equal-now</tt></a> to perform the comparison. (Thus <tt class="pyretexpr">member-always</tt> is the same as <tt class="pyretexpr">member</tt>; the name is provided for completeness and in case the user wants to make their intent more explicit.)</p><p>Note that if a <tt class="pyretexpr">Roughnum</tt> is present, these functions will raise exceptions. To avoid that, use <a href="../trove/lists.html#member3"><tt class="pyretexpr">member3</tt></a> and the analogous related functions.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.member([L.list: 1, 2, 3], 2) is true
  L.member([L.list: 2, 4, 6], 3) is false
  L.member([L.list: ], L.empty) is false
  L.member([L.list: 1, 2, 3], ~1) raises "Roughnums"
  L.member([L.list: ~1, 2, 3], 1) raises "Roughnums"

  L.member([L.list: 'a'], 'a') is true
  L.member([L.list: false], false) is true
  L.member([L.list: nothing], nothing) is true
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.member([L.list: 1, 2, 3], 2) is true 
    L.member([L.list: 2, 4, 6], 3) is false 
    L.member([L.list: ], L.empty) is false 
    L.member([L.list: 1, 2, 3], ~1) raises &quot;Roughnums&quot; 
    L.member([L.list: ~1, 2, 3], 1) raises &quot;Roughnums&quot; 

    L.member([L.list: 'a'], 'a') is true 
    L.member([L.list: false], false) is true 
    L.member([L.list: nothing], nothing) is true 
 end">(Try it!)</a></p></div><div><p><span><a name="member3"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member3">member3</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><div><p><span><a name="member-always3"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member-always3">member-always3</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><div><p><span><a name="member-identical3"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member-identical3">member-identical3</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><div><p><span><a name="member-now3"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member-now3">member-now3</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><p>These functions are analogous to <a href="../trove/lists.html#member"><tt class="pyretexpr">member</tt></a>, but use <a href="../lang/equality.html#equal-always3"><tt class="pyretexpr">equal-always3</tt></a>, <a href="../lang/equality.html#identical3"><tt class="pyretexpr">identical3</tt></a>, or <a href="../lang/equality.html#equal-now3"><tt class="pyretexpr">equal-now3</tt></a> to perform the comparison. Thus, they do not raise an exception if a <tt class="pyretexpr">Roughnum</tt> is present.</p><div><p><b>Examples:</b></p><pre>import lists as L
import equality as EQ

check:
  L.member3([L.list: 1, 2, 3], ~1) satisfies EQ.is-Unknown
  L.member3([L.list: ~1, 2, 3], 1) satisfies EQ.is-Unknown
end</pre><p><a class="show-embed" code="import lists as L 
 import equality as EQ 

 check: 
    L.member3([L.list: 1, 2, 3], ~1) satisfies EQ.is-Unknown 
    L.member3([L.list: ~1, 2, 3], 1) satisfies EQ.is-Unknown 
 end">(Try it!)</a></p></div><div><p><span><a name="member-with"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#member-with">member-with</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span>, <span class="pyret-content">eq :: <span>(<span>(<span>a, a</span>) -&gt; EqualityResult</span>)</span></span></span>) -&gt; EqualityResult</span></pre></div><p><tt class="pyretexpr">member-with</tt> is <tt class="pyretexpr">member</tt> with a custom equality function. Returns an <tt class="pyretexpr">equality.Equal</tt> if the <tt class="pyretexpr">eq</tt> parameter returns <tt class="pyretexpr">equality.Equal</tt> for <tt class="pyretexpr">elt</tt> and any one element of <tt class="pyretexpr">List</tt> <tt class="pyretexpr">lst</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L
import equality as EQ

check:
  fun equal-length(a :: String, b :: String) -&gt; EQ.EqualityResult:
    if string-length(a) == string-length(b):
      EQ.Equal
    else:
      EQ.NotEqual("Different lengths.", a, b)
    end
  end
  equal-length('tom', 'dad') is EQ.Equal
  equal-length('tom', 'father') satisfies EQ.is-NotEqual

  L.member-with([L.list: 'father', 'pater', 'dad'], 'tom', equal-length)
    is EQ.Equal
  L.member-with([L.list: 'father', 'pater'], 'tom', equal-length)
    satisfies EQ.is-NotEqual
end</pre><p><a class="show-embed" code="import lists as L 
 import equality as EQ 

 check: 
    fun equal-length(a :: String, b :: String) -&gt; EQ.EqualityResult: 
      if string-length(a) == string-length(b): 
        EQ.Equal 
      else: 
        EQ.NotEqual(&quot;Different lengths.&quot;, a, b) 
      end 
    end 
    equal-length('tom', 'dad') is EQ.Equal 
    equal-length('tom', 'father') satisfies EQ.is-NotEqual 

    L.member-with([L.list: 'father', 'pater', 'dad'], 'tom', equal-length) 
      is EQ.Equal 
    L.member-with([L.list: 'father', 'pater'], 'tom', equal-length) 
      satisfies EQ.is-NotEqual 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="reverse"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#reverse">reverse</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Returns a new <tt class="pyretexpr">List</tt> with all the elements of the original <tt class="pyretexpr">List</tt> in reverse order.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3, 4]
  L.reverse(l) is [L.list: 4, 3, 2, 1]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3, 4] 
    L.reverse(l) is [L.list: 4, 3, 2, 1] 
 end">(Try it!)</a></p></div><div><p><span><a name="remove"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#remove">remove</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span>, <span class="pyret-content">elt :: a</span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>Returns a new <tt class="pyretexpr">List</tt> with all the elements of the original that are not equal to the specified element (using <a href="../lang/equality.html#=="><tt class="pyretexpr">==</tt></a> as the comparison).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3, 4, 3, 2, 1]
  L.remove(l, 2) is [L.list: 1, 3, 4, 3, 1]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3, 4, 3, 2, 1] 
    L.remove(l, 2) is [L.list: 1, 3, 4, 3, 1] 
 end">(Try it!)</a></p></div><p>  </p><div><p><span><a name="shuffle"></a></span></p><pre class="pyret-display"><a href="../trove/lists.html#shuffle">shuffle</a> :: <span>(<span><span class="pyret-content">lst :: <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span><a href="../trove/lists.html#List">List</a>&lt;<span>a</span>&gt;</span></span></pre></div><p>  Returns a new <tt class="pyretexpr">List</tt> with all the elements of the original <tt class="pyretexpr">List</tt> in random   order.</p><div><p><b>Examples:</b></p><pre>import lists as L
import sets as S

check:
  l = [L.list: 1, 2, 3, 4]
  l-mixed = L.shuffle(l)
  S.list-to-set(l-mixed) is S.list-to-set(l)
  l-mixed.length() is l.length()
end</pre><p><a class="show-embed" code="import lists as L 
 import sets as S 

 check: 
    l = [L.list: 1, 2, 3, 4] 
    l-mixed = L.shuffle(l) 
    S.list-to-set(l-mixed) is S.list-to-set(l) 
    l-mixed.length() is l.length() 
 end">(Try it!)</a></p></div></div></root>
    <hr/>
    The current page is trove/lists.html.
    The previous page is <a href = "../trove/pick.html">../trove/pick.html</a>.
    The next page is <a href = "../trove/sets.html">../trove/sets.html</a>.
    </div>
  </body>
</html>