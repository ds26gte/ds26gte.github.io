<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Untitled</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="lists" toclevel="1" tocentry="yes"></h1><p>  </p><p>  </p><h2 id="The-List-Datatype" toclevel="2" tocentry="yes">The List Datatype</h2><p>  </p><pre class="pyret-display"><span>data List&lt;a&gt;:</span>
<div><tt>   | <span>empty</span></tt>
<tt>   | <span>link(<span>first :: a</span>, <span>rest :: <span>List&lt;<span>a</span>&gt;</span></span>)</span></tt></div><tt>end</tt></pre><p>  </p><div class="insetpara nested"><div><p><span><a name="empty-66"></a></span></p><pre class="pyret-display">empty :: <span>List&lt;<span>a</span>&gt;</span></pre></div><p>  </p><div><p><span><a name="link-67"></a></span></p><pre class="pyret-display">link :: (<span>first :: a</span>, <span>rest :: <span>List&lt;<span>a</span>&gt;</span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></pre><p></p></div><p>  </p><div><pre class="pyret-display">is-empty :: <span><span><span class="pyret-display">(val :: Any)</span></span> -&gt; Boolean</span></pre></div><p>  </p><div><pre class="pyret-display">is-link :: <span><span><span class="pyret-display">(val :: Any)</span></span> -&gt; Boolean</span></pre></div><p>A <tt class="pyretexpr">List</tt> is an immutable, fixed-length collection indexed by non-negative integers.</p><p>As in most programming languages, you can use <tt class="pyretexpr">List</tt>s in Pyret without understanding much, if anything, about how they are implemented internally in the language.</p><p>However, in functional languages such as Pyret a particular implementation of lists—the linked list—has a central role for both historical and practical reasons, and a fuller understanding of linked lists goes hand in hand with a fuller understanding of Pyret.  If you have not encountered linked lists before and would like to know more, we recommend reading <a href="http://dcic-world.org/">the material on
lists in DCIC</a>.</p><p>In lieu of a full explanation on this page, here are a few quick points to help parse some of the following examples:</p><ul><li>A <tt class="pyretexpr">List</tt> is made up of elements, usually referred to as <tt class="pyretexpr">elt</tt>s in examples.</li><li>Elements are of two types: <tt class="pyretexpr">link</tt> and <tt class="pyretexpr">empty</tt>.</li><li>Every <tt class="pyretexpr">link</tt> actually has two parts: a <bold>first</bold> value and the <bold>rest</bold> of the <tt class="pyretexpr">List</tt>.</li><li>The rest of the <tt class="pyretexpr">List</tt> is itself a <tt class="pyretexpr">link</tt>, or if you have reached the end of the <tt class="pyretexpr">List</tt>, the rest will be <tt class="pyretexpr">empty</tt>.</li></ul><p>and here are some illustrative examples:</p><div><p><b>Examples:</b></p><pre>check:
  l0 = empty
  l1 = link(1, l0)
  l2 = link(2, l1)
  is-empty(l0) is true
  is-link(l0) is false

  is-empty(l1) is false
  is-link(l1) is true

  is-empty(l2) is false
  is-link(l2) is true
end</pre><p><a class="show-embed" code="check: 
    l0 = empty 
    l1 = link(1, l0) 
    l2 = link(2, l1) 
    is-empty(l0) is true 
    is-link(l0) is false 

    is-empty(l1) is false 
    is-link(l1) is true 

    is-empty(l2) is false 
    is-link(l2) is true 
 end">(Try it!)</a></p></div></div><h2 id="List-Creation-Functions" toclevel="2" tocentry="yes">List Creation Functions</h2><pre class="pyret-display">[list: <span class="pyret-display">elt :: a</span>, ...] -&gt; <span>List&lt;<span>a</span>&gt;</span></pre><p><span class="margin-note">This illustrates the underlying structure created when you define a <tt class="pyretexpr">List</tt> with <tt class="pyretexpr">[list: ...]</tt></span></p><p>Constructs a <tt class="pyretexpr">List</tt> out of <tt class="pyretexpr">elt</tt>s by chaining <tt class="pyretexpr">link</tt>s, ending in a single <tt class="pyretexpr">empty</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: ] is L.empty
  [L.list: 1] is L.link(1, L.empty)
  [L.list: 1, 2] is L.link(1, link(2, L.empty))
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: ] is L.empty 
    [L.list: 1] is L.link(1, L.empty) 
    [L.list: 1, 2] is L.link(1, link(2, L.empty)) 
 end">(Try it!)</a></p></div><p>Though it is neither required nor enforced by the language, conventionally, when writing the empty list using the constructor notation, we write an extra spce between the <tt class="pyretexpr">:</tt> and <tt class="pyretexpr">]</tt>.</p><p><bold>Note</bold>: You should <i>not</i> write a trailing <tt class="pyretexpr">empty</tt> when using this constructor notation. Everything you write is an <i>element</i> of the list. Thus,</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: ] is-not [L.list: L.empty]
  L.link(L.empty, L.empty) is [L.list: L.empty]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: ] is-not [L.list: L.empty] 
    L.link(L.empty, L.empty) is [L.list: L.empty] 
 end">(Try it!)</a></p></div><div><pre class="pyret-display">build-list :: <span>(<span><span class="pyret-display">f :: <span><span>Number</span> -&gt; a</span></span>, <span class="pyret-display">size :: Number</span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre></div><p>Constructs a list of length <tt class="pyretexpr">size</tt>, and fills it with the result of calling the function <tt class="pyretexpr">f</tt> with each index from <tt class="pyretexpr">0</tt> to <tt class="pyretexpr">size - 1</tt>.</p><p>Similar to <tt class="pyretexpr">build-arrayarrays</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun sq(x): x * x end
  L.build-list(sq, 4)
    is [L.list: 0, 1, 4, 9]
    because [L.list: sq(0), sq(1), sq(2), sq(3)]
end

check:
  fun build-from(base :: Number) -&gt; List&lt;String&gt;:
    L.build-list({(n): base + n}, 3)
  end

  a = L.build-list(build-from, 3)

  a is [L.list:
    [L.list: 0, 1, 2],
    [L.list: 1, 2, 3],
    [L.list: 2, 3, 4]]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun sq(x): x * x end 
    L.build-list(sq, 4) 
      is [L.list: 0, 1, 4, 9] 
      because [L.list: sq(0), sq(1), sq(2), sq(3)] 
 end 

 check: 
    fun build-from(base :: Number) -&gt; List&lt;String&gt;: 
      L.build-list({(n): base + n}, 3) 
    end 

    a = L.build-list(build-from, 3) 

    a is [L.list: 
      [L.list: 0, 1, 2], 
      [L.list: 1, 2, 3], 
      [L.list: 2, 3, 4]] 
 end">(Try it!)</a></p></div><h2 id="List-Methods" toclevel="2" tocentry="yes">List Methods</h2><p>These methods are available on all <tt class="pyretexpr">List</tt>s whether empty or a link.</p><div class="pyret-display"><tt>.length :: <span>() -&gt; Number</span></tt></div><p>Returns the number of elements in the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 'a', 'b'].length() is 2
  L.empty.length() is 0
  L.link("a", L.empty).length() is 1
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 'a', 'b'].length() is 2 
    L.empty.length() is 0 
    L.link(&quot;a&quot;, L.empty).length() is 1 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.map :: <span><span><span class="pyret-display">(f :: <span>(<span><span>a</span> -&gt; b</span>)</span>)</span></span> -&gt; <span>List&lt;<span>b</span>&gt;</span></span></tt></div><p>Applies function <tt class="pyretexpr">f</tt> to each element of the list from left to right, and constructs a new <tt class="pyretexpr">List</tt> out of the return values in the corresponding order.</p><p><tt class="pyretexpr">a</tt> represents the type of the elements in the original <tt class="pyretexpr">List</tt>, <tt class="pyretexpr">b</tt> is the type of the elements in the new <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2].map(num-tostring) is [L.list: "1", "2"]
  [L.list: 1, 2].map(lam(n): n + 1 end) is [L.list: 2, 3]
  [L.list: 1, 2].map(_ + 1) is [L.list: 2, 3]
  L.empty.map(lam(x): raise("This never happens!") end) is L.empty
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2].map(num-tostring) is [L.list: &quot;1&quot;, &quot;2&quot;] 
    [L.list: 1, 2].map(lam(n): n + 1 end) is [L.list: 2, 3] 
    [L.list: 1, 2].map(_ + 1) is [L.list: 2, 3] 
    L.empty.map(lam(x): raise(&quot;This never happens!&quot;) end) is L.empty 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.each :: <span><span><span class="pyret-display">(f :: <span>(<span><span>a</span> -&gt; Nothing</span>)</span>)</span></span> -&gt; Nothing</span></tt></div><p>Applies <tt class="pyretexpr">f</tt> to each element of the <tt class="pyretexpr">List</tt> from left to right, and returns <tt class="pyretexpr">nothing</tt>.  Because it returns <tt class="pyretexpr">nothing</tt>, use <tt class="pyretexpr">each</tt> instead of <tt class="pyretexpr">map</tt> when the function <tt class="pyretexpr">f</tt> is needed only for its side-effects.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var x = 1
  [L.list: 1, 2].each(lam(n): x := x + n end) is nothing
  x is 4
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var x = 1 
    [L.list: 1, 2].each(lam(n): x := x + n end) is nothing 
    x is 4 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.filter :: <span><span><span class="pyret-display">(f :: <span>(<span><span>a</span> -&gt; Boolean</span>)</span>)</span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Applies function <tt class="pyretexpr">f</tt> to each element of <tt class="pyretexpr">List</tt> from left to right, constructing a new <tt class="pyretexpr">List</tt> out of the elements for which <tt class="pyretexpr">f</tt> returned <tt class="pyretexpr">true</tt>.</p><p>The original <tt class="pyretexpr">List</tt> elements are of type <tt class="pyretexpr">a</tt> and the function <tt class="pyretexpr">f</tt> must return a <tt class="pyretexpr">Boolean</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-is-one(s :: String) -&gt; Boolean:
    string-length(s) == 1
  end
  [L.list: "ab", "a", "", "c"].filter(length-is-one) is [L.list: "a", "c"]
  [L.list: L.empty, L.link(1, L.empty), L.empty].filter(L.is-link)
    is [L.list: L.link(1, L.empty)]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun length-is-one(s :: String) -&gt; Boolean: 
      string-length(s) == 1 
    end 
    [L.list: &quot;ab&quot;, &quot;a&quot;, &quot;&quot;, &quot;c&quot;].filter(length-is-one) is [L.list: &quot;a&quot;, &quot;c&quot;] 
    [L.list: L.empty, L.link(1, L.empty), L.empty].filter(L.is-link) 
      is [L.list: L.link(1, L.empty)] 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.push :: <span><span><span class="pyret-display">(elt :: a)</span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Returns <tt class="pyretexpr">link(elt, self)</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.empty.push("a") is L.link("a", L.empty)
  L.link("a", L.empty).push("b") is L.link("b", L.link("a", L.empty))
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.empty.push(&quot;a&quot;) is L.link(&quot;a&quot;, L.empty) 
    L.link(&quot;a&quot;, L.empty).push(&quot;b&quot;) is L.link(&quot;b&quot;, L.link(&quot;a&quot;, L.empty)) 
 end">(Try it!)</a></p></div><p>In other words, returns a <tt class="pyretexpr">List</tt> with <tt class="pyretexpr">elt</tt> appended to the beginning of the original <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 'a', 'b'].push('c') is [L.list: 'c', 'a', 'b']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 'a', 'b'].push('c') is [L.list: 'c', 'a', 'b'] 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.split-at :: <span><span><span class="pyret-display">(n :: Number)</span></span> -&gt; <span>{<span class="pyret-display">prefix :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">suffix :: <span>List&lt;<span>a</span>&gt;</span></span>}</span></span></tt></div><p>Produces a record containing two <tt class="pyretexpr">List</tt>s, consisting of the items before and the items at-or-after the splitting index of the current <tt class="pyretexpr">List</tt>.  The index is 0-based, so splitting a <tt class="pyretexpr">List</tt> at index <math>n</math> will produce a prefix of length exactly <math>n</math>.  Moreover, <tt class="pyretexpr">append</tt>ing the two <tt class="pyretexpr">List</tt>s together will be equivalent to the original <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 'a', 'b', 'c', 'd'].split-at(2)
    is {prefix: [L.list: "a", "b"], suffix: [L.list: "c", "d"]}
  one-four = L.link(1, L.link(2, L.link(3, L.link(4, L.empty))))
  one-four.split-at(0) is {prefix: L.empty, suffix: one-four}
  one-four.split-at(4) is {prefix: one-four, suffix: L.empty}
  one-four.split-at(2) is
  {prefix: [L.list: 1, 2], suffix: [L.list: 3, 4]}
  one-four.split-at(-1) raises "Invalid index"
  one-four.split-at(5) raises "Index too large"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 'a', 'b', 'c', 'd'].split-at(2) 
      is {prefix: [L.list: &quot;a&quot;, &quot;b&quot;], suffix: [L.list: &quot;c&quot;, &quot;d&quot;]} 
    one-four = L.link(1, L.link(2, L.link(3, L.link(4, L.empty)))) 
    one-four.split-at(0) is {prefix: L.empty, suffix: one-four} 
    one-four.split-at(4) is {prefix: one-four, suffix: L.empty} 
    one-four.split-at(2) is 
    {prefix: [L.list: 1, 2], suffix: [L.list: 3, 4]} 
    one-four.split-at(-1) raises &quot;Invalid index&quot; 
    one-four.split-at(5) raises &quot;Index too large&quot; 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.take :: <span><span><span class="pyret-display">(n :: Number)</span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Given a length <tt class="pyretexpr">n</tt>, returns a new <tt class="pyretexpr">List</tt> containing the first <tt class="pyretexpr">n</tt> items of the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3, 4, 5, 6].take(3) is [L.list: 1, 2, 3]
  [L.list: 1, 2, 3].take(6) raises "Index too large"
  [L.list: 1, 2, 3].take(-1) raises "Invalid index"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3, 4, 5, 6].take(3) is [L.list: 1, 2, 3] 
    [L.list: 1, 2, 3].take(6) raises &quot;Index too large&quot; 
    [L.list: 1, 2, 3].take(-1) raises &quot;Invalid index&quot; 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.drop :: <span><span><span class="pyret-display">(n :: Number)</span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>] Given a length <tt class="pyretexpr">n</tt>, returns a <tt class="pyretexpr">List</tt> containing all but the first <tt class="pyretexpr">n</tt> items of the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3, 4, 5, 6].drop(3) is [L.list: 4, 5, 6]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3, 4, 5, 6].drop(3) is [L.list: 4, 5, 6] 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.get :: <span><span><span class="pyret-display">(n :: Number)</span></span> -&gt; a</span></tt></div><p>Returns the <tt class="pyretexpr">n</tt>th element of the given <tt class="pyretexpr">List</tt>.</p><p>Using an index too large, negative, or not a whole number raises an error.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3]

  l.get(0) is 1
  l.get(4) raises "too large"
  l.get(-1) raises "invalid argument"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3] 

    l.get(0) is 1 
    l.get(4) raises &quot;too large&quot; 
    l.get(-1) raises &quot;invalid argument&quot; 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.set :: <span>(<span><span class="pyret-display">n :: Number</span>, <span class="pyret-display">e :: a</span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Returns a new <tt class="pyretexpr">List</tt> with the same values as the given <tt class="pyretexpr">List</tt> but with the <tt class="pyretexpr">n</tt>th element set to the given value, or raises an error if <tt class="pyretexpr">n</tt> is out of range.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].set(0, 5) is [L.list: 5, 2, 3]
  [L.list: ].set(0, 5) raises "too large"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].set(0, 5) is [L.list: 5, 2, 3] 
    [L.list: ].set(0, 5) raises &quot;too large&quot; 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.foldl :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, Base</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span></span>) -&gt; Base</span></tt></div><p>Computes <tt class="pyretexpr">f(last-elt, ... f(second-elt, f(first-elt, base))...)</tt>.  For <tt class="pyretexpr">empty</tt>, returns <tt class="pyretexpr">base</tt>.</p><p>In other words, <tt class="pyretexpr">.foldl</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the <i>left</i> (hence, fold<bold>l</bold>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 3, 2, 1].foldl(lam(elt, acc): elt + acc end, 10) is 16
  fun combine(elt, acc) -&gt; String:
    tostring(elt) + " - " + acc
  end
  [L.list: 3, 2, 1].foldl(combine, "END") is "1 - 2 - 3 - END"
  L.empty.foldl(combine, "END") is "END"
  [L.list: 3, 2, 1].foldl(L.link, L.empty) is [L.list: 1, 2, 3]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 3, 2, 1].foldl(lam(elt, acc): elt + acc end, 10) is 16 
    fun combine(elt, acc) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    [L.list: 3, 2, 1].foldl(combine, &quot;END&quot;) is &quot;1 - 2 - 3 - END&quot; 
    L.empty.foldl(combine, &quot;END&quot;) is &quot;END&quot; 
    [L.list: 3, 2, 1].foldl(L.link, L.empty) is [L.list: 1, 2, 3] 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.foldr :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, Base</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span></span>) -&gt; Base</span></tt></div><p>Computes <tt class="pyretexpr">f(first-elt, f(second-elt, ... f(last-elt, base)))</tt>.  For <tt class="pyretexpr">empty</tt>, returns <tt class="pyretexpr">base</tt>.</p><p>In other words, <tt class="pyretexpr">.foldr</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the <i>right</i> (hence, fold<bold>r</bold>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 3, 2, 1].foldr(lam(elt, acc): elt + acc end, 10) is 16
  fun combine(elt, acc) -&gt; String:
    tostring(elt) + " - " + acc
  end
  [L.list: 3, 2, 1].foldr(combine, "END") is "3 - 2 - 1 - END"
  empty.foldr(combine, "END") is "END"
  [L.list: 3, 2, 1].foldr(L.link, L.empty) is [L.list: 3, 2, 1]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 3, 2, 1].foldr(lam(elt, acc): elt + acc end, 10) is 16 
    fun combine(elt, acc) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    [L.list: 3, 2, 1].foldr(combine, &quot;END&quot;) is &quot;3 - 2 - 1 - END&quot; 
    empty.foldr(combine, &quot;END&quot;) is &quot;END&quot; 
    [L.list: 3, 2, 1].foldr(L.link, L.empty) is [L.list: 3, 2, 1] 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.member :: <span><span><span class="pyret-display">(elt :: a)</span></span> -&gt; Boolean</span></tt></div><p><span class="margin-note">Passing a <tt class="pyretexpr">Roughnum</tt> as an argument will raise an error.</span> Returns true if the current <tt class="pyretexpr">List</tt> contains the given value, as compared by <tt class="pyretexpr">==</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].member(2) is true
  [L.list: 2, 4, 6].member(3) is false
  [L.list: ].member(L.empty) is false
  [L.list: 1, 2, 3].member(~1) raises "Roughnums"
  [L.list: ~1, 2, 3].member(1) raises "Roughnums"
  [L.list: 1, 2, 3].member(4) is false
  [L.list: 1, 2, 3].member(~4) raises "Roughnums"

  [L.list: 'a'].member('a') is true
  [L.list: false].member(false) is true
  [L.list: nothing].member(nothing) is true
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].member(2) is true 
    [L.list: 2, 4, 6].member(3) is false 
    [L.list: ].member(L.empty) is false 
    [L.list: 1, 2, 3].member(~1) raises &quot;Roughnums&quot; 
    [L.list: ~1, 2, 3].member(1) raises &quot;Roughnums&quot; 
    [L.list: 1, 2, 3].member(4) is false 
    [L.list: 1, 2, 3].member(~4) raises &quot;Roughnums&quot; 

    [L.list: 'a'].member('a') is true 
    [L.list: false].member(false) is true 
    [L.list: nothing].member(nothing) is true 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.append :: <span><span><span class="pyret-display">(other :: <span>List&lt;<span>a</span>&gt;</span>)</span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Produces a new <tt class="pyretexpr">List</tt> with all the elements of the current <tt class="pyretexpr">List</tt>, followed by all the elements of the <tt class="pyretexpr">other</tt> <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2].append([list: 3, 4]) is [L.list: 1, 2, 3, 4]
  L.empty.append([L.list: 1, 2]) is [L.list: 1, 2]
  [L.list: 1, 2].append(empty) is [L.list: 1, 2]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2].append([list: 3, 4]) is [L.list: 1, 2, 3, 4] 
    L.empty.append([L.list: 1, 2]) is [L.list: 1, 2] 
    [L.list: 1, 2].append(empty) is [L.list: 1, 2] 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.last :: <span>() -&gt; a</span></tt></div><p>Returns the last item of the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].last() is 3
  L.empty.last() raises "last of empty list"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].last() is 3 
    L.empty.last() raises &quot;last of empty list&quot; 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.reverse :: <span>() -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Produces a new <tt class="pyretexpr">List</tt> with the items of the original <tt class="pyretexpr">List</tt> in reversed order.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].reverse() is [L.list: 3, 2, 1]
  L.empty.reverse() is L.empty
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].reverse() is [L.list: 3, 2, 1] 
    L.empty.reverse() is L.empty 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.sort :: <span>() -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Produces a new <tt class="pyretexpr">List</tt> whose contents are the same as those of the current <tt class="pyretexpr">List</tt>, sorted by <tt class="pyretexpr">&lt;equality</tt> and <tt class="pyretexpr">==equality</tt>.  This requires that the items of the <tt class="pyretexpr">List</tt> be comparable by <tt class="pyretexpr">&lt;equality</tt> (see <a href="lang/forms.html#s:binop-expr">Binary Operators</a>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 5, 3, 2, 4].sort() is [L.list: 1, 2, 3, 4, 5]
  [L.list: "aaaa", "B", "a"].sort() is [L.list: "B", "a", "aaaa"]
  [L.list: 'a', 1].sort() raises "binop-error"
  [L.list: true, false].sort() raises "binop-error"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 5, 3, 2, 4].sort() is [L.list: 1, 2, 3, 4, 5] 
    [L.list: &quot;aaaa&quot;, &quot;B&quot;, &quot;a&quot;].sort() is [L.list: &quot;B&quot;, &quot;a&quot;, &quot;aaaa&quot;] 
    [L.list: 'a', 1].sort() raises &quot;binop-error&quot; 
    [L.list: true, false].sort() raises &quot;binop-error&quot; 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.sort-by :: <span>(<span><span class="pyret-display">cmp :: <span>(<span>a, a</span>) -&gt; Boolean</span></span>, <span class="pyret-display">eq :: <span>(<span>a, a</span>) -&gt; Boolean</span></span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></span></tt></div><p>Like <tt class="pyretexpr">sort</tt>, but the comparison and equality operators can be specified.  This allows for sorting <tt class="pyretexpr">List</tt>s whose contents are not comparable by <tt class="pyretexpr">&lt;</tt>, or sorting by custom comparisons, for example, sorting by string length instead of alphabetically.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) &gt; string-length(s2)
  end
  fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) == string-length(s2)
  end
  [L.list: 'a', 'aa', 'aaa'].sort-by(length-comparison, length-equality) is
    [L.list: 'aaa', 'aa', 'a']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) &gt; string-length(s2) 
    end 
    fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) == string-length(s2) 
    end 
    [L.list: 'a', 'aa', 'aaa'].sort-by(length-comparison, length-equality) is 
      [L.list: 'aaa', 'aa', 'a'] 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.join-str :: <span><span><span class="pyret-display">(sep :: String)</span></span> -&gt; String</span></tt></div><p>Combines the values of the current <tt class="pyretexpr">List</tt> by converting them to strings with <tt class="pyretexpr">tostring</tt> and joining them with the given separator <tt class="pyretexpr">sep</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].join-str("; ") is "1; 2; 3"
  [L.list: "a", true, ~5.3].join-str(" : ") is "a : true : ~5.3"
  L.empty.join-str("nothing at all") is ""
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].join-str(&quot;; &quot;) is &quot;1; 2; 3&quot; 
    [L.list: &quot;a&quot;, true, ~5.3].join-str(&quot; : &quot;) is &quot;a : true : ~5.3&quot; 
    L.empty.join-str(&quot;nothing at all&quot;) is &quot;&quot; 
 end">(Try it!)</a></p></div><div class="pyret-display"><tt>.join-str-last :: <span>(<span><span class="pyret-display">sep :: String</span>, <span class="pyret-display">last-sep :: String</span></span>) -&gt; String</span></tt></div><p>Combines the values of the current <tt class="pyretexpr">List</tt> by converting them to strings with <tt class="pyretexpr">tostring</tt> and joining them with the given separator <tt class="pyretexpr">sep</tt>. If the list has more than one element, the function will use <tt class="pyretexpr">last-sep</tt> to join the last element instead of the regular <tt class="pyretexpr">sep</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].join-str-last(", ", " and ") is "1, 2 and 3"
  [L.list: "a", true, ~5.3].join-str-last(" : ", " # ") is "a : true # ~5.3"
  L.empty.join-str-last("nothing at all", "really nothing") is ""
  [L.list: 1, 2].join-str-last("a", "b") is "1b2"
  [L.list: 1].join-str-last("a", "b") is "1"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    [L.list: 1, 2, 3].join-str-last(&quot;, &quot;, &quot; and &quot;) is &quot;1, 2 and 3&quot; 
    [L.list: &quot;a&quot;, true, ~5.3].join-str-last(&quot; : &quot;, &quot; # &quot;) is &quot;a : true # ~5.3&quot; 
    L.empty.join-str-last(&quot;nothing at all&quot;, &quot;really nothing&quot;) is &quot;&quot; 
    [L.list: 1, 2].join-str-last(&quot;a&quot;, &quot;b&quot;) is &quot;1b2&quot; 
    [L.list: 1].join-str-last(&quot;a&quot;, &quot;b&quot;) is &quot;1&quot; 
 end">(Try it!)</a></p></div><h2 id="List-Functions" toclevel="2" tocentry="yes">List Functions</h2><p>  These functions are available on the <tt class="pyretexpr">lists</tt> module object.   Some of the functions require the <tt class="pyretexpr">lists</tt> module to be   <tt class="pyretexpr">import</tt>ed, as indicated in the examples.</p><p>  </p><div><pre class="pyret-display">length :: <span><span><span class="pyret-display">(lst :: <span>List&lt;<span>a</span>&gt;</span>)</span></span> -&gt; Number</span></pre><p>Returns the number of elements in the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.length([list: 'a', 'b']) is 2
  L.length(L.empty) is 0
  L.length(L.link("a", L.empty)) is 1
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.length([list: 'a', 'b']) is 2 
    L.length(L.empty) is 0 
    L.length(L.link(&quot;a&quot;, L.empty)) is 1 
 end">(Try it!)</a></p></div></div><p>  </p><div><pre class="pyret-display">get :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">n :: Number</span></span>) -&gt; a</span></pre></div><p>Equivalent to <tt class="pyretexpr">list</tt><tt>.get</tt><tt class="pyretexpr">(n)</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3]

  L.get(l, 0) is 1
  L.get(l, 4) raises "too large"
  L.get(l, -1) raises "invalid argument"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3] 

    L.get(l, 0) is 1 
    L.get(l, 4) raises &quot;too large&quot; 
    L.get(l, -1) raises &quot;invalid argument&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">set :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">n :: Number</span>, <span class="pyret-display">v :: a</span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.set([L.list: 1, 2, 3], 0, 5) is [L.list: 5, 2, 3]
  L.set([L.list: ], 0, 5) raises "too large"
end</pre></div><div><pre class="pyret-display">sort :: <span>(<span>lst :: <span><span>List&lt;<span>A</span>&gt;</span></span></span>)</span></pre><p>Produces a new <tt class="pyretexpr">List</tt> whose contents are the same as those of the current <tt class="pyretexpr">List</tt>, sorted by <tt class="pyretexpr">&lt;equality</tt> and <tt class="pyretexpr">==equality</tt>.  This requires that the items of the <tt class="pyretexpr">List</tt> be comparable by <tt class="pyretexpr">&lt;equality</tt> (see <a href="lang/forms.html#s:binop-expr">Binary Operators</a>).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.sort([L.list: 1, 5, 3, 2, 4]) is [L.list: 1, 2, 3, 4, 5]
  L.sort([L.list: "aaaa", "B", "a"]) is [L.list: "B", "a", "aaaa"]
  L.sort([L.list: 'a', 1]) raises "binop-error"
  L.sort([L.list: true, false]) raises "binop-error"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.sort([L.list: 1, 5, 3, 2, 4]) is [L.list: 1, 2, 3, 4, 5] 
    L.sort([L.list: &quot;aaaa&quot;, &quot;B&quot;, &quot;a&quot;]) is [L.list: &quot;B&quot;, &quot;a&quot;, &quot;aaaa&quot;] 
    L.sort([L.list: 'a', 1]) raises &quot;binop-error&quot; 
    L.sort([L.list: true, false]) raises &quot;binop-error&quot; 
 end">(Try it!)</a></p></div></div><div><pre class="pyret-display">sort-by :: <span>(<span>lst :: (</span>, <span>cmp :: (</span>, <span>eq :: (</span>)</span></pre><p>Like <tt class="pyretexpr">sort</tt>, but the comparison and equality operators can be specified.  This allows for sorting <tt class="pyretexpr">List</tt>s whose contents are not comparable by <tt class="pyretexpr">&lt;equality</tt>,  or sorting by custom comparisons, for example, sorting by string length instead of alphabetically.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) &gt; string-length(s2)
  end
  fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean:
    string-length(s1) == string-length(s2)
  end
  L.sort-by([L.list: 'a', 'aa', 'aaa'], length-comparison, length-equality) is
    [L.list: 'aaa', 'aa', 'a']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun length-comparison(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) &gt; string-length(s2) 
    end 
    fun length-equality(s1 :: String, s2 :: String) -&gt; Boolean: 
      string-length(s1) == string-length(s2) 
    end 
    L.sort-by([L.list: 'a', 'aa', 'aaa'], length-comparison, length-equality) is 
      [L.list: 'aaa', 'aa', 'a'] 
 end">(Try it!)</a></p></div></div><div><pre class="pyret-display">join-str :: <span><span><span class="pyret-display">(sep :: String)</span></span> -&gt; String</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  [L.list: 1, 2, 3].join-str("; ") is "1; 2; 3"
  [L.list: "a", true, ~5.3].join-str(" : ") is "a : true : ~5.3"
  L.empty.join-str("nothing at all") is ""
end</pre></div><p>  </p><div><pre class="pyret-display">range :: <span>(<span><span class="pyret-display">start :: Number</span>, <span class="pyret-display">stop :: Number</span></span>) -&gt; <span>List&lt;<span>Number</span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>check:
  range(0, 0) is [list: ]
  range(0, 1) is [list: 0]
  range(-5, 5) is [list: -5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
end</pre></div><p>  </p><div><pre class="pyret-display">range-by :: <span>(<span><span class="pyret-display">start :: Number</span>, <span class="pyret-display">stop :: Number</span>, <span class="pyret-display">delta :: Number</span></span>) -&gt; <span>List&lt;<span>Number</span>&gt;</span></span></pre></div><p>  </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.range-by(1, 10, 4) is [L.list: 1, 5, 9]
  L.range-by(10, 1, -4) is [L.list: 10, 6, 2]
  L.range-by(3, 20, 9) is [L.list: 3, 12]
  L.range-by(20, 3, 9) is L.empty
  L.range-by(20, 3, -9) is [L.list: 20, 11]
  L.range-by(2, 3, 0) raises "interval of 0"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.range-by(1, 10, 4) is [L.list: 1, 5, 9] 
    L.range-by(10, 1, -4) is [L.list: 10, 6, 2] 
    L.range-by(3, 20, 9) is [L.list: 3, 12] 
    L.range-by(20, 3, 9) is L.empty 
    L.range-by(20, 3, -9) is [L.list: 20, 11] 
    L.range-by(2, 3, 0) raises &quot;interval of 0&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">repeat :: <span>(<span><span class="pyret-display">n :: Number</span>, <span class="pyret-display">e :: a</span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.repeat(0, 10) is L.empty
  L.repeat(3, -1) is [L.list: -1, -1, -1]
  L.repeat(1, "foo") is L.link("foo", L.empty)
  L.repeat(3, L.empty) is [L.list: [L.list: ], [L.list: ], [L.list: ]]
end</pre></div><p>  </p><div><pre class="pyret-display">distinct :: <span><span><span class="pyret-display">(lst :: <span>List&lt;<span>a</span>&gt;</span>)</span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre><p>  Given a <tt class="pyretexpr">List</tt>, returns a new <tt class="pyretexpr">List</tt> containing only one copy of each element   that is duplicated in the <tt class="pyretexpr">List</tt>.</p><p>  The last (latest in the <tt class="pyretexpr">List</tt>) copy is kept.   <tt class="pyretexpr">Roughnums</tt> are not compared for equality, and so will always appear in the   output <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.distinct([L.list: 3, 1, 2, 2, 3, 2]) is [L.list: 1, 3, 2]
  L.distinct([L.list: ~1, ~1]) is-roughly [L.list: ~1, ~1]
  L.distinct([L.list: ~1, ~1, 1]) is-roughly [L.list: ~1, ~1, 1]
  L.distinct([L.list: ~1, ~1, 1, 1]) is-roughly [L.list: ~1, ~1, 1]
  L.distinct([L.list: ~1, ~2, ~3]) is-roughly [L.list: ~1, ~2, ~3]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.distinct([L.list: 3, 1, 2, 2, 3, 2]) is [L.list: 1, 3, 2] 
    L.distinct([L.list: ~1, ~1]) is-roughly [L.list: ~1, ~1] 
    L.distinct([L.list: ~1, ~1, 1]) is-roughly [L.list: ~1, ~1, 1] 
    L.distinct([L.list: ~1, ~1, 1, 1]) is-roughly [L.list: ~1, ~1, 1] 
    L.distinct([L.list: ~1, ~2, ~3]) is-roughly [L.list: ~1, ~2, ~3] 
 end">(Try it!)</a></p></div></div><p>  </p><div><pre class="pyret-display">filter :: <span>(<span><span class="pyret-display">f :: <span>(<span><span>a</span> -&gt; Boolean</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun length-is-one(s :: String) -&gt; Boolean:
    string-length(s) == 1
  end
  L.filter(length-is-one, [L.list: "ab", "a", "", "c"])
    is [L.list: "a", "c"]
  L.filter(is-link, [L.list: L.empty, L.link(1, L.empty), L.empty])
    is [L.list: L.link(1, L.empty)]
end</pre></div><p>  </p><div><pre class="pyret-display">partition :: <span>(<span><span class="pyret-display">f :: <span>(<span><span>a</span> -&gt; Boolean</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>{<span class="pyret-display">is-true :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">is-false :: <span>List&lt;<span>a</span>&gt;</span></span>}</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.partition(lam(e): e &gt; 0 end, [L.list: -1, 1])
    is {is-true: [L.list: 1], is-false: [L.list: -1]}
  L.partition(lam(e): e &gt; 5 end, [L.list: -1, 1])
    is {is-true: [L.list: ], is-false: [L.list: -1, 1]}
  L.partition(lam(e): e &lt; 5 end, [L.list: -1, 1])
    is {is-true: [L.list: -1, 1], is-false: [L.list: ]}
end</pre></div><div><pre class="pyret-display">find :: <span>(<span><span class="pyret-display">f :: <span>(<span><span>a</span> -&gt; Boolean</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>Option&lt;<span>a</span>&gt;</span></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L
import option as O

check:
  L.find(num-is-integer,  [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(100)
  L.find(num-is-rational, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2.5)
  L.find(num-is-negative, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none
  L.find(lam(n): n &lt;= 2 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2)
  L.find(lam(n): n &lt; 1 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none
end</pre><p><a class="show-embed" code="import lists as L 
 import option as O 

 check: 
    L.find(num-is-integer,  [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(100) 
    L.find(num-is-rational, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2.5) 
    L.find(num-is-negative, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none 
    L.find(lam(n): n &lt;= 2 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.some(2) 
    L.find(lam(n): n &lt; 1 end, [L.list: 2.5, 3.5, 100, 2, 4.5]) is O.none 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">split-at :: <span>(<span><span class="pyret-display">n :: Number</span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>{<span class="pyret-display">prefix :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">suffix :: <span>List&lt;<span>a</span>&gt;</span></span>}</span></span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.split-at(2, [L.list: 'a', 'b', 'c', 'd'])
    is {prefix: [L.list: "a", "b"], suffix: [L.list: "c", "d"]}
  L.split-at(0, [L.list: 1, 2, 3, 4])
    is {prefix: L.empty, suffix: [L.list: 1, 2, 3, 4]}
  L.split-at(4, [L.list: 1, 2, 3, 4])
    is {prefix: [L.list: 1, 2, 3, 4], suffix: L.empty}
  L.split-at(2, [L.list: 1, 2, 3, 4])
    is {prefix: [L.list: 1, 2], suffix: [L.list: 3, 4]}
  L.split-at(-1, [L.list: 1, 2, 3, 4]) raises "Invalid index"
  L.split-at(5, [L.list: 1, 2, 3, 4]) raises "Index too large"
end</pre></div><p>  </p><div><pre class="pyret-display">last :: <span>(<span>lst :: <span><span class="pyret-display">lst :: <span>List&lt;<span>A</span>&gt;</span></span></span></span>)</span></pre><p>Returns the last element in <tt class="pyretexpr">lst</tt>.  Raises an error if the <tt class="pyretexpr">List</tt> is empty.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.last([L.list: 1, 3, 5]) is 5
  L.last([L.list: 1]) is 1
  L.last([L.list: ]) raises "last of empty list"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.last([L.list: 1, 3, 5]) is 5 
    L.last([L.list: 1]) is 1 
    L.last([L.list: ]) raises &quot;last of empty list&quot; 
 end">(Try it!)</a></p></div></div><div><pre class="pyret-display">push :: <span>(<span>l :: (</span>, <span>elt :: (</span>)</span></pre><p>Constructs a list with the given element prepended to the front of the given list.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.push(L.empty, "a") is L.link("a", L.empty)
  L.push(L.link("a", empty), "b") is L.link("b", L.link("a", L.empty))
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.push(L.empty, &quot;a&quot;) is L.link(&quot;a&quot;, L.empty) 
    L.push(L.link(&quot;a&quot;, empty), &quot;b&quot;) is L.link(&quot;b&quot;, L.link(&quot;a&quot;, L.empty)) 
 end">(Try it!)</a></p></div></div><p>  </p><div><pre class="pyret-display">append :: <span>(<span>front :: (</span>, <span>back :: (</span>)</span></pre><p>Produce a new <tt class="pyretexpr">List</tt> with the elements of <tt class="pyretexpr">front</tt> followed by the elements of <tt class="pyretexpr">back</tt>.</p><pre class="good-ex">import lists as L

check:
  L.append([L.list: 1, 2, 3], [L.list: 4, 5, 6])
    is [L.list: 1, 2, 3, 4, 5, 6]
  L.append([L.list: ], [L.list: ]) is [L.list: ]
  L.append([L.list: 1], [L.list: 2]) is [L.list: 1, 2]
end</pre><p>Note that it does <i>not</i> change either <tt class="pyretexpr">List</tt>:</p><pre class="bad-ex">import lists as L

check:
  l = [L.list: 1, 2, 3]
  L.append(l, [L.list: 4])
  l is [L.list: 1, 2, 3, 4] # this test fails
end</pre></div><p>  </p><div><pre class="pyret-display">any :: <span>(<span><span class="pyret-display">f :: <span>(<span><span>a</span> -&gt; Boolean</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; Boolean</span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.any(is-number, [L.list: 1, 2, 3]) is true
  L.any(is-string, [L.list: 1, 2, 3]) is false
  L.any(lam(n): n &gt; 1 end, [L.list: 1, 2, 3]) is true
  L.any(lam(n): n &gt; 3 end, [L.list: 1, 2, 3]) is false
end</pre></div><p>  </p><div><pre class="pyret-display">all :: <span>(<span><span class="pyret-display">f :: <span>(<span><span>a</span> -&gt; Boolean</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; Boolean</span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.all(is-number, [L.list: 1, 2, 3]) is true
  L.all(is-string, [L.list: 1, 2, 'c']) is false
  L.all(lam(n): n &gt; 1 end, [L.list: 1, 2, 3]) is false
  L.all(lam(n): n &lt;= 3 end, [L.list: 1, 2, 3]) is true
end</pre></div><p>  </p><div><pre class="pyret-display">all2 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, b</span>) -&gt; Boolean</span>)</span></span>, <span class="pyret-display">lst1 :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">lst2 :: <span>List&lt;<span>b</span>&gt;</span></span></span>) -&gt; Boolean</span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when both <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true
  L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 3], [L.list: 2, 1, 0]) is true
  L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2], [L.list: 2, 1, 0]) is true
  L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 6], [L.list: 2, 1]) is true
  L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true
  L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 0], [L.list: 0, 1]) is true
  L.all2(lam(n, m): n &lt; m end, [L.list: 1], [L.list: 2, 0]) is true
  L.all2(lam(n, m): n &lt; m end, [L.list: 1, 2, 3], L.empty) is true
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true 
    L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 3], [L.list: 2, 1, 0]) is true 
    L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2], [L.list: 2, 1, 0]) is true 
    L.all2(lam(n, m): (n + m) == 3 end, [L.list: 1, 2, 6], [L.list: 2, 1]) is true 
    L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 3], [L.list: 0, 1, 2]) is true 
    L.all2(lam(n, m): n &gt; m end, [L.list: 1, 2, 0], [L.list: 0, 1]) is true 
    L.all2(lam(n, m): n &lt; m end, [L.list: 1], [L.list: 2, 0]) is true 
    L.all2(lam(n, m): n &lt; m end, [L.list: 1, 2, 3], L.empty) is true 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map :: <span>(<span><span class="pyret-display">f :: <span>(<span><span>a</span> -&gt; b</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>b</span>&gt;</span></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map(num-tostring, [L.list: 1, 2]) is [L.list: "1", "2"]
  L.map(lam(x): x + 1 end, [L.list: 1, 2]) is [L.list: 2, 3]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map(num-tostring, [L.list: 1, 2]) is [L.list: &quot;1&quot;, &quot;2&quot;] 
    L.map(lam(x): x + 1 end, [L.list: 1, 2]) is [L.list: 2, 3] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map2 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, b</span>) -&gt; c</span>)</span></span>, <span class="pyret-display">l1 :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">l2 :: <span>List&lt;<span>b</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>c</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when both <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map2(string-append, [L.list: "mis", "mal"], [L.list: "fortune", "practice"])
    is [L.list: "misfortune", "malpractice"]
  L.map2(_ + _, [L.list: "mis", "mal"], [L.list: "fortune", "practice"])
    is [L.list: "misfortune", "malpractice"]
  L.map2(string-append, [L.list: "mis", "mal"], [L.list: "fortune"])
    is [L.list: "misfortune"]
  L.map2(string-append, [L.list: "mis", "mal"], L.empty)
    is L.empty
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map2(string-append, [L.list: &quot;mis&quot;, &quot;mal&quot;], [L.list: &quot;fortune&quot;, &quot;practice&quot;]) 
      is [L.list: &quot;misfortune&quot;, &quot;malpractice&quot;] 
    L.map2(_ + _, [L.list: &quot;mis&quot;, &quot;mal&quot;], [L.list: &quot;fortune&quot;, &quot;practice&quot;]) 
      is [L.list: &quot;misfortune&quot;, &quot;malpractice&quot;] 
    L.map2(string-append, [L.list: &quot;mis&quot;, &quot;mal&quot;], [L.list: &quot;fortune&quot;]) 
      is [L.list: &quot;misfortune&quot;] 
    L.map2(string-append, [L.list: &quot;mis&quot;, &quot;mal&quot;], L.empty) 
      is L.empty 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map3 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, b, c</span>) -&gt; d</span>)</span></span>, <span class="pyret-display">l1 :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">l2 :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">l3 :: <span>List&lt;<span>c</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>d</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun full-name(n1, n2, n3) -&gt; String:
    n1 + " " + n2 + " " + n3
  end
  full-name("Thomas", "Alva", "Edison") is "Thomas Alva Edison"
  L.map3(full-name, [L.list: "Martin", "Mohandas", "Pelé"],
    [L.list: "Luther", "Karamchand"], [L.list: "King", "Gandhi"]) is
  [L.list: "Martin Luther King", "Mohandas Karamchand Gandhi"]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun full-name(n1, n2, n3) -&gt; String: 
      n1 + &quot; &quot; + n2 + &quot; &quot; + n3 
    end 
    full-name(&quot;Thomas&quot;, &quot;Alva&quot;, &quot;Edison&quot;) is &quot;Thomas Alva Edison&quot; 
    L.map3(full-name, [L.list: &quot;Martin&quot;, &quot;Mohandas&quot;, &quot;Pelé&quot;], 
      [L.list: &quot;Luther&quot;, &quot;Karamchand&quot;], [L.list: &quot;King&quot;, &quot;Gandhi&quot;]) is 
    [L.list: &quot;Martin Luther King&quot;, &quot;Mohandas Karamchand Gandhi&quot;] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map4 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, b, c, d</span>) -&gt; e</span>)</span></span>, <span class="pyret-display">l1 :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">l2 :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">l3 :: <span>List&lt;<span>c</span>&gt;</span></span>, <span class="pyret-display">l4 :: <span>List&lt;<span>d</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>e</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun title-name(title, n1, n2, n3) -&gt; String:
    title + " " + n1 + " " + n2 + " " + n3
  end
  L.map4(title-name, [L.list: "Reverend", "Mahātmā"],
    [L.list: "Martin", "Mohandas", "Pele"],
    [L.list: "Luther", "Karamchand"], [list: "King", "Gandhi"]) is
  [L.list: "Reverend Martin Luther King", "Mahātmā Mohandas Karamchand Gandhi"]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun title-name(title, n1, n2, n3) -&gt; String: 
      title + &quot; &quot; + n1 + &quot; &quot; + n2 + &quot; &quot; + n3 
    end 
    L.map4(title-name, [L.list: &quot;Reverend&quot;, &quot;Mahātmā&quot;], 
      [L.list: &quot;Martin&quot;, &quot;Mohandas&quot;, &quot;Pele&quot;], 
      [L.list: &quot;Luther&quot;, &quot;Karamchand&quot;], [list: &quot;King&quot;, &quot;Gandhi&quot;]) is 
    [L.list: &quot;Reverend Martin Luther King&quot;, &quot;Mahātmā Mohandas Karamchand Gandhi&quot;] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>Number, a</span>) -&gt; b</span></span>, <span class="pyret-display">n :: Number</span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>b</span>&gt;</span></span></pre></div><p>  Like map, but also includes a numeric argument for the position in the <tt class="pyretexpr">List</tt>   that is currently being mapped over.</p><p>  </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map_n(num-expt, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 1, 4, 9]
  L.map_n(lam(n, elem): n * elem end, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6]
  L.map_n(_ * _, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6]
  L.map_n(_ * _, 1, [L.list: 2, 2, 2, 2]) is [L.list: 2, 4, 6, 8]
  L.map_n(_ + _, 10, [L.list: 2, 2, 2, 2]) is [L.list: 12, 13, 14, 15]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map_n(num-expt, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 1, 4, 9] 
    L.map_n(lam(n, elem): n * elem end, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6] 
    L.map_n(_ * _, 0, [L.list: 2, 2, 2, 2]) is [L.list: 0, 2, 4, 6] 
    L.map_n(_ * _, 1, [L.list: 2, 2, 2, 2]) is [L.list: 2, 4, 6, 8] 
    L.map_n(_ + _, 10, [L.list: 2, 2, 2, 2]) is [L.list: 12, 13, 14, 15] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map2_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>Number, a, b</span>) -&gt; c</span></span>, <span class="pyret-display">n :: Number</span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>b</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>c</span>&gt;</span></span></pre></div><p>Like <tt class="pyretexpr">map_n</tt>, but for two-argument functions.</p><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.map2_n(lam(n, a, b): n * (a + b) end, 10,
    [L.list: 2, 2, 2, 2], [L.list: 0, 3, 9, 12])
    is [L.list: 20, 55, 132, 182]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.map2_n(lam(n, a, b): n * (a + b) end, 10, 
      [L.list: 2, 2, 2, 2], [L.list: 0, 3, 9, 12]) 
      is [L.list: 20, 55, 132, 182] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map3_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>Number, a, b, c</span>) -&gt; d</span></span>, <span class="pyret-display">n :: Number</span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>c</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>d</span>&gt;</span></span></pre></div><p>When the <tt class="pyretexpr">List</tt>s are of different length, the function is only called when all <tt class="pyretexpr">List</tt>s have a value at a given index.  In other words, Pyret iterates over the shortest <tt class="pyretexpr">List</tt> and stops.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun combine(n, l1, l2, l3) -&gt; String:
    string-repeat(l1, n) + string-repeat(l2, n) +
    string-repeat(l3, n)
  end
  combine(2, 'a', 'b', 'c') is "aabbcc"
  L.map3_n(combine, 1, [L.list: 'a', 'a'], [L.list: 'b', 'b'],
    [L.list: 'c', 'c']) is [L.list: 'abc', 'aabbcc']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun combine(n, l1, l2, l3) -&gt; String: 
      string-repeat(l1, n) + string-repeat(l2, n) + 
      string-repeat(l3, n) 
    end 
    combine(2, 'a', 'b', 'c') is &quot;aabbcc&quot; 
    L.map3_n(combine, 1, [L.list: 'a', 'a'], [L.list: 'b', 'b'], 
      [L.list: 'c', 'c']) is [L.list: 'abc', 'aabbcc'] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">map4_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>Number, a, b, c, d</span>) -&gt; e</span></span>, <span class="pyret-display">n :: Number</span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>c</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>d</span>&gt;</span></span></span>) -&gt; <span>List&lt;<span>e</span>&gt;</span></span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fun combine(n, l1, l2, l3, l4) -&gt; String:
    string-repeat(l1, n) + string-repeat(l2, n) +
    string-repeat(l3, n) + string-repeat(l4, n)
  end
  combine(2, 'a', 'b', 'c', 'd') is "aabbccdd"
  L.map4_n(combine, 1, L.repeat(3, 'a'), L.repeat(3, 'b'),
    L.repeat(3, 'c'), L.repeat(3, 'd')) is
  [L.list: 'abcd', 'aabbccdd', 'aaabbbcccddd']
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fun combine(n, l1, l2, l3, l4) -&gt; String: 
      string-repeat(l1, n) + string-repeat(l2, n) + 
      string-repeat(l3, n) + string-repeat(l4, n) 
    end 
    combine(2, 'a', 'b', 'c', 'd') is &quot;aabbccdd&quot; 
    L.map4_n(combine, 1, L.repeat(3, 'a'), L.repeat(3, 'b'), 
      L.repeat(3, 'c'), L.repeat(3, 'd')) is 
    [L.list: 'abcd', 'aabbccdd', 'aaabbbcccddd'] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">each :: <span>(<span><span class="pyret-display">f :: <span>(<span><span>a</span> -&gt; Nothing</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  one-four = [list: 1, 2, 3, 4]
  block:
    var counter = 0
    L.each(lam(n): counter := counter + n end, one-four)
    counter is 1 + 2 + 3 + 4
    counter is 10
  end
  block:
    var counter = 1
    L.each(lam(n): counter := counter * n end, one-four)
    counter is 1 * 2 * 3 * 4
    counter is 24
  end
end</pre></div><p>  </p><div><pre class="pyret-display">each2 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, b</span>) -&gt; Nothing</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>b</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each2(lam(x, y): counter := counter + x + y end,
    [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10])
  counter is 33
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each2(lam(x, y): counter := counter + x + y end, 
      [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10]) 
    counter is 33 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">each3 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, b, c</span>) -&gt; Nothing</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>c</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each3(lam(x, y, z): counter := counter + x + y + z end,
    [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10], [L.list: 100, 100])
  counter is 222
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each3(lam(x, y, z): counter := counter + x + y + z end, 
      [L.list: 1, 1, 1], [L.list: 10, 10, 10, 10], [L.list: 100, 100]) 
    counter is 222 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">each4 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>a, b, c, d</span>) -&gt; Nothing</span>)</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>c</span>&gt;</span></span>, <span class="pyret-display">lst :: <span>List&lt;<span>d</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each4(lam(w, x, y, z): counter := counter + w + x + y + z end,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100],
    [L.list: 1000, 1000])
  counter is 2222
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each4(lam(w, x, y, z): counter := counter + w + x + y + z end, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100], 
      [L.list: 1000, 1000]) 
    counter is 2222 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">each_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Number, a</span>) -&gt; Nothing</span>)</span></span>, <span class="pyret-display">num :: Number</span>, <span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><p>Like <tt class="pyretexpr">each</tt>, but also includes a numeric argument for the current index in the <tt class="pyretexpr">List</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each_n(lam(i, w): counter := counter + (i * w) end,
    1,
    [L.list: 1, 1, 1])
  counter is 6
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each_n(lam(i, w): counter := counter + (i * w) end, 
      1, 
      [L.list: 1, 1, 1]) 
    counter is 6 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">each2_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Number, a, b</span>) -&gt; Nothing</span>)</span></span>, <span class="pyret-display">num :: Number</span>, <span class="pyret-display">lst1 :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst2 :: <span>List&lt;<span>b</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each2_n(lam(i, w, x): counter := counter + (i * (w + x)) end,
    1,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10])
  counter is 66
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each2_n(lam(i, w, x): counter := counter + (i * (w + x)) end, 
      1, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10]) 
    counter is 66 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">each3_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Number, a, b, c</span>) -&gt; Nothing</span>)</span></span>, <span class="pyret-display">num :: Number</span>, <span class="pyret-display">lst1 :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst2 :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">lst3 :: <span>List&lt;<span>c</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each3_n(lam(i, w, x, y): counter := counter + (i * (w + x + y)) end,
    1,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100])
  counter is 666
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each3_n(lam(i, w, x, y): counter := counter + (i * (w + x + y)) end, 
      1, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100]) 
    counter is 666 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">each4_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Number, a, b, c, d</span>) -&gt; Nothing</span>)</span></span>, <span class="pyret-display">num :: Number</span>, <span class="pyret-display">lst1 :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">lst2 :: <span>List&lt;<span>b</span>&gt;</span></span>, <span class="pyret-display">lst3 :: <span>List&lt;<span>c</span>&gt;</span></span>, <span class="pyret-display">lst4 :: <span>List&lt;<span>d</span>&gt;</span></span></span>) -&gt; Nothing</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  var counter = 0
  L.each4_n(lam(i, w, x, y, z): counter := counter + (i * (w + x + y + z)) end,
    1,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100],
    [L.list: 1000, 1000, 1000])
  counter is 6666
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    var counter = 0 
    L.each4_n(lam(i, w, x, y, z): counter := counter + (i * (w + x + y + z)) end, 
      1, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100], 
      [L.list: 1000, 1000, 1000]) 
    counter is 6666 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">fold-while :: <span>(<span><span class="pyret-display">f :: <span>(<span>Base, Elt</span>) -&gt; <span>Either&lt;<span>Base, Base</span>&gt;</span></span></span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">lst :: <span>List&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L
import either as EI

check:
  fun stop-at-not-one(acc :: Number, n :: Number) -&gt; EI.Either:
    if n == 1:
      EI.left(acc + n)
    else:
      EI.right(acc)
    end
  end

  L.fold-while(stop-at-not-one, 0, [L.list: 1, 1, 1, 0, 1, 1]) is 3
end</pre><p><a class="show-embed" code="import lists as L 
 import either as EI 

 check: 
    fun stop-at-not-one(acc :: Number, n :: Number) -&gt; EI.Either: 
      if n == 1: 
        EI.left(acc + n) 
      else: 
        EI.right(acc) 
      end 
    end 

    L.fold-while(stop-at-not-one, 0, [L.list: 1, 1, 1, 0, 1, 1]) is 3 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">fold :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">lst :: <span>List&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre><p><tt class="pyretexpr">fold</tt> computes <tt class="pyretexpr">f(... f(f(base, first-elt), second-elt) ..., last-elt)</tt>.  For <tt class="pyretexpr">empty</tt>, returns <tt class="pyretexpr">base</tt>.</p><p>In other words, <tt class="pyretexpr">fold</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the left.</p></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.fold((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6
  L.fold((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16

  fun combine(acc, elt) -&gt; String:
    tostring(elt) + " - " + acc
  end
  L.fold(combine, "END", [L.list: 3, 2, 1]) is "1 - 2 - 3 - END"
  L.fold(combine, "END", L.empty) is "END"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.fold((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6 
    L.fold((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16 

    fun combine(acc, elt) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    L.fold(combine, &quot;END&quot;, [L.list: 3, 2, 1]) is &quot;1 - 2 - 3 - END&quot; 
    L.fold(combine, &quot;END&quot;, L.empty) is &quot;END&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">foldl :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">lst :: <span>List&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><p>  Another name for <tt class="pyretexpr">fold</tt>.   </p><div><pre class="pyret-display">foldr :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">lst :: <span>List&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><p>Computes <tt class="pyretexpr">f(f(... f(base, last-elt) ..., second-elt), first-elt)</tt>.  For <tt class="pyretexpr">empty</tt>, returns <tt class="pyretexpr">base</tt>.  In other words, it uses <tt class="pyretexpr">f</tt> to combine <tt class="pyretexpr">base</tt> with each item in the <tt class="pyretexpr">List</tt> starting from the right.</p><p>In other words, <tt class="pyretexpr">foldr</tt> uses the function <tt class="pyretexpr">f</tt>, starting with the <tt class="pyretexpr">base</tt> value, of type <tt class="pyretexpr">Base</tt>, to calculate the return value of type <tt class="pyretexpr">Base</tt> from each item in the <tt class="pyretexpr">List</tt>, of input type <tt class="pyretexpr">Elt</tt>, starting the sequence from the right.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.foldr((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6
  L.foldr((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16

  fun combine(acc, elt) -&gt; String:
    tostring(elt) + " - " + acc
  end
  L.foldr(combine, "END", [L.list: 3, 2, 1]) is "3 - 2 - 1 - END"
  L.foldr(combine, "END", L.empty) is "END"
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.foldr((lam(acc, elt): acc + elt end), 0, [L.list: 3, 2, 1]) is 6 
    L.foldr((lam(acc, elt): acc + elt end), 10, [L.list: 3, 2, 1]) is 16 

    fun combine(acc, elt) -&gt; String: 
      tostring(elt) + &quot; - &quot; + acc 
    end 
    L.foldr(combine, &quot;END&quot;, [L.list: 3, 2, 1]) is &quot;3 - 2 - 1 - END&quot; 
    L.foldr(combine, &quot;END&quot;, L.empty) is &quot;END&quot; 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">fold2 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Base, Elt1, Elt2</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">l1 :: <span>List&lt;<span>Elt1</span>&gt;</span></span>, <span class="pyret-display">l2 :: <span>List&lt;<span>Elt2</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.fold2(lam(acc, elt1, elt2): acc + elt1 + elt2 end,
    11,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10])
    is 44
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.fold2(lam(acc, elt1, elt2): acc + elt1 + elt2 end, 
      11, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10]) 
      is 44 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">fold3 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Base, Elt1, Elt2, Elt3</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">l1 :: <span>List&lt;<span>Elt1</span>&gt;</span></span>, <span class="pyret-display">l2 :: <span>List&lt;<span>Elt2</span>&gt;</span></span>, <span class="pyret-display">l3 :: <span>List&lt;<span>Elt3</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  fold3(lam(acc, elt1, elt2, elt3): acc + elt1 + elt2 + elt3 end,
    111,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100])
    is 444
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    fold3(lam(acc, elt1, elt2, elt3): acc + elt1 + elt2 + elt3 end, 
      111, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100]) 
      is 444 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">fold4 :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Base, Elt1, Elt2, Elt3, Elt4</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">l1 :: <span>List&lt;<span>Elt1</span>&gt;</span></span>, <span class="pyret-display">l2 :: <span>List&lt;<span>Elt2</span>&gt;</span></span>, <span class="pyret-display">l3 :: <span>List&lt;<span>Elt3</span>&gt;</span></span>, <span class="pyret-display">l4 :: <span>List&lt;<span>Elt4</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.fold4(lam(acc, elt1, elt2, elt3, elt4):
    acc + elt1 + elt2 + elt3 + elt4 end,
    1111,
    [L.list: 1, 1, 1],
    [L.list: 10, 10, 10, 10],
    [L.list: 100, 100, 100],
    [list: 1000, 1000])
    is 3333
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.fold4(lam(acc, elt1, elt2, elt3, elt4): 
      acc + elt1 + elt2 + elt3 + elt4 end, 
      1111, 
      [L.list: 1, 1, 1], 
      [L.list: 10, 10, 10, 10], 
      [L.list: 100, 100, 100], 
      [list: 1000, 1000]) 
      is 3333 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">fold_n :: <span>(<span><span class="pyret-display">f :: <span>(<span>(<span>Number, Base, Elt</span>) -&gt; Base</span>)</span></span>, <span class="pyret-display">num :: Number</span>, <span class="pyret-display">base :: Base</span>, <span class="pyret-display">lst :: <span>List&lt;<span>Elt</span>&gt;</span></span></span>) -&gt; Base</span></pre></div><p>    </p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  # for comparison, here is a map_n example:
  L.map_n(lam(index, elt): index * elt end, 0, [L.list: 2, 2, 2, 2])
    is [L.list: 0, 2, 4, 6]
  # this fold_n version adds up the result
  L.fold_n(lam(index, acc, elt): acc + (index * elt) end, 0, 0,
    [L.list: 2, 2, 2, 2])
    is 12
  L.fold_n(lam(index, acc, elt): acc + (index * elt) end, 0, 10,
    [L.list: 2, 2, 2, 2])
    is 22
  L.fold_n(lam(index, acc, elt): acc + (index * elt) end, 10, 0,
    [L.list: 2, 2, 2, 2])
    is 92 because 20 + 22 + 24 + 26
end</pre></div><p>  {</p><p>  Like <tt class="pyretexpr">fold</tt>, but takes a numeric argument for the position in the   <tt class="pyretexpr">List</tt> that is currently being visited.</p><p>  }</p><p>  </p><div><pre class="pyret-display">member :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; Boolean</span></pre></div><div><pre class="pyret-display">member-always :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; Boolean</span></pre></div><div><pre class="pyret-display">member-identical :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; Boolean</span></pre></div><div><pre class="pyret-display">member-now :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; Boolean</span></pre></div><p><tt class="pyretexpr">member</tt> returns <tt class="pyretexpr">true</tt> if <tt class="pyretexpr">List</tt> <tt class="pyretexpr">lst</tt> contains the element <tt class="pyretexpr">elt</tt>, as compared by <tt class="pyretexpr">==</tt>. The other three functions are analogous to <tt class="pyretexpr">member</tt>, but use <tt class="pyretexpr">equal-alwaysequality</tt>, <tt class="pyretexpr">identicalequality</tt>, or <tt class="pyretexpr">equal-nowequality</tt> to perform the comparison. (Thus <tt class="pyretexpr">member-always</tt> is the same as <tt class="pyretexpr">member</tt>; the name is provided for completeness and in case the user wants to make their intent more explicit.)</p><p>Note that if a <tt class="pyretexpr">Roughnum</tt> is present, these functions will raise exceptions. To avoid that, use <tt class="pyretexpr">member3lists</tt> and the analogous related functions.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  L.member([L.list: 1, 2, 3], 2) is true
  L.member([L.list: 2, 4, 6], 3) is false
  L.member([L.list: ], L.empty) is false
  L.member([L.list: 1, 2, 3], ~1) raises "Roughnums"
  L.member([L.list: ~1, 2, 3], 1) raises "Roughnums"

  L.member([L.list: 'a'], 'a') is true
  L.member([L.list: false], false) is true
  L.member([L.list: nothing], nothing) is true
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    L.member([L.list: 1, 2, 3], 2) is true 
    L.member([L.list: 2, 4, 6], 3) is false 
    L.member([L.list: ], L.empty) is false 
    L.member([L.list: 1, 2, 3], ~1) raises &quot;Roughnums&quot; 
    L.member([L.list: ~1, 2, 3], 1) raises &quot;Roughnums&quot; 

    L.member([L.list: 'a'], 'a') is true 
    L.member([L.list: false], false) is true 
    L.member([L.list: nothing], nothing) is true 
 end">(Try it!)</a></p></div><div><pre class="pyret-display">member3 :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><div><pre class="pyret-display">member-always3 :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><div><pre class="pyret-display">member-identical3 :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><div><pre class="pyret-display">member-now3 :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; EqualityResult</span></pre></div><p>These functions are analogous to <tt class="pyretexpr">member</tt>, but use <tt class="pyretexpr">equal-always3equality</tt>, <tt class="pyretexpr">identical3equality</tt>, or <tt class="pyretexpr">equal-now3equality</tt> to perform the comparison. Thus, they do not raise an exception if a <tt class="pyretexpr">Roughnum</tt> is present.</p><div><p><b>Examples:</b></p><pre>import lists as L
import equality as EQ

check:
  L.member3([L.list: 1, 2, 3], ~1) satisfies EQ.is-Unknown
  L.member3([L.list: ~1, 2, 3], 1) satisfies EQ.is-Unknown
end</pre><p><a class="show-embed" code="import lists as L 
 import equality as EQ 

 check: 
    L.member3([L.list: 1, 2, 3], ~1) satisfies EQ.is-Unknown 
    L.member3([L.list: ~1, 2, 3], 1) satisfies EQ.is-Unknown 
 end">(Try it!)</a></p></div><div><pre class="pyret-display">member-with :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span>, <span class="pyret-display">eq :: <span>(<span>(<span>a, a</span>) -&gt; EqualityResult</span>)</span></span></span>) -&gt; EqualityResult</span></pre></div><p><tt class="pyretexpr">member-with</tt> is <tt class="pyretexpr">member</tt> with a custom equality function. Returns an <tt class="pyretexpr">equality.Equal</tt> if the <tt class="pyretexpr">eq</tt> parameter returns <tt class="pyretexpr">equality.Equal</tt> for <tt class="pyretexpr">elt</tt> and any one element of <tt class="pyretexpr">List</tt> <tt class="pyretexpr">lst</tt>.</p><div><p><b>Examples:</b></p><pre>import lists as L
import equality as EQ

check:
  fun equal-length(a :: String, b :: String) -&gt; EQ.EqualityResult:
    if string-length(a) == string-length(b):
      EQ.Equal
    else:
      EQ.NotEqual("Different lengths.", a, b)
    end
  end
  equal-length('tom', 'dad') is EQ.Equal
  equal-length('tom', 'father') satisfies EQ.is-NotEqual

  L.member-with([L.list: 'father', 'pater', 'dad'], 'tom', equal-length)
    is EQ.Equal
  L.member-with([L.list: 'father', 'pater'], 'tom', equal-length)
    satisfies EQ.is-NotEqual
end</pre><p><a class="show-embed" code="import lists as L 
 import equality as EQ 

 check: 
    fun equal-length(a :: String, b :: String) -&gt; EQ.EqualityResult: 
      if string-length(a) == string-length(b): 
        EQ.Equal 
      else: 
        EQ.NotEqual(&quot;Different lengths.&quot;, a, b) 
      end 
    end 
    equal-length('tom', 'dad') is EQ.Equal 
    equal-length('tom', 'father') satisfies EQ.is-NotEqual 

    L.member-with([L.list: 'father', 'pater', 'dad'], 'tom', equal-length) 
      is EQ.Equal 
    L.member-with([L.list: 'father', 'pater'], 'tom', equal-length) 
      satisfies EQ.is-NotEqual 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">reverse :: <span><span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre></div><p>Returns a new <tt class="pyretexpr">List</tt> with all the elements of the original <tt class="pyretexpr">List</tt> in reverse order.</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3, 4]
  L.reverse(l) is [L.list: 4, 3, 2, 1]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3, 4] 
    L.reverse(l) is [L.list: 4, 3, 2, 1] 
 end">(Try it!)</a></p></div><div><pre class="pyret-display">remove :: <span>(<span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span>, <span class="pyret-display">elt :: a</span></span>) -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre></div><p>Returns a new <tt class="pyretexpr">List</tt> with all the elements of the original that are not equal to the specified element (using <tt class="pyretexpr">==equality</tt> as the comparison).</p><div><p><b>Examples:</b></p><pre>import lists as L

check:
  l = [L.list: 1, 2, 3, 4, 3, 2, 1]
  L.remove(l, 2) is [L.list: 1, 3, 4, 3, 1]
end</pre><p><a class="show-embed" code="import lists as L 

 check: 
    l = [L.list: 1, 2, 3, 4, 3, 2, 1] 
    L.remove(l, 2) is [L.list: 1, 3, 4, 3, 1] 
 end">(Try it!)</a></p></div><p>  </p><div><pre class="pyret-display">shuffle :: <span><span><span class="pyret-display">lst :: <span>List&lt;<span>a</span>&gt;</span></span></span> -&gt; <span>List&lt;<span>a</span>&gt;</span></span></pre></div><p>  Returns a new <tt class="pyretexpr">List</tt> with all the elements of the original <tt class="pyretexpr">List</tt> in random   order.</p><div><p><b>Examples:</b></p><pre>import lists as L
import sets as S

check:
  l = [L.list: 1, 2, 3, 4]
  l-mixed = L.shuffle(l)
  S.list-to-set(l-mixed) is S.list-to-set(l)
  l-mixed.length() is l.length()
end</pre><p><a class="show-embed" code="import lists as L 
 import sets as S 

 check: 
    l = [L.list: 1, 2, 3, 4] 
    l-mixed = L.shuffle(l) 
    S.list-to-set(l-mixed) is S.list-to-set(l) 
    l-mixed.length() is l.length() 
 end">(Try it!)</a></p></div></div></root>
    <hr/>
    The current page is trove/lists.html.
    The previous page is <a href = "../trove/pick.html">../trove/pick.html</a>.
    The next page is <a href = "../trove/sets.html">../trove/sets.html</a>.
    </div>
  </body>
</html>