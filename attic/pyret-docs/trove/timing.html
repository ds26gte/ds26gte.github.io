<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <link rel="stylesheet" href="../styles.css">
  <head>
    <title>Timing</title>
  </head>
  <body>
    <div class="container">
    <root><div><h1 id="timing" toclevel="1" tocentry="yes">Timing</h1><h2 id="Background-and-Caveat" toclevel="2" tocentry="yes">Background and Caveat</h2><p>This library gives you the ability to determine how long a computation takes.</p><p>Please note that measuring the time of a computation can be very complicated. Naturally, the same computation may take very different amounts of time on different machines. However, it may also take very different amounts of time on the same machine, depending on what else is running. It may take very different amounts of time <i>even if</i> nothing else is running (are you sure?), because of cache effects, JIT effects, and so on.</p><p>Therefore, you should either: <itemlist><item>only use this library in an advisory way, not treat its answers as being too precise; and/or</item><item>perform timing many times and use appropriate statistical methods to get a better sense of the true running time</item></itemlist> Nevertheless, this library can be very useful for rough approximation and for telling apart coarse differences in running time.</p><h2 id="Design-and-Rationale" toclevel="2" tocentry="yes">Design and Rationale</h2><p>The timing functions all take <i>thunks</i>, i.e., procedures of no argument, to represent the computation that needs to be timed.</p><p>It is important to understand why this is. Suppose we want to know how long it takes to run some computation, <tt class="pyretexpr">f(x)</tt>. Pretend we had a function called <tt class="pyretexpr">time-of</tt> and could just call <tt class="pyretexpr">time-of(f(x))</tt>. We might expect this to determine how long it takes for <tt class="pyretexpr">f(x)</tt> to run.</p><p>Unfortunately, that is not how functions work in Pyret (or indeed in most programming languages: see the <a href="https://smol-tutor.xyz/">Standard Model of Languages</a>). Instead, Pyret first turns <tt class="pyretexpr">f(x)</tt> into a value (if it has one), and it is this <i>value</i> that is supplied to <tt class="pyretexpr">time-of(…)</tt>. Therefore, <tt class="pyretexpr">time-of</tt> already receives a value, which takes effectively no time to compute; so no matter how long <tt class="pyretexpr">f(x)</tt> took, <tt class="pyretexpr">time-of(f(x))</tt> will return essentially the same answer, which will effectively be <tt class="pyretexpr">0</tt>.</p><p>In contrast, a thunk reflects the <i>computation</i> rather than its answer. When this thunk is passed to a timing function, the computation has not yet occurred. Instead, the timing function can call it in an appropriate way, and can thus measure how long it ran.</p><p>All the functions rely on the underlying system timers, which use <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a> time. There are many online converters that will translate the resulting value into something human-readable.</p><h2 id="timing-functions" toclevel="2" tocentry="yes">Functions</h2><p>This library provides three functions. <tt class="pyretexpr">time-now</tt> is a low-level primitive useful for building the other two. Most of the time you would not use it directly, but we provide it in case you need fine-grained control that doesn’t easily fit the other two.</p><p>The other two functions determine how long a given thunk takes to run by running it. They differ in what they produce as a result. One only produces the <i>time</i> that it takes (not to be confused with the value produced by the thunk, which may also be a number, and even a positive integer that is similar to the returned time); the other produces both the duration and the value produced by the computation.</p><p>  </p><div><pre class="pyret-display">time-only :: <span>(<span>f -&gt; <span>() -&gt; T</span></span>)</span></pre><p>Consumes a thunk, runs it, and produces how long it takes to run (in milliseconds).</p><div><pre>include timing

check:
  produce-0-to-9 = {(): range(0, 10)}
  fun takes-less-than-1-second(t): t &lt; 1000 end
  # NOTE: may fail on a sufficiently slooooow machine!
  time-only(produce-0-to-9) satisfies takes-less-than-1-second
end</pre><p><a class="show-embed" code="include timing 

 check: 
    produce-0-to-9 = {(): range(0, 10)} 
    fun takes-less-than-1-second(t): t &lt; 1000 end 
    # NOTE: may fail on a sufficiently slooooow machine! 
    time-only(produce-0-to-9) satisfies takes-less-than-1-second 
 end">(Try it!)</a></p></div></div><p>  </p><div><pre class="pyret-display">time-value :: <span>(<span>f -&gt; <span>() -&gt; T</span></span>)</span></pre><p>Consumes a thunk, runs it, and produces both how long it takes to run (in milliseconds) and the value that it produces.</p><div><pre>include timing

check:
  produce-0-to-9 = {(): range(0, 10)}
  fun takes-less-than-1-second(t): t &lt; 1000 end
  {t; v} = time-value(produce-0-to-9)
  # NOTE: may fail on a sufficiently slooooow machine!
  t satisfies takes-less-than-1-second
  v is [list: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
end</pre><p><a class="show-embed" code="include timing 

 check: 
    produce-0-to-9 = {(): range(0, 10)} 
    fun takes-less-than-1-second(t): t &lt; 1000 end 
    {t; v} = time-value(produce-0-to-9) 
    # NOTE: may fail on a sufficiently slooooow machine! 
    t satisfies takes-less-than-1-second 
    v is [list: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 
 end">(Try it!)</a></p></div></div><p>  </p><div><pre class="pyret-display">time-now :: <span>()</span></pre><p>Returns the current time, in milliseconds since the start of the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a>. Since this value changes every millisecond, it is very difficult to write a test where it succeeds; it’s much easier to write a test that it fails.</p><div><pre>include timing

check:
  time-now() is-not 1740426758012
end</pre><p><a class="show-embed" code="include timing 

 check: 
    time-now() is-not 1740426758012 
 end">(Try it!)</a></p></div><p>We can therefore reconstruct, for instance, <tt class="pyretexpr">time-only</tt> as follows:</p><pre>fun my-time-only(thunk):
  start-time = time-now()
  _ = thunk()
  end-time = time-now()
  end-time - start-time
end</pre></div></div></root>
    <hr/>
    The current page is trove/timing.html.
    The previous page is <a href = "../trove/matrices.html">../trove/matrices.html</a>.
    The next page is <a href = "../trove/fetch.html">../trove/fetch.html</a>.
    </div>
  </body>
</html>