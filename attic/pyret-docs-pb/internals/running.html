<!doctype html>
<html lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
  <script type="module" src="../embed-api.js"></script>
  <script src="../codemirror.js"></script>
  <script src="../runmode.js"></script>
  <script src="../pyret.js"></script>
  <script src="../hilite.js"></script>
  <link rel="stylesheet" type="text/css" href="../codemirror.css" title="default"/>
  <link rel="stylesheet" type="text/css" href="../pyret.css" title="default"/>
  <link rel="stylesheet" type="text/css" href="../styles.css" title="default"/>
  <head>
    <title>Running Code (Safely)</title>
  </head>
  <body>
    <div class="container">
    <root><h1 id="s:running" toclevel="1" tocentry="yes">Running Code (Safely)</h1><p>In order to support both responsive evaluation and simulate an arbitrarily deep stack, Pyret has an evaluation model that does not exactly match JavaScript’s.</p><p>When a Pyret function is compiled, it gets an extra <span class="pyret-highlight"><tt class="pyretexpr">try/catch</tt></span> handler wrapped around it that listens for special Pyret-specific exceptions.  That means when it’s running, we can think of the stack frame of the function as having an extra layer around it:</p><p><img src="frames.png"/></p><p>When a Pyret function detects (via a counter stored in the runtime) that the stack depth is approaching the maximum that JavaScript can tolerate, it throws an exception:</p><p><img src="exception.png"/></p><p>When the exception is encountered by one of the handlers, it attaches enough information to the exception to restart the handler’s frame before allowing the exception to coninue:</p><p><img src="first-frame.png"/></p><p>This continues through the entire stack, storing a list of Pyret stack frames stored on the exception object:</p><p><img src="many-frames.png"/></p><p>Until finally, the entire Pyret stack is reified on the exception object, and all the JavaScript frames from the Pyret functions are gone:</p><p><img src="stack.png"/></p><p>This exception is caught by Pyret’s toplevel, which restarts the <i>bottommost</i> element of the stack, which now has nothing above it, instead of a full stack.  It can make progress with the available JS stack.  The runtime can store the existing Pyret stack and add to it if the JS stack runs out again.</p><p>This works just fine if all that’s running is Pyret code.  However, there are two cases where JavaScript code that interacts with Pyret needs to be handled delicately.</p><h2 id="JS-Pretending-to-be-Pyret" toclevel="2" tocentry="yes">JS Pretending to be Pyret</h2><p>Many library use cases, like data structures and convenience functions, are written as JavaScript code that emulates Pyret function calls.  However, if JS code calls back into Pyret code, care is in order.  Here’s what the stack looks like if Pyret calls JavaScript that calls Pyret again:</p><p><img src="callback.png"/></p><p>If the stack limit is reached and an exception thrown, the bottom Pyret frames will have their intermediate state stored:</p><p><img src="callback-bottom.png"/></p><p>But the pure JavaScript frames have no stack management handlers installed, so they are skipped without consideration for any intermediate state they may contain.</p><p><img src="callback-middle.png"/></p><p>The resulting stack doesn’t accurately represent the program that was being executed.  It is, quite literally, nonsense, because a Pyret function will return directly to another Pyret function, ignoring all of the intermediate JavaScript logic.  Using this pattern without any guards or protection will create programs that simply produce wrong answers.</p><p><img src="callback-final.png"/></p><p>Pyret’s runtime defines a function called <internal-id>RuntimesafeCall</internal-id> that allows pure JavaScript to participate in the Pyret stack.</p><div><pre class="pyret-display">Runtime.safeCall((→ a), (a → b)) !→ b</pre></div><p><internal-id>RuntimesafeCall</internal-id> combines the two provided functions in a special stack frame:</p><p><img src="safe-call.png"/></p><p>The first argument is called, and in normal execution, its return value is passed to the second function.  The second function’s return value is then the return value of the whole call.  However, if a stack exception occurs, the <i>second</i> function is registered as the frame stored on the Pyret stack:</p><p><img src="safe-call-catch.png"/></p><p>This means that in the simulated stack, the second callback (blue in the picture), will receive the result of the last call to a stack-managed function from the first callback (pink in the picture):</p><p><img src="return-1.png"/></p><p>Then, when the second callback (blue) is run, it’s return value will be passed up the stack to the Pyret function that called into the use of <span class="pyret-highlight"><tt class="pyretexpr">safeCall</tt></span>:</p><p><img src="return-2.png"/></p><p>The usual pattern for using <internal-id>RuntimesafeCall</internal-id> is with a single call to a Pyret function, or another function that calls a Pyret function.  As long as all the calls to Pyret functions are in tail position in safeCalls, no information will be lost.</p><p><b>Examples</b></p><p>Calling <span class="pyret-highlight"><tt class="pyretexpr">torepr</tt></span> can consume a lot of stack (for serializing large data structures), so JavaScript-implemented <span class="pyret-highlight"><tt class="pyretexpr">torepr</tt></span> methods often need to use <span class="pyret-highlight"><tt class="pyretexpr">safeCall</tt></span>.  For example, a function that does work with the result of a <span class="pyret-highlight"><tt class="pyretexpr">torepr</tt></span> call needs to use <span class="pyret-highlight"><tt class="pyretexpr">safeCall</tt></span> to capture the result correctly:</p><pre class="nothing_special">function makeDataType(val) {
  function torepr(self, toreprRecursive) {
    return runtime.safeCall(function() {
      return toreprRecursive.app(val);
    }, function(valAsString) {
      return "Value was: " + valAsString
    })
  }
  return runtime.makeObject({
    _torepr: runtime.makeMethod1(torepr)
  });
}</pre><div class="margin-note">We haven’t found a way to turn this into an error, so testing and code review are the only real protections.  The best way to test for this kind of problem is to pass deeply recursive callbacks into the JS library, which can trigger odd behavior.  If you have suggestions for patterns or tools to make this less error-prone, let us know.</div><p>If instead it was written as:</p><pre class="nothing_special">function makeDataType(val) {
  function torepr(self, toreprRecursive) {
    var valAsString = toreprRecursive.app(val);
    return "Value was: " + valAsString;
  }
  return runtime.makeObject({
    _torepr: runtime.makeMethod1(torepr)
  });
}</pre><p>then, a <span class="pyret-highlight"><tt class="pyretexpr">torepr</tt></span> call on the resulting object could use up all the stack while evaluating <span class="pyret-highlight"><tt class="pyretexpr">toreprRecursive.app(val)</tt></span>, causing the string concatenation in the return to simply be ignored.</p><h2 id="Asynchronous-JS-and-Pyret" toclevel="2" tocentry="yes">Asynchronous JS and Pyret</h2><p>Lots of JavaScript code works asynchronously, with callbacks that are registered to be invoked after the stack clears.  The control flow of these callbacks interacts with Pyret’s stack infrastructure.  Most callback-using JavaScript code simply returns <span class="pyret-highlight"><tt class="pyretexpr">undefined</tt></span> immediately, and all further computation happens in either success or failure continuations.  This doesn’t play nicely with Pyret’s stack-based control flow, because Pyret functions expect a meaningful return value.</p><div class="margin-note">We could require that all Pyret code that uses JS callback libraries use Pyret callbacks, but it’s hardly elegant to require that all students learn to use callbacks before they can import an image.</div><p><img src="ajax.png"/></p><p>In order to weave the control flow of Pyret through the success and failure continuations of callbacks, the runtime provides a way to pause and reify the Pyret stack for later resumption.</p><div><pre class="pyret-display">Runtime.pauseStack((Restarter → Undefined)) → Undefined</pre></div><p>When <span class="pyret-highlight"><tt class="pyretexpr">pauseStack</tt></span> is called, a special <i>pause</i> exception is thrown, that stores the callback passed in as the argument to <span class="pyret-highlight"><tt class="pyretexpr">pauseStack</tt></span>.  The pause exception collects Pyret stack frames in the same way as a stack exception, it just keeps track of the callback as well:</p><p><img src="pause.png"/></p><p>The pause exception is handled specially at the toplevel, by creating a <span class="pyret-highlight"><tt class="pyretexpr">Restarter</tt></span> object that is capable of resuming, stopping, or signalling an error at the point the Pyret stack was paused.  This <span class="pyret-highlight"><tt class="pyretexpr">Restarter</tt></span> is passed into the callback argument to <span class="pyret-highlight"><tt class="pyretexpr">pauseStack</tt></span>, which can then <i>asynchronously</i> restart the Pyret process:</p><pre class="nothing_special">Restarter :: {
  resume: PyretVal → Undefined,
  error: (PyretError U PyretVal) → Undefined,
  break: → Undefined
}</pre><p>Example:</p><pre class="nothing_special">myRuntime.pauseStack(function(restarter) {
  var request = $.ajax("/api");
  request.then(function(answer) {
    restarter.resume(toPyretResponse(answer));
  });
  request.fail(function(err) {
    restarter.error(myRuntime.ffi.makeMessageException("Request failed"));
  });
});</pre><p>Some things to note:</p><ul><li>It is an error to call more than one of <span class="pyret-highlight"><tt class="pyretexpr">resume</tt></span>/<span class="pyret-highlight"><tt class="pyretexpr">error</tt></span>/<span class="pyret-highlight"><tt class="pyretexpr">break</tt></span>: a <span class="pyret-highlight"><tt class="pyretexpr">Restarter</tt></span> is not a continuation that can be invoked multiple times.</li><li>If none of the callbacks are ever called, from the point of view of the running Pyret process, the program is in an infinite loop (for example, the IDE may show a “running” GIF forever).  This includes the case where executing the callback ends in an error.  So, using <span class="pyret-highlight"><tt class="pyretexpr">pauseStack</tt></span> requires some care in writing robust JavaScript code, or odd behavior can result.</li></ul><div><pre class="pyret-display">Runtime.schedulePause((Restarter → Undefined)) → Undefined</pre></div><p>Similar to <internal-id>RuntimepauseStack</internal-id>, but used from outside the runtime (e.g. in the REPL), to schedule a pause.  Since the point of interruption (and resumption) is not predictable from outside the Pyret thread, the <span class="pyret-highlight"><tt class="pyretexpr">resume</tt></span> method of the <span class="pyret-highlight"><tt class="pyretexpr">Restarter</tt></span> for <span class="pyret-highlight"><tt class="pyretexpr">schedulePause</tt></span> ignores any value passed to it; it always resumes the computation exactly as it would have continued had it not been paused.</p><p>If <internal-id>RuntimeschedulePause</internal-id> is called during a synchronous <internal-id>Runtimerun</internal-id>, the runtime will still wait until the next stack exception to call the given <span class="pyret-highlight"><tt class="pyretexpr">Restarter</tt></span>.  If called during an asynchronous run, the next time a setTimeout is triggered, the <span class="pyret-highlight"><tt class="pyretexpr">Restarter</tt></span> will be called.</p><p>If <internal-id>RuntimeschedulePause</internal-id> is called multiple times before Pyret checks for scheduled pauses, the last call’s <span class="pyret-highlight"><tt class="pyretexpr">Restarter</tt></span> is used, and any earlier calls are ignored.</p><h2 id="Starting-a-New-Pyret-Stack" toclevel="2" tocentry="yes">Starting a New Pyret Stack</h2><p>The description of <internal-id>RuntimesafeCall</internal-id> and <internal-id>RuntimepauseStack</internal-id> assume that the calls are being made in a running Pyret execution context.  This is the case for most library code that would get run via <span class="pyret-highlight"><tt class="pyretexpr">import</tt></span>, and be using external APIs.</p><p>However, some applications may need to start new Pyret instances from scratch. In order for the special <span class="pyret-highlight"><tt class="pyretexpr">PauseExceptions</tt></span> and <span class="pyret-highlight"><tt class="pyretexpr">StackExceptions</tt></span> to be caught at the top level and correctly restarted, the handlers need to be correctly installed.  This is done by <internal-id>Runtimerun</internal-id>:</p><div><pre class="pyret-display">Runtime.run(
  (Runtime, Namespace → a)
  Namespace
  RunOptions
  (RunResult&lt;a&gt; → Undef)
)
→ Undef</pre></div><p>The first argument is the program to run, which takes a <span class="pyret-highlight"><tt class="pyretexpr">Runtime</tt></span> (which is always the same as the runtime <span class="pyret-highlight"><tt class="pyretexpr">run</tt></span> is called on), and a <span class="pyret-highlight"><tt class="pyretexpr">Namespace</tt></span> as arguments.  Pyret programs are compiled to look for any global identifiers in <span class="pyret-highlight"><tt class="pyretexpr">Namespace</tt></span>.  The second argument is the <span class="pyret-highlight"><tt class="pyretexpr">Namespace</tt></span> passed to the function to run (adding to the namespace is useful for e.g. putting REPL-defined identifiers into scope).  <span class="pyret-highlight"><tt class="pyretexpr">RunOptions</tt></span> has only one field: <span class="pyret-highlight"><tt class="pyretexpr">sync</tt></span>, which is a boolean indicating if the program should be run <i>synchronously</i> or not.  This is described more in <a href="/Users/ds26gte/src/pyret-docs-pb/internals/running.html#s:synchronous">Synchronous vs. Asynchronous Execution</a>.  Finally, the last argument is a callback that gets either a <span class="pyret-highlight"><tt class="pyretexpr">Success</tt></span> or <span class="pyret-highlight"><tt class="pyretexpr">Failure</tt></span> result, described in <a href="/Users/ds26gte/src/pyret-docs-pb/internals/running.html#s:result-structures">Result Data Structures</a>.</p><p>Only one <span class="pyret-highlight"><tt class="pyretexpr">run</tt></span> call can be active for a given <span class="pyret-highlight"><tt class="pyretexpr">runtime</tt></span> at once.  If it is called more than once, an error that says <span class="pyret-highlight"><tt class="pyretexpr">“run called while already running”</tt></span> will be raised.  New calls to <internal-id>Runtimerun</internal-id> should only be used at the logical start of a Pyret program’s execution (e.g. running the definitions window, running a REPL entry, running a standalone test case start-to-finish), not for loading libraries, interacting with native JS APIs, or managing asynchronous APIs.</p><h3 id="s:synchronous" toclevel="3" tocentry="yes">Synchronous vs. Asynchronous Execution</h3><p>The <span class="pyret-highlight"><tt class="pyretexpr">sync</tt></span> flag passed to <internal-id>Runtimerun</internal-id> changes how stack pauses are managed.  In synchronous mode (<span class="pyret-highlight"><tt class="pyretexpr">sync: true</tt></span>), when a stack or pause exception reaches the top level, it is immediately restarted.  This is the fastest option, and is the default for Pyret running from the command-line.</p><p>However, when executing synchronously, Pyret never yields to the event loop. If <span class="pyret-highlight"><tt class="pyretexpr">sync: true</tt></span> were used in a context with user interaction, like a browser page, the UI thread would never get a chance to run.  If <span class="pyret-highlight"><tt class="pyretexpr">sync</tt></span> is set to <span class="pyret-highlight"><tt class="pyretexpr">false</tt></span>, when the stack limit is reached, or a pause execption is thrown, it is restarted after first yielding to the event loop (using <span class="pyret-highlight"><tt class="pyretexpr">setTimeout</tt></span>). This provides a window for the browser to process click and key events, avoiding page lockup.  This also gives the ability for UI elements to trigger calls to <internal-id>RuntimeschedulePause</internal-id>, which will call back to the pauser the next time the Pyret thread restarts.</p><h3 id="s:result-structures" toclevel="3" tocentry="yes">Result Data Structures</h3><div><pre class="pyret-display">Runtime.makeSuccessResult(a) → SuccessResult&lt;a&gt;</pre></div><p>Represents a successful completion of a Pyret execution with <internal-id>Runtimerun</internal-id>.</p><div><pre class="pyret-display">Runtime.isSuccessResult(Any) → Bool</pre></div><p>Checks if a value is a <span class="pyret-highlight"><tt class="pyretexpr">SuccessResult</tt></span>.</p><div><pre class="pyret-display">Runtime.SuccessResult.result :: Any</pre></div><p>The field that stores the answer of a <span class="pyret-highlight"><tt class="pyretexpr">SuccessResult</tt></span>.</p><div><pre class="pyret-display">Runtime.makeFailureResult(a) → FailureResult&lt;a&gt;</pre></div><p>Represents a Pyret execution with <internal-id>Runtimerun</internal-id> that ended in some kind of exception (either from Pyret or an internal JavaScript error).</p><div><pre class="pyret-display">Runtime.isFailureResult(Any) → Bool</pre></div><p>Checks if a value is a <span class="pyret-highlight"><tt class="pyretexpr">FailureResult</tt></span>.</p><div><pre class="pyret-display">Runtime.FailureResult.exn :: Any</pre></div><p>The field that stores the exception value of a <span class="pyret-highlight"><tt class="pyretexpr">FailureResult</tt></span>.</p></root>
    <hr/>
    <!-- The current page is internals/running.html. -->
    <a class="floatleft" href="../internals/ffi-helpers.html">⏴⏴⏴</a>
    <a class="floatright" href="../internals/modules.html">⏵⏵⏵</a>
    </div>
  </body>
</html>